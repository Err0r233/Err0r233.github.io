[{"title":"看看ssti","date":"2023-09-09T04:48:14.000Z","url":"/posts/42279.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"整理一下有关服务端模板注入(server side template injection)的东西 开局一张经典老图，判断类型： Python的一些特性 在python中，有一些独特的特性： python中的类均继承于object基类 python中还有一系列的魔术方法，一些函数的实现也是通过直接调用魔术方法的，常用的魔术方法有: __init__: 构造函数，一般是接受类初始化的参数，并且进行一系列初始化的操作 __len__: 返回对象的长度 __str__: 返回对象的字符串表示 __getattr__: 对象是否含有某属性，等价于函数方法getattr(a, 'b')，相当于a.b __subclasses__: 返回当前类的所有子类，一般用于object类中，然后找到带有os的模块实现rce python的类中也有一些魔术属性： __dict__: 可以查看内部所有属性名和属性值组成的字典 __class__:返回当前对象所属的类，例如''.__class__会返回&lt;class 'str'&gt;。拿到类后就可以构造函数生成新的对象，如''.__class__(1234)等价于str(1234)，即'1234' __base__: 返回当前类的基类，例如str.__base__就会返回&lt;class 'str'&gt; 此外还有一些重要的函数： __mro__ 返回一个包含对象所继承的基类元组，按顺序解析 __globals__返回所有全局变量 __builtins__ 包含当前运行环境中默认的所有函数，如str、chr等，可以通过拿到__builtins__，然后__import__('os').system('')进行RCE 通过从变量 -&gt; 对象 -&gt; 基类 -&gt; 子类 -&gt; 全局变量的方式，就可以进行ssti 一般思路：寻找到object基类后，引入os._wrap_close，然后寻找popen即可进行 一些参数 payload jinja2 smarty smarty是一个基于PHP开发的php模板引擎，所以其payload与我们熟知的PHP命令执行十分相似： twig ssti绕过过滤 对于关键字过滤： 1、关键字的拼接 非常常见的方法，在python中ab是可以又'a'+'b'拼接而成的，也就是说：__class__ = '__cla'+'ss__' 例如： 但实际上在jinja2内，&quot;cla&quot;&quot;ss&quot;等同于&quot;class&quot; 2、关键字倒序输出、替换 简单地说就是类似于strrev()的操作，通过['__ssalc__'][::-1]输出__class__： 当然，倒序输出还可以使用reverse: 关键字替换： 3、ascii转换： 利用python的格式化字符串特性: 4、编码绕过 hex编码和unicode编码都可以，例如： 5、chr函数，前提是需要通过__builtins__找到chr函数： 6、jinja2内可以利用~进行拼接： 7、大小写转换 前提只是过滤小写： 8、attr 当然，前文已经讲过attr能够在同时过滤点号和中括号时使用了： 9、join 10、利用请求方式绕过： 例如过滤了__class__ 如果还过滤了 args，可以使用request['values']和attr结合绕过 绕过中括号： 获取单独字符： 1、利用string: 2、利用list配合pop 绕过config参数 适用于一些题目中将flag设置在config中的题： 如果题目有app.config['FLAG'] = os.environ.pop['FLAG']，我们可以直接访问&#123;&#123;config['FLAG']&#125;&#125;或者&#123;&#123;config.FLAG&#125;&#125;得到flag 但是如果过滤了config，我们可以利用self来间接得到config: 过滤下划线_ 利用编码绕过： 删除许多模块，但是没删除reload 仅适用于python2，通过reload恢复所有被删除的模块： 同时有大量过滤 例如过滤： 思想大体是利用没有过滤的模块(可能如lipsum)来构造基础payload 比如没过滤lipsum，就可以先构造出基础payload: 然后再考虑如何构造出关键字 这就要利用到上文的获取单独字符的方法和字符串拼接的方法join进行拼接 然后利用内置的&#123;%set%&#125; &#123;%print%&#125;进行变量设置和打印 逐步组装关键字 然后用print打印结果即可 详情可以看flask ssti的新姿势这篇文章 qwq 参考文章： 服务端模板注入(SSTI) | micgo’s blog Y4tacker - SSTI模板注入及绕过姿势 yu22x - SSTI模板注入绕过(进阶篇)"},{"title":"羊城杯的一些题解及体会","date":"2023-09-04T09:57:26.000Z","url":"/posts/10145.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"打了羊城杯，自我感觉难的挺合理:( 不过我觉得了解到题目出/考的是什么才是重要的:( D0n’t pl4y g4m3!!! 一道考察php反序列化的题目，需要我们访问p0p.php，但是我们一旦访问/p0p.php就会把页面跳转至一个吃豆人游戏中 但是题目就是叫我们不要玩游戏的意思嘛 我开始还以为是什么js题，但是查遍了js，没有什么异常，才回去尝试抓包的 抓包以后发现啥也没有，这下这下了 但是它提示有个hint.zip 下载下来解压后的内容： … 那我只能说hint了个寂寞 没辙啊，p0p.php也不给源码 不过越是不给源码的说明越重要是吧，我们还是得像办法读出p0p.php的内容 注意到服务器的php版本是7.4.21 此时群里的师傅们也都说了7.4.21有这个漏洞： 只需要先关闭自动更新Content-Length，然后按如下图所示： 即可读到源码： 拉取到的p0p.php内容如下： 可以看到是一个php反序列化，而且还有waf 这个waf只会将关键字替换为空，所以我们可以进行双写绕过： syssystemtem只会将中间的system去掉，然后剩下的sys 和 tem 能够组成system 那我们来简单看下这个链子怎么触发吧 总结一下其实链子就是 这里先将exp给大家，然后说一下我先前不懂的点： 为什么name要设置成 name[finish] = &quot;a&quot;的形式 还有是为什么now[YCB1] = &quot;system&quot;的形式 先说说后面那个 如果调用__call()魔术方法的话，会传递两个参数 第一个参数就是我们调用的方法，这里是调用YCB1方法，所以传递了第一个参数叫YCB1 第二个参数就是我们调用到的方法传递的参数，比如这里的YCB1方法有两个参数： rce和rce1，那么这两个参数会一并传递过去，并作为数组存储 而这里call_user_func调用了call的两个参数： now[$name] 和ary[0] call传入的两个参数就叫name 和 ary 答案很明显了吧，name其实就是我们的YCB1方法，而ary数组内有2个元素，一个是rce，另一个是rce1，这里的ary[0]相当于rce 其实就是now[YCB1](rce) 我们将now设置为数组，且键名就叫YCB1，键值为system，其实就是system(rce) 再将rce设置为ls 就相当于执行system('ls'); 那另外一个的话我想大概也是如此，传入了一个finish参数，然后value其实就是finish 返回的是什么意思呢？是这样的： 那大概便是如此 将序列化结果进行双写即可（也就是把system改为syssystemtem） 但是ls /之后找不到flag。。。 cat /flag会显示flag不在这，笑死，找了个寂寞 这里通过find / 来读取所有文件，最终发现flag在/tmp/catcatflag.txt内： 最终payload： ez_java 不是很懂 java审计题，题目提供了附件： 简单地说就是/会显示Welcome to YCB /templating会对模板进行渲染(这里的模板是freemarker) /getflag会将传入的data参数进行base64解码，然后进行反序列化 其实这里还是不是很懂要怎么利用，毕竟自己的java还是太菜了 这里按照thai师傅的方法应该是调用： BadAttributeValueExpException -&gt; POJONODE#toString -&gt; HtmlInvocationHandler -&gt; htmlmap 利用poc: payload: 将payload发到getflag路由即可覆写index.ftl 将ftl覆写成可以利用freemarker ssti的形式，再访问template传入name: 执行反弹shell 关于反弹shell的操作这里也一直在踩坑，导致卡了很久，包括Serpent那题也是很晚才能够解出来 这里反弹shell必须要有一台公网vps，同时要在安全组内对需要监听的端口进行开放，不然请求就会被防火墙一直拦截 噗，下次就不要这么犯蠢了:( vps内: 然后发送请求： 即可获得flag ez_web 不会。。 一点头绪都没有 官方hint说访问cmd.php 访问后命令执行仅能执行whoami 还有另外一个是列目录，但是只能列ls、ls /、ls /etc、ls /etc/passwd 文件上传没看，大概也对文件进行了限制 总之就是很迷 不过结束后听师傅们说应该是通过文件上传so文件再用whoami触发…? 算了 看不懂 Serpent flask题 通过访问www.zip就可以获得源码： 访问/verification获取到session 如果session为admin，返回secret ey开头的session是flask的session 尝试使用flask session decoder: 他直接把secret_key给解出来了： 加密： 返回： 访问src0de即可获得源码： 这里就是pickle反序列化的点了： pickle是python中的一个能够序列化和反序列化对象的模块 上面是一个简单的pickle例子，dumps相当于序列化一个对象 而loads相当于反序列化一个对象 而pickle反序列化中还有一些opcode，例如一个比较经典的opcode： 但是在这里不行，它返回了No Way!!! 因为这里还有个check函数没有给出，相当于有waf的存在 慢慢测试发现waf拦截了R 所以我们需要一个不含R的opcode协助我们进行pickle反序列化： 这个时候返回了go for it 但是并没有whoami的回显，说明我们要进行无回显的pickle反序列化 这里还是通过反弹shell来执行： 打开2333的监听，将其使用cookie传递后成功反弹： 但是我们在cat /flag的时候显示了权限不足 由于服务器使用python 这里我们使用python提权： ArkNights 这题被狠狠的非预期了。。 这题提供了源码： 可以看到本意应该是什么呢？ 先看路由，read路由存在有任意文件读取，但是不能直接读取flag /里面能够通过exec进行命令执行，但是我们需要对session进行修改 这里就有点像蓝帽杯2022 file_session的味道了，毕竟在read路由内写的源码都十分地相似： secret_key肯定是存在内存内的，由于我们没有其他方法直接读取到secret_key 我们就需要间接从内存中获取，其secret_key是随机uuid，并将-替换为*，然后后面拼接上Boogipopisweak： 利用我们蓝帽杯里的方法，读取/proc/self/maps和proc/self/mem获取secretkey: 爆出key： 还要记得加上Boogipopisweak key: 验证： 伪造的时候还需要加上时间戳… 为什么呢？ 这就涉及到session的一些性质了，对于flask session加密的流程如下： 可以得到其时间戳 说明这个session是有时效性的 同样，我们使用蓝帽杯的脚本来对时间戳进行加密： 如果在正确的时间访问接口，会返回500，说明我们成功进入到exec 但是后面怎么绕exec就有些麻烦了 刚开始是想通过类似sql注入的方式闭合[]然后执行命令，但是发现过滤了[] 但是它还有一个非预期： ezyaml 涉及到yaml反序列化、tar包的extractall漏洞 源码如下： 路由： 这里就是通过/src路由并且提供name参数能够对yaml进行反序列化，然后对admin.html进行渲染并且返回 但是无论我们怎么上传tar包，我们都不能够访问到我们传入的yaml文件(返回500) 百思不得其解啊，看不懂要怎么触发 这时候还是得靠万能的博客，通过NSSCTF Round#6的一篇wp内，发现了对于tar包的extractall的漏洞： 其实这里是它引用的一篇博客：  通过这里面的poc直接运行即可 另外，关于yaml反序列化的一些payload： exp: 总结一下，感觉自己还是特别特别的菜。。 啥也不会的样子，pop链也得理解好久:( 不过我应该是有点进步了吧，起码是会那么一点点东西的:( 另：网络的力量真的非常的厉害"},{"title":"Inject Me 题解","date":"2023-08-26T01:40:04.000Z","url":"/posts/57648.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"],["java","/categories/CTF/java/"]],"content":"一道来自CNSS Summer的java题 笨人也是最近才刚刚开始学习java，所以写得比较菜。而且说是题解，但是因为自己没有vps的原因，自己也做不完后面的内容 题目与靶机 题目提供了summer.jar附件，打开靶机页面显示404 Not Found 对于jar包，我们可以使用jadx对其进行反编译： 题目的提示为： XXE Revese Shell(反弹shell) 查看源代码 查看源代码： Controller 发现Controller有两个主要Controller: 分析下来CommandController其实是我们通过访问/cnss/doCmd?cmd=来进行命令执行 另外一个Controller: 该Controller包含两个路由： /cnss/summer/login: 通过Post方式传入loginParam内的东西，将其称为credentials Param 查看loginParam: 说明其实我们的POST参数名应该是us3rname和p@ssword 然后获取了一个uuid，设置session内的参数（比如username, timestamp, token），然后返回了一个token的md5值 /cnss/summer/parse: parse路由需要使用POST传入ParseParam的东西，将其称为payload，还需要使用get传入一个参数nammmmme 查看ParseParam: 说明我们需要请求的参数是username和xml 然后获取到session内我们先前login的username参数，并进行判断： 如果session内的username参数和我们的nammmmme不一致，或者是payload内传入的username参数与nammmmme不一致，就会返回错误 反而会进行一个xml的获取，我们结合题目的提示xxe可以猜测到我们可以在这里进行xxe的注入 实际上，对于SAXReader这个第三方库，是的确有存在xxe的风险的： 参考这篇文章： java xxe 再查看 然后回过头来，先前我们在CommandController内发现它从config处获取了blacklist，所以我们尝试去查找一个这个config Config 在config处我们发现了： CommandFilterConfig和ParseFilterConfig 其实就是用系统设置内获取allow和blacklist 同样地，获取参数并且设置 filter 我们还发现了一个重要的包：filter未查看，其实从包名应该可以猜出这是对我们访问时所作出的一些过滤限制 应该是对于请求/doCmd时做出的限制，其实就是查看请求的内容是否符合规范(?) 上一行当然是废话… 其实是对于访问地址做出的限制： 这里对于我们的/Parse做出限制： 系统设置 application.properties 其实就是application.properties 发现application.properties对server进行了一些限制： 服务器在本地的5000端口，请求方式为SUMMMMER 以及expire: 5000 在java时间戳（timestamp）当中应该是5秒钟的时间 还有command处，仅允许127.0.0.1访问才能够执行命令 而且还有黑名单限制，我们无法使用： 联系到反弹shell，我们可以猜测到通过反弹shell来获取到我们的flag 而且需要通过访问本地的服务才能进行命令的执行： xxe: 我们先前的xxe一直都是使用进行flag的读取，但其实xxe不仅仅只有这一个用途，它还有： SSRF 探测内网的信息 RCE 等 思路 在上文中我们得知/cnss/summer/parse可以进行xxe，但是有以下几个限制： 对于5秒钟的限制，我们仍有解决方法。解决的方法就是利用我们的python 对，写python脚本即可 由于只用考虑前4项一致，我们可以直接进行爆破即可 通过碰撞来获取我们需要的UUID，通常我们考虑的是数字的爆破即可 但是在python中的md5加密一般都是字符串，所以我们要先对int类型进行转换 Login 而我们首先需要通过/cnss/summer/login来获取这个token: 通过python获取到session的token即可： Parse 接下来我们需要访问parse并且执行xxe: 对于parse我们需要做的准备是： 通过python设置SUMMMMMER请求方式 设置UUID请求头，并且通过爆破获得参数 传入参数username和xml 对于请求方式，可以通过Request来进行设置： 对于UUID，我们需要进行md5的碰撞，先写一个md5的加密函数方便我们接下来的操作： 然后写一个md5碰撞： 其实我们已经知道是在parse处进行xxe了，所以我们可以将xml修改一下: 接下来设置请求头，添加我们的UUID、Content-Type等： 最后设置并发送请求 返回： 为了使得好看一些： 可以修改为print(x.json()[‘data’]): 发现fl444444g 但是我们尝试使用时，会返回： 说明该文件是我们无法通过file来进行读取的 但是我们读取/etc/passwd的话，它是能够正常读取： 所以说我们总体思路是没有问题的，问题在于flag是不能正常读 联系到我们还有个/doCmd没有使用 以及hint Revese Shell 所以我们应该是需要去访问/doCmd然后进行反弹shell操作 考虑到/doCmd的访问方式是限制0.0.0.0（或者127.0.0.1），端口限制在5000 所以我们可以通过xxe访问内网： 同时利用quote库使得我们的command能够正常被引用： 只需要command处执行反弹shell即可 死于没有vps，做不了这一步T_T 完整exp: 后面就是反弹shell后的操作了 其实这是2022的原题，完整操作参考： [CTF]2022 CNSS夏令营 Web&amp;Reverse 复现wp - Tim厉 - 博客园 (cnblogs.com)"},{"title":"NSS Round 13","date":"2023-06-04T09:52:00.000Z","url":"/posts/4670.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"是赛后靠wp自己复现的，可以划走了 flask?jwt? 看到提示就知道有可能是jwt伪造了 但事实是自己做的时候并不是这样 哈哈，这里是用了flask的session伪造，乐 注册个账户先： 就随便写邮箱号，用户名，密码 然后登录，burp suite抓包，发现了session: 进入jwt.io试图解码jwt，但是 居然不是jwt格式。。 所以想到是不是flask的session 使用flask-session-cookie-manager-master试试 这里使用的是不带secret-key的解密方式，可以看到能够正常解码，userid是8 那么secretkey在哪呢？ 这个问题困扰了我很久，直到我找到了一个重置密码的页面： 这里打开f12就找到了我们的secret-key：th3f1askisfunny 总结就是百密一疏，万万没想到把secretkey藏在这里了… 拿到secretkey直接重新解密： 那我们接下来重新加密session： 这里我之前一直尝试user id是不是改成admin，但是结果不是，改成admin后直接500 Internal Server Error 后来还是我自己尝试是不是把userid改成1就行了，结果真是 … 只能说带点运气成分在里面了 重新登录，将session替换即可获得flag： 然后，赛后出题人来说这是非预期解（雾 flask?jwt?的预期解 这里的正确姿势是需要我们进行jwt伪造，重置admin账户的密码，以admin的身份进行登录并获取flag 这里的重置密码页面会发送重置密码的邮件 我们通过重置密码的连接可以获得jwt，重置链接的格式是这样的： /changePassword/&lt;jwttoken&gt;?email=&lt;youremail&gt; 同时secretkey仍然是那个th3f1askisfunny 这个时候使用secretkey重新伪造jwt，覆盖后就能够重置admin的账户(题目中给出admin的邮箱是adm1n@flag.com) 重新修改admin的密码登录即可获取flag flask?jwt?(hard) 这题我研究了一半，没想到通过删除session引发报错能够获取secretkey 同样注册登录，在拿flag前发现了注释： 访问/wor 发现只给了一段提示： 抓包获取flask session后解码的结果是： 居然和我们flask session里的内容的时间是一致的 那这是什么神奇的魔术呢？ 这里怪我脑子不好使，还是做题做少了，当时做题的时候没想出来 这里肯定是flask读取了我们的session然后获取了time咯 那我们将session删除试试呢？ 会发现我们直接进入报错界面了： 浏览报错界面直接发现了secretkey： 直接进行decode测试： 重新加密即可，userid应该同样是改为1： 这里如果不删掉后面的time 的话python会报错。。。 复制session即可获得flag: 同样地，获取到的secretkey同样也是jwt的secretkey，采用上面的预期解的方法做同样能够获取flag ezfactors …看完前面句号的东西我还认真的去社工了一下，发现并没有这种东西 这里的tool可以点击，进入后发现： 修改数字可以看到不同的数字的因数被分解 搜索了一下，发现linux确实有factor这个指令用于因数分解，而且分解的结果与页面的结果一致： 那这里就有可能就是直接一个命令执行，factor + 传入的参数 对于传入的参数没有作限制，所以可以尝试直接命令执行： 这里后面的/要进行url编码，否则会报错(产生歧义，会认为你访问的是/factors/1234;cat /flag这个路径) 居然真的执行成功了。。 但是flag不可能是这个格式，很明显结果只能够显示数字和冒号还有空格 那我们需要找一个方式能够读取flag的全部内容并且是以纯数字的方式输出 这里采用od，od能够将内容读取并且以8进制的方式返回，此时就是纯数字了 拿到cyberchef解码即可： 这题赛时没做出来（（ 因为自己就是在想linux有什么爆破因数的工具的rce然后进行漏洞利用。。 然后找不到，没想到居然是factor这个命令 其实这里做完就会发现这题跟ping命令是差不多的，同样是加分号后直接跟命令执行即可 MyWeb 这题只能怪自己不肯静下心来好好钻研了。。 源码： 在这里重新梳理一遍源码： mode有save和read 先看read，read模块比较简单： 通过eval函数处理json格式并且输出，这里使用eval函数处理还是比较危险的，如果我们在$data里的内容是: 的话，就能够同样执行commandshere的命令，考虑在data处下手 然后再看save，通过传入value把value写入data.json内，然后保存 这里传入的value经过addslashes处理(单引号，双引号会被添加反斜杠，所以这里不能使用带引号的rce) 这里将代码copy并进行本地测试： 稍微修改了一下源码： data.json内容： 注意到写入data前的操作：先获取data.json的内容，将$data的]直接替换成'$value']，也就是说操作的时候写入是这样的，假设传入的value是6666: 漏洞就出在这里了，简单地说就是直接将传入的value直接拼接在尾部 假设我们传入的是: ]//呢 那json的内容就会变成： 从vscode里看到后面直接被注释掉了，前面完成了闭合，而且read能够直接读出内容： 这里就类似于sql注入了，通过闭合后面的]从而成功执行自己的命令 接下来只需要用分号将命令间隔开并且执行自己的命令即可 由于接下来的内容都被//注释掉了，这里需要新开一行添加; 也就是: 这里好像是靶机寄了，做不出来… 信息收集 … 做不了一点 dirsearch扫到了index.php/login和/cgi-bin/testcgi和/cgi/bin/printenv 然后外加提示说搜索的不是dirsearch(( 然后我意识到可能是让我去找某些cve了 乐 由于搜到的是cgi那边的，所以我就尝试去找了cgi-bin的漏洞 CVE-2014-6271 shellshock 还真有。。 然后直接尝试用它的poc，发现并没有运行这个脚本。。 要开启的话还需要我们chmod 775… 并没有办法执行chmod 775 这个方法就寄了 然后查看了index.php/login 是任意文件读取： wappalyzer解析是apache 2.4.10，那就只能再找找apache 2.4.10的漏洞了 这部分现在是我现看先学的 然后burp抓包的结果的apache却是2.4.55 找找2.4.55的漏洞： CVE-2023-25690 Apache HTTP Server 请求走私漏洞 分析与利用_黑客技术 (hackdig.com) …真有 我们详细看看这篇CVE的解析： 我对于这里的解读大概是这样的： 先通过读取conf/httpd.conf Apache默认安装httpd.conf在哪里？-Java 学习之路 (javaroad.cn) 这篇文章讲述了路径在哪： /usr/local/apache2/conf/httpd.conf 看到Rewrite rule的路径，这里的意思就是将请求的内容转发到/hello/*的路径（应该是 回到这里，我们的Rewrite rule是这样的： 再回到CVE分析的文章，查看利用的方式，大概就是打断点（ 那我们直接看利用方式： 修改一下payload: 即可获取flag 至于为什么是/flag.txt 当然是猜的（可以看出我就把hello改成了nssctf而已） TimeTrcer 不会 看了许多师傅的wp，然后自己再尝试复现而完成的这篇博客，非常的没有营养… 在此po出各位师傅写的wp，毕竟我是靠着他们才能写出这篇文章的： F12师傅 c4skg师傅 ph0ebus’s Blog gtg’s infoSec blog | NSSCTFround13WP-TimeTrcer "},{"title":"CISCN 2022 online_crt题解","date":"2023-06-01T11:23:27.000Z","url":"/posts/28425.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"又是go和python的结合啊（（ 今年的CISCN好像也有一道go+python的(go_session) NSS上提供了附件，先看看附件怎么写的吧： app.py flask里有如下几个路由： /：主页 /getcrt：调用get_crt函数获取crt(证书) /createlink：使用c_rehash方式使得openssl在证书目录中能够找到证书 这里通过搜索c_rehash能够得知有OpenSSL 命令注入漏洞(CVE-2022-1292) 这个漏洞的利用方式是如果证书的名字有反引号的话可以执行命令： /proxy如同他的名字，通过uri传入表单访问内网8887端口的服务 8887端口是什么服务呢？ main.go: go服务开在8887端口，也就是说我们可以通过/proxy来访问8887 8887是rename操作，也就是说我们可以通过重命名crt的方式来将crt命名成带反引号能够命令执行的方式，再通过/createlink的c_rehash执行命令，获取flag 思路如下： 一些问题及解决 Host 这里的访问host为admin并且rawpath不为空才能够进行Rename操作 但是我们可以从app.py的/proxy路由得到 这里的User-Agent设置为了Guest 但是我们可以控制uri的输入，这里可以通过自行构造Host: admin来使得host为admin RawPath 认识GO语言url.URL结构体 - 谈一些有趣的编程 (ipeapea.cn) 可以看到两个例子 这里的url.Parse类似于php的parse_url() 第一个例子输出的时候RawPath为空 第二个例子把home后面的斜杠变为%2f后，RawPath便不为空了 这就是说，如果有%2f的话，RawPath就不会为空 即，在url任意一个/进行url编码即可绕过 get表单 由于app.py获取的是form，也就是表单的形式（Burp抓包） 所以我们需要加入:Content-Type: application/x-www-form-urlencoded 我们需要访问rename，所以构造的表单的总体形式是这样的： 换成get传参就是： 解题 先直接GET访问/getcrt获取一张证书 然后访问proxy，传入 再访问/createlink 这样执行c_rehash static/crt/ &amp;&amp; ls static/crt/ 所以这里读取的就是static/crt内的目录 说明flag.txt存在了static/crt下 接下来访问static/crt/flag.txt即可获取flag "},{"title":"ctfshow周末大挑战 - parseurl","date":"2023-05-15T04:37:46.000Z","url":"/posts/22097.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"今天看到ctfshow上有个周末大挑战啊，来做做 认识parse_url() 根据php的函数介绍： parse_url是对传入的url进行语法分析，然后返回url的每个部分： 如果prase_url后带第二个参数，则是直接获取结果的一部分： 参数2的可选值： 具体例子如下： 其中还缺少了一个[fragment]=&gt;test 我本地跑的时候显示不出来，但是这个组成部分还是存在的 parse_url后就可以分成如上的scheme、host、user、pass、path、query、fragment七个部分 第一关 这题就非常简单了，获取parse_url()的host部分然后进行eval 那直接在host处下手即可： 命令执行成功 尝试使用ls /失败 那就得用cd ..;ls 逐级寻找flag 发现flag: 第二关 改为了包含host和path 如果知道了文件的路径，直接包含获取即可 如果不知道可以通过data伪协议包含写入shell: 最终payload： 然后就可以进行命令执行： 另：既然知道了flag的路径 那直接： 乐 第三关 同上，只不过改为scheme和path拼接 将scheme从http://改为data:: 然后发现data后面的内容全部为path了，也就是： 所以直接写： flag的开头还是以下划线开头的 所以直接 第四关 和第一题一样啊 host改一改命令执行即可 换到靶机就是： 发现flag 1_f1ag_1s_h3re : 第五关 套娃： include 还是用data协议写shell 那这个$$$$$$host又是什么东西呢？ 其实就是套娃 如果$host指向1 那就会变成$$$$$1 ，消掉一个1 如果1指向2 那就会变成$$$$2…以此推类 这里通过parse_url获取url各部分: host scheme username password port path query fragment 那就可以通过这八个进行上述的套娃，从而指向最后的data伪协议： payload: 第六关 看到file_put_contents写shell: 对回去就是： 将path做文件名，host作为data写入 本地测试： 也就是说它把问号后面的内容定义为了query 所以我们要找一个不带问号的webshell： 使用js的webshell： payload: 访问1.php后： (完)"},{"title":"flask ssti的新姿势","date":"2023-04-16T06:33:25.000Z","url":"/posts/25410.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"这个题是最新最热的GDOUCTF里面出的一个题&lt;ez_ze&gt;的姿势 偷偷来学一学： 打开靶机后看到的是一个post窗口，刚开始怀疑是sql注入，但是做着做着发现不对劲，应该不是sql，是ssti 随后我用dirsearch扫了，发现有个/console 进去就是flask的后台（（ 所以很明确就是flask了 can can 过滤 首先测试了&#123;&#123;7*7&#125;&#125; 回显是invalid input 将花括号去掉，显示7*7 再单独输入花括号回显invalid input 过滤了花括号 经过测试应该是绕过了至少： &#123;&#123;` 、`\"`、 `_`、`\\`、`class`、`popen`、`.`、`[]`、`os` 但是很搞笑的事就是 我想要跑个fuzz字典来着，发现没有ssti的字典... &#123;%asset_img 2.png bwb%&#125; 反正这些都被过滤了，常见的一些绕过方式也没有办法（比如request.args，通过传参绕过下划线、用中括号替换点号、等等） 但是还是有绕过的方法的： # 绕过原理： `dict()|join`：python中的字典 将字典中的key值进行拼接 `&#123;&#123;set p1=dict(p=a)|join&#125;&#125;就是令p1=p 如果后面加|count变成dict()|join|count的话就是返回该字符串的长度： &#123;&#123;set p1=dict(c=a)|join|count&#125;&#125; p1=1 通过这样的拼接可以获取到payload 花括号替换：&#123;%%&#125; payload: 先获取数字0-9（没有过滤数字，其实可以不用这么做） 通过获取pop来获取下划线：(pop能够将索引值删除列的某个元素并将该元素返回) 返回 其中便有下划线，通过pop删除第18（或者24）即可返回_ 通过join拼接下划线和globals即可： 获取get： 获取os: 获取builtins: 获取popen: 如果使用上面的拼接会报错：keyword repeated 这里可以使用+拼接： %2b即为加号 获取chr函数来获取flag： 命令cat /flag： 用chr() -&gt; 字符即可 获取read: 总payload： 也就是： 最后多打了个&#123;%print read%&#125; 所以上面显示多了一个read "},{"title":"看看无回显RCE","date":"2023-03-11T08:46:16.000Z","url":"/posts/50751.html","tags":[["RCE","/tags/RCE/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"学到了一点点新东西： 1.什么是无回显RCE 简单说来应该就是和sql注入里的盲注一个概念，你看不到回显的结果是什么 就比如eval函数，他就是一个有回显的函数 但是exec()就是一个无回显的函数，你看不到结果是什么 2. how 2 solve it? 对于无回显的rce一般有三种解决方式： 反弹shell dnslog外带数据 时间盲注 反弹shell 使用bash或nc反弹 dnslog外带数据 使用： ceye 使用;作为命令的分隔符，然后发起curl请求 收到外带数据回显结果 不过这个b玩意太容易504 Gateway Time-out了… 等能访问的时候再补充图片吧 使用方法： 注册了一个账号以后就会有个属于自己的dnslog域名 然后： 如果使用dnslog.cn dnslog 要这么写： 可惜由于dir/ls会被空格截断 可以加上|sed -n '1p’来查看 … extra: 还可以使用burp的Burp Collaborator Client 点击Burp就有Burp Collaborator Client了 点击copy to clipboard 会生成一段：ucamo87yesi3j87kf879es5cn3tuhj.burpcollaborator.net 然后payload： tee：从标准输入读取，再写入标准输出和文件 时间盲注： 使用sleep 不过我在nssctf上没成功（（（ 所以这里就不多展开"},{"title":"一道题学习两个知识点","date":"2023-03-04T05:42:27.000Z","url":"/posts/13237.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"说点题外话，就是今年的安洵杯老逆天了这件事 其实我连账号都没有的（（ 懒狗本质，懒得去注册账号 然后看到群里发的比赛链接，欸，怎么连都进不去 容器环境也打不开… 还是得靠thai神 然后thai神光速做完web1下班，后面就没见到题目解了= = 额，这段话的意思就是很离谱，只能打开第一题的环境… 后面就更搞笑了 比赛直接给paused了，笑死 然后群里都在说这一届安洵杯就是个离谱杯 知乎一看： Web： 5秒最多10次请求 开局500 公共环境静态flag Misc：套题 Crypto： misc 简单的密码学不给附件 re：原题 甚至没有pwn 甚至还有开盒，收集学生信息 不过知乎说他们没少看p神文章还挺对的 web 1 就考的两篇p神的文章(( 不吹水了，来看看web1 好像忘记源码了… 大概就是get传参名为heizi，开头前5个字符限制为aikun 最后10个字符限制为xiaojijiao，如果字符串为aikunxiaojijiao输出nonono 否则进入下一层 下一层考的是p神的PHP利用PCRE回溯次数限制绕过某些安全限制这篇文章 源码应该是这样的： 如果输入的是aikunaaaaaxiaojijiao的话 .+?匹配到a 由于是非贪婪模式.+?停止匹配，由s匹配a（第二个a） 匹配失败，回溯到.+?匹配第2个a 然后停止，s匹配第三个a … 随着a的数量增加，回溯次数越来越多，但是回溯次数的上限是100万次，如果超出了这个回溯次数就会返回false 所以我们直接用python打印100万个a写在里面就好了 print('a' * 1000000) 随后进入第二层 这篇就是p神的 我是如何利用环境变量注入执行任意命令 其语句为： 在CentOS 8下安装PHP，并使用本文开头的代码，直接运行一个测试服务器： 访问`1.php?envs[BASH_FUNC_echo%25%25]=()%20"},{"title":"看看session.upload_progress","date":"2023-03-04T05:12:51.000Z","url":"/posts/42409.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"这个东西让我印象挺深刻的（ 最近一次接触还是在一道SQL注入的题目： [PwnThyBytes2019] BabySQL 由于login.php没有session存在的时候就不能访问，并且无法注入 所以这时候就需要我们自己创造一个session 所以session_upload_progress在这里就派上用场了 然后我就想起来之前session反序列化的时候好像也是用这个session_upload_progress的 觉得这个东西挺有用的，就来学习一下 还有就是这个了（雾） 1.绕过!isset[$session] 就是上面的引子引入的题目，不多赘述 2.session反序列化 session序列化/反序列化的默认引擎是php 但是如果php文件变成了： 就将序列化的引擎改变了（php_serialize） php引擎对于序列化的存储格式是：|serialized_string，而php_serialize引擎的存储格式是serialized_string，如果使用两个引擎分别处理的时候就会出现问题 这是因为php_serialize会将|当作正常字符来解析，生成session，php中会将|看作分隔符，解析session文件时会直接对|后的值进行反序列化处理（session_start()） 如果存在两种不同的引擎的时候，就可以利用session_start()的自动反序列化传输数据 此时当浏览器向服务器上传一个文件时，php将会把文件上传的详细信息存储在session当中；只需往该地址POST一个名为PHP_SESSION_UPLOAD_PROGRESS的字段，就可以将文件名的值赋值到session中，进行session反序列化 前提当然是session.upload_progress.enabled为On 简单看一个以前做的题就知道了 （ctfshow新手杯-石头剪刀布） 源码可以看到__destruct()魔术方法里file_get_contents()这一个危险的函数 可以想到用反序列化获取flag 虽然整个源码没有unserialize()函数，但是源码开头将序列化反序列化引擎设置为了php，通过phpinfo()可以看到默认处理器是php_serialize，且session.upload_progress.enabled已经打开 所以这里就可以通过尝试上传session进行反序列化 先进行反序列化，这个反序列化连我都能看得懂( 然后post传个文件： 发包过去就好了 3.文件包含 1.如果session.auto_start=On的话，即使没有session_start()也会对session进行初始化，但是默认关闭 由于session.use_strict_mode默认值为0，导致用户可以自定义Session ID（Cookie: PHPSESSID= xxx） 这个时候PHP就会在服务器上创建一个文件/tmp/sess_xxx 这个时候PHP会自动初始化session，并且将文件名等内容写入sess_xxx文件中 其实就是这个： upload_progress_xxx 这个xxx其实就是命令执行之后的结果 然后序列化的结果就是文件的一些详细信息，包括文件名，上传时间等 也就是说如果我们此时包含了这个文件，这个文件写入了eval()的话就可以进行rce 但是由于session.upload_progress.cleanup = on使得上传的sess_xx会被立即清空，此时在session文件内容清空前包含即可 script: 如果是利用 burp 发包的话 你需要准备一个session的包（包含有PHPSESSID和PHP_SESSION_UPLOAD_PROGRESS的那个包），然后一个文件包含包(?file=/tmp/sess_id的那个) 同时发包，赶在sess_id文件清除之前访问即可"},{"title":"HSCCTF 2th WriteUp","date":"2023-02-19T03:30:24.000Z","url":"/posts/37685.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF WriteUp","/categories/CTF-WriteUp/"]],"content":"又被薄纱了，哈哈哈 Misc SIGNIN 关注公众号：中龙 红客突击队 发送：HSCCTF{TELLMEFLAG}获取flag即可 Crypto EZRSA 尝试factordb分解失败 但是M=2022mep=k1p n=pq=k2p c = M^e mod n = (k1p)^e mod k2p =k3p mod k2p = k3p-k4k2p 结果是 n，c都含有p的因子 所以n和c的最大公因数就是p 得到p之后就可以得到q 之后就是rsa常规解法 Web EZSSTI ssti模板注入，传参点是name 直接使用poc一把梭： 但是发现报错： 对比发现popen被删除了，所以这里直接双写绕过即可 回显： 应该是有过滤cat 所以换成nl EasyPHY 第一眼进去还以为是文件上传，于是传什么文件都被挡… 后来发现：&lt;input type=&quot;submit&quot; name=&quot;acti0n&quot; placeholder=&quot;上传图片&quot; value=&quot;upload&quot; class='btn' id='b1'&gt; name=acti0n… 所以应该是有传参点的，那么我们可以尝试获取view和upload的源码（文件包含） acti0n=php://filter/convert.base64-encode/resource=view.php 发现被挡了，可以大小写绕过 acti0n=php://filter/convert.basE64-encode/resource=view.php 可以看到ban掉了很多危险函数 而view.php内能够明显看到在__destruct()方法内有eval函数 而__destruct()明显是反序列化的标志，而该方法又在delete_img函数内 而如果delete作为post参数的时候，就会将其内容传递到delete_img函数内，再加之上传文件，所以应该是phar反序列化 运行后获得phar.phar，将其上传即可 然后通过post的delete触发phar即可 delete=phar://phar.phar EZFlask Flask pin码攻击 不过这个东西最恶心的地方就在我找到的几个脚本里生成的pin码都是错的… 都不知道什么原因… 什么是flask的pin码攻击呢？ 简单的说就是你可以通过报错的页面进入debug模式，直接获得控制台（ 但是一般都会被锁定，并且让你输入pin码 而我们的pin码攻击此时就要派上用场了，我们可以通过计算获得pin码并且解锁 如何进行pin码的计算： 你要获取以下几个东西： 机器的mac地址：可以通过访问/sys/class/net/eth0/address获得 机器id：访问/etc/machine-id或者/proc/sys/kernel/random/boot_id，二选一 CPUID:/proc/self/cgroup或者/proc/1/cpuset modname：默认为flask.app 用户名：访问etc/passwd获得 app.py的绝对路径：通过报错页面获得 然后使用脚本计算即可 解题： 页面提示：/view?filename=app.py，输入后获得app.py的源码 猜测我们可以通过filename来进行文件的读取，并且如果我们直接访问/view页面会报错，通过报错页面我们获得app.py的绝对路径：/usr/local/lib/python3.8/site-packages/flask/app.py 通过/view?filename=/sys/class/net/eth0/address获取机器mac地址：02:42:ac:02:0b:47 通过/view?filename=/etc/machine-id获得机器码：7265fe765262551a676151a24c02b7b6 通过/view?filename=/proc/1/cpuset获取CPUID: 2b577240d0290d4743c464cf4a8375c8c1a52d7eae4545baaf602d2577177a70（docker后面的一串） 通过/view?filename=../../etc/passwd获取用户名： app 也就是bin/sh的前一个 那直接上脚本即可： 直接复制819-831-805即可，有时候不能认证，尝试重新打开一下页面即可 获取到控制台了 那直接想怎么做就怎么做： 发现flag和readflag 先查看flag，是空的 然后查看readflag获得flag "},{"title":"CTFShow 菜狗杯","date":"2023-01-29T03:26:32.000Z","url":"/posts/37693.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做菜狗杯的题（主要是web） Web签到 源码如下： 这个刚开始看的时候可能头很大，实际上就是变量的嵌套 由里到外传参即可： 第一层是cookie传参：名为CTFshow-QQ群: 值为1 这样就变成了eval($_REQUEST[$_GET[$_POST[1]]]) 相当于让我们POST 名为1的值 此时令1=2 变成eval($_REQUEST[$_GET[2]]) 同上，get传参2=3 最后的request用任意方式传参即可，注意后面的中括号 3[6][0][7][5][8][0][9][4][4]=system('ls /'); 注意中文需要url编码 发现f1agaaa，直接cat /f1agaaa即可 web2 c0me_t0_s1gn 提示：the page hide something you need use the god’s eye to find 使用F12发现： 提示我们看看控制台： 运行这个函数即可获得flag 直接控制台输入g1ve_flag() 我的眼里只有$ 非常简单的代码，通过POST请求覆盖变量： 一共有36个$ 所以直接cat /f*即可 一言既出+驷马难追 这个题可以有两种方法： 1.将后面的内容注释掉（通过注释符，因为没有对输入进行过滤） 只需要将==1919810及其后面的内容注释掉即可 ?num=114514);// 传入后assert内容变为了 也就是intval 114514 然后输出flag 2.assert()类似于eval()，可以执行加减乘除 所以只需要114514+1805296即可 加号需要url编码 ?num=114514%2B1805296 （驷马难追中使用） TapTapTap js游戏题，关注： 1.js是否有alert 2.游戏取得胜利的条件 3.角色参数（ 在/js/habibiScript.js中找到alert(atob('WW91ciBmbGFnIGlzIGluIC9zZWNyZXRfcGF0aF95b3VfZG9fbm90X2tub3cvc2VjcmV0ZmlsZS50eHQ=')); 通过base64解码得到 Your flag is in /secret_path_you_do_not_know/secretfile.txt 直接访问获得flag WebShell 非常简单的反序列化 只需注意过滤了flag即可 执行后打开f12即可看到flag 化零为整 所以这个题目就是让我们通过多次get传参拼接出大牛 由于每一个url编码长度只占1 所以我们可以将大牛进行url编码，每一个get传参只传递其中一个编码，拼接后解码就能组成大牛 将大牛url编码：%E5%A4%A7%E7%89%9B 传入?1=%E5&amp;2=%A4&amp;3=%A7&amp;4=%E7&amp;5=%89&amp;6=%9B即可 无一幸免 不是很懂，get随便传都行 ?0=即可 传说之下（雾） 还是js小游戏 直接看看js： 这里没有alert什么的输出条件… 就看看分数，发现var nowScore = this.score += 1 就是每吃一个苹果得到1分 我们直接改成2077+就行了 控制台输出flag 算力超群 打开是个计算器 但是随便输点算术没有其他的回显 打开burp抓个包 抓到了： 接下来对这三个参数进行修改： 删除number1的参数： 页面报错，发现是app.py(flask) 并且最后的内容是eval函数 说明我们可以对传入的参数进行修改执行命令（ 算力升级 仅能使用gmpy2库的函数进行注入 查看源码 查看gmpy2库内的内容 builtins内一般有eval（ssti) 查看后确实有 只需要成功调用eval即可再次使用上一题的payload获取flag 也就是最终结果是 所以我们可以使用gmpy2库内的函数获取出所有的英文字母从而拼接出payload （注意单引号需要使用双引号，就像这样 “'”） 经过不懈努力后得出如下payload Is_Not_Obfuscate 打开网页是一个push 和 pull的界面，首先查看源码： 发现了一段被注释的内容：action=test的时候会执行内容 并且是eval执行 发现了lib.php和index.php 提示访问index.php前首先要测试lib.php 还有robots.txt 先访问robots.txt 发现/lib.php?flag=0，并且直接访问lib.php页面无内容 于是尝试将flag修改为1，回显出一套神秘代码 我也不懂什么东西，起初我还以为是base64，所以去用cyberchef搞了一下，发现不行 然后源码处知道将action设置为test后可以解密文件 于是将加密文本解密 于是成功回显源码 其中最重要的就是下一段了 于是我们可以output写入命令，然后进行push 然后使用pull操作访问这个文件，执行其中的命令 第一步： 第二步： 其中1ce4b066a901b6cb2f7905584ff31ad4是system('cat /f*');youyou的md5值 就能获得flag easyPytHon_P 直接给出源码如下： 值得注意的就是： request.form.get说的是虽然是get，但是其实使用post方式提交的 真蛋疼啊… 然后就是这个subprocess.run()了，它是用于执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例 函数参数： subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, timeout=None, check=False, universal_newlines=False) args：默认是字符串序列 也可以是一个字符串，但是此时要将shell参数设置为true shell：如果为true，则命令将会通过shell执行 check：检查异常 举个例子： 从这里我们就可以知道这些个字符串需要分开 也就是我们想要执行ls -l 就需要分开传递ls 和-l 所以就是换个方式来执行命令 POST方式传入：cmd=ls&amp;param=/ 查看根目录下是否有flag 发现没有，所以flag应该在当前目录/app下 经过测试发现如果param为空无回显 所以我们传入cmd=ls&amp;param=/app查看/app下的文件 发现flag.txt 直接cat flag.txt即可 满地飘零 但事实呢，这题考的不是变量覆盖，因为如果你传值?flag=zeros的时候就只会echo “好多零”，而且flag原本的值也被覆盖了 我们知道$号后面是变量名 那么$_GET呢？ 那么我们是不是可以这样理解：$_GET不仅仅是GET传参，还可以是个变量名_GET？ 那么我们如果传入_GET=flag的话 那么$_GET=$flag 而且没有进入好多零，而是var_dump()，就能获得flag了 茶歇区 int64溢出 消耗fp得到物品 每一件物品有不同的分数 消耗的fp值超过你有的fp值的时候就会回显你不好意思拿那么多… 那么如果我们硬要拿很多的话，就会使得扣除的分数溢出，导致无法处理（ int 64 : 9223372036854775807 如果我们超过了这个数字，int就无法处理了 然后就是试错，拿咖啡试是最好的，因为他是x10 矿泉水是无法触发溢出的，因为x1 我们试试 9223372036854775807 发现我们获得了0分 这个时候就是溢出太大了（ 我们调整一下 932337203685477580 这样恰好溢出不会太大 操作成功：你拿了932337203685477580瓶咖啡，总计获得-9123372036854775808分! 回显成功，再传一次932337203685477580即可获得flag 感觉怪怪的，说不太清 恭喜你获得flag：ctfshow&#123;4d69f484-1089-4e02-8437-9726728942bd&#125; 无一幸免_FIXED 这里修复了bug（ 考的还是整型溢出： $arr[]=1就是让数组追加一个新的下标，然后令他的值为1 也就是说我们输入什么数字，他的下一个数都是1 判断永真，进入不了else 但是如果它超过了整型最大值的话，数组就会处理异常 因为数组的最大下标数=最大int数 追加的话会导致整型溢出，追加失败 进入else 那直接传入0=9223372036854775807即可 这个时候就会报错：**Warning**: Cannot add element to the array as the next element is already occupied in **/var/www/html/index.php** on line **7** 并且进入else语句ctfshow&#123;2520e3b6-c6de-4205-9f8a-60565aa79691&#125; 小舔田? 反序列化 目标：echo $flag 需要触发call()函数，并且nickname=“小甜甜” call()函数由__toString()魔术方法触发，而__toString()又可以由 Moon类触发 那就可以了 当然，nickname是弱比较 我们让nickname=0（int）和字符串比较，也是可以的 不过这个后面就比较怪了… LSB探姬 【ctfshow菜狗杯-LSB探姬】 抽老婆 像catctf的 catcat，比catcat简单 直接抽一个老婆，然后查看源码 在下载老婆处找到了/download?file=3e5b0bcb240126f92e31206528fa81ff.jpg 就是通过file=文件名进行下载 尝试修改一下文件名，改为1，页面报错，同时发现是flask模板（/flask/app.py） 所以我们尝试下载app.py查看源码 file=../../app.py 可以发现flag在/secret_path_U_never_know处，但是他又需要session的身份验证 所以这个时候就需要我们伪造session了，详见CatCTF的catcat 我们首先获取我们当前的session，打开bp抓包： 然后通过flask-session-cookie-manager伪造session即可 伪造session需要知道secretkey，而在这里已经提供了secretkey：tanji_is_A_boy_Yooooooooooooooooooooo! 先使用decode解码内容： python.exe .\\flask_session_cookie_manager3.py decode -c 'eyJjdXJyZW50X3dpZmkiOiIzZTViMGJjYjI0MDEyNmY5MmUzMTIwNjUyOGZhODFmZi5qcGciLCJpc2FkbWluIjpmYWxzZX0.Y-UDjg.2I1zjYEctpdz93Wi_YcLVmgBrAg' -s 'tanji_is_A_boy_Yooooooooooooooooooooo!' 解码内容：&#123;'current_wifi': '3e5b0bcb240126f92e31206528fa81ff.jpg', 'isadmin': False&#125; 然后进行加密： python.exe .\\flask_session_cookie_manager3.py encode -s 'tanji_is_A_boy_Yooooooooooooooooooooo!' -t &quot;&#123;'current_wifi': '3e5b0bcb240126f92e31206528fa81ff.jpg', 'isadmin': True&#125;&quot; 获取session： eyJjdXJyZW50X3dpZmkiOiIzZTViMGJjYjI0MDEyNmY5MmUzMTIwNjUyOGZhODFmZi5qcGciLCJpc2FkbWluIjp0cnVlfQ.Y-UG7Q.K3pbEVAqAZZFU1upOI_Zn4Rpj7c 然后替换session再访问/secret_path_U_never_know即可 龙珠nft我没做出来（（（ 完 CTFShow 菜狗杯wp"},{"title":"看看sql注入","date":"2023-01-10T02:35:56.000Z","url":"/posts/35462.html","tags":[["SQL_Injection","/tags/SQL-Injection/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"突然发现好久没写博客了，赶紧水一篇（雾） 该文稍微总结一下我遇到过的sql注入（非常基础非常萌新，没学过的都能看得懂…吗？） 0x01 SQL漏洞成因 程序没有对用户的输入进行过滤。 例如SQL的查询语句可能是： id和password是我们可输入的参数 在进行数据库查询时由于没有过滤单引号，我们输入1’和任意的密码时，语句会变成： 由于sql语法中单引号必须成对存在，所以这条查询语句中1’后面的单引号会和前面的单引号闭合，导致后面的单引号变得多余了，这条语句就会报错，一般报错的内容就是： 此时我们只需要将前面的单引号闭合，在后面插入我们想要查询的语句，就能够进行SQL的注入了 0x02 SQL注入点 SQL注入的注入点其实很多的（ 首先看url 是否有?id=1这种，如果有的话有可能是SQL注入 然后就是给你一个框框，有可能是搜索用户名，也有可能是登录框，让你输入账号密码登录，也有可能是让你查询一段内容… 然后就是http头，包括user-agent，cookie，referer，xff(有些flask的也经常用X-Forwarded-For) 只需要在你怀疑的注入点加入单引号进行测试即可（雾 其实有可能有单引号、双引号、甚至加入一个反斜杠也有可能发现 0x03 查询语句的过滤 1.大小写绕过： 2.编码： 进行url编码，如and（&amp;&amp;）可以尝试使用%26%26 如#可以使用%23 3.内联注释： 空格被过滤的一个方法： 另一个方法就是使用括号： 4.双写绕过： 将中间的union和select删除后又有union select，绕过成功 大抵是因为str_replace? 5.符号绕过： or 换成 || and 换成 &amp;&amp; 6.大小于号的过滤 万恶的大小于号过滤，在写脚本跑的时候非常痛苦 可以使用greatest()函数、least()函数 其实也可以直接使用等于号硬跑脚本，也就只用跑十七八分钟而已 7.过滤了database() updated in 2023/3/11 可以通过查一个不存在的表来爆出库名： 0x04 SQL注入类型 分为字符型和数字型两种 判断方式也很简单： 虽然但是我这一步好像从来没判断过，直接加个单引号注入的… 所以有些不用加单引号的题就比较容易吃亏 0x05 SQL注入手法 1.联合查询 非常常用的注入，适用于有回显位的注入（也就是会返回我们输入数据结果的位置） 首先判断字段数： 然后判断回显位： 爆库：（推荐使用-1） 爆表： 爆列名： 爆内容： 当然也可以写成： 2.报错注入 报错注入适用于没有回显位的，但是页面有报错信息的时候 有三种注入方式（雾） 1.group by 重复键冲 反正我是看不懂： 2.extractvalue() updated in 2023/3/11 extractvalue()的报错注入和updatexml还是有点不一样的： 3.updatexml() 与extractvalue()很相似，也是这三个里面最常用的： 注意报错注入只能回显前32个字符，爆flag时可能需要添加reverse函数： 3.堆叠注入 在SQL中（以及在很多的地方中），分号表示命令的分隔，也就是SQL语句的结束，如果使用;后再在后面构造SQL语句，两条是可以一起执行的,例如： （此处可左转NewStarCTF week 3的multi SQL） 将id为1的密码更新为123456 爆库： 爆表： 爆列： 查看内容： 如果update等被过滤，可以使用sql预处理语句进行拼接： 4.布尔盲注 适用于页面只有两种回显结果，没有任何错误回显 有的时候也可以使用异或符号（页面有1和0的时候） 直接用脚本跑就行了 5.时间盲注 延时注入，页面啥回显都没有的时候，我们需要观察页面的请求时间（ 编写脚本： 根据注入类型的不同，前面的查询需要修改的（ 6.headers注入 就是利用上面的方式，换了个注入点… 例如user-agents（sqli-labs的less-18） cookies referer X-Forwarded-For 7.宽字节注入： 宽字节是多个字节宽度（&gt;1）的编码（GBK,gb2312…） 汉字就是宽字节编码 有些时候传入的参数（单引号）会被addslashes()函数转义，添加反斜杠，但是又因为设定字符集为gbk，导致宽字节的注入 要将反斜杠转义处理掉的方式有： 让（\\）失去作用 让（\\）的编码和另一个编码组合成两字节的编码（使得反斜杠消失） 第二种方法就是宽字节注入： 单引号的编码是%27 反斜杠的编码是%5c 所以我们只需要在单引号前加上%df，此时转义后的反斜杠(%5c)与%df就会组成一个汉字：運(运的繁体,%df%5c) 也就是： 这个时候查询语句就会变成： 剩下的只需要和联合查询一样的地方即可，在前面的单引号添加%df 在爆列名时： 8.二次注入 第一次注册等操作没有注入点，但是第二次操作代入了第一次操作的语句，导致sql注入（ 也就是说，我们提前构造好的语句成功储存进入数据库了，然后第二次操作（例如修改密码）中调用了第一次操作的语句，使得sql语句被执行 … 感觉好像还是没解释好，就是 第一次操作中，我们成功将sql语句储存入数据库中了 第二次操作中，数据库调用了该sql语句，导致sql语句被执行，形成二次注入(?) [RCTF2015] EasySQL 例如该题就是二次注入： 需要我们注册一个账户： 尝试注册一个叫1’的账户，注册成功，此处没有注入点 发现能修改密码，这种先注册再修改密码的操作很可能有二次注入 发现同样没有任何问题… 可能是单引号的问题，尝试换成双引号再注册一个用户 然后修改密码，发现报错： 说明是双引号型的二次注入，并且有报错，可以使用报错注入： 回显 invalid string，说明有过滤 可能是过滤了空格，所以我们使用括号替代空格： 发现还是回显invalid string 所以有可能也过滤了and，使用&amp;&amp;替代空格： 注册成功，然后修改密码 爆出库名web_sqli 注册用户 然后修改密码，爆出表名：article flag users 注册用户 然后修改密码，爆列名 注册用户 爆flag 发现flag并不在flag表内，回去看users表： 发现real_flag_1s_her 然后尝试 然后报错了… 没有这一列 突然才意识到报错注入有32个字符长度的限制， 尝试倒序查看列名： 果然，列名是real_flag_1s_here 然后爆flag： 发现很多xxx，列名内有很多xxx，占用了32个字符长度 regexp函数：正则匹配，返回特定字符串 flag的格式就是flag{xxx} 所以只需要匹配含有f的字符串即可 组合一下就行了，注意重复的地方 9.无列名注入 适用于information_schema表被过滤的情况 爆库名： 使用mysql.innodb_table_stats时，不储存列名 爆表名： 对列的处理： 先判断该表内有几列 然后给列都取一个名，然后读取这个名字的内容 判断列数： database.table为数据库名.表名 回显了多少个1就说明有几列 例如： 给列取名字读取： 10.insert注入 SQL语句： 此时构造语句 语句就会变成： xxxxx可以是报错注入的updatexml，也可以是时间盲注的语句，取决于你用何种注入方式： 11.join+报错注入 updated in 2023/3/11 利用重复查询相同表的方法来爆数据： sql语句： 搭配报错注入： 0x06 结束 嗯，凑数标题（ 老采集了我 参考资料： sql注入详解 [RCTF2015]EasySQL 1 "},{"title":"NepNep x CatCTF    WriteUp","date":"2023-01-02T03:07:03.000Z","url":"/posts/22778.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF WriteUp","/categories/CTF-WriteUp/"]],"content":"又是被虐爆的一天，太难了 Misc MeowMeow 将图片拖入WinHex，会发现在文件的后半部分藏有flag Nepnep 祝你新年快乐啦 评论区置顶评论： CatchCat GPS Visualizer: Draw a map from a GPS data file 通过这个绘制出猫猫的行动路径，即可获取flag （为什么这玩意这么难看，这两个题都是考眼力的） Crypto Cat’s gift 将礼物分成了四份，说明结果需要乘4，其中一份是1-1/3+1/5-1/7+… 这个级数其实就是 （大抵是这样） 所以最后的值就是π（所以直接交pi是错的 看到flag的格式都是食物，所以应该是派 Web ez_js 直接进入**/js/game.js** 看到下面的函数： 访问/g3t_fl4g即可 ezbypass 华夏ERP漏洞之授权绕过漏洞+后台命令执行漏洞=未授权命令执行 | CN-SEC 中文网 参考这篇文章，可以绕过验证漏洞直接访问flag.html payload: /a.css/…/flag.html 或者**/login.html/…/flag.html** Catcat 蓝帽杯 2022 web/misc writeup - 腾讯云开发者社区-腾讯云 (tencent.com) 进入靶机，点击猫猫 可以看到url的变化，推测有目录穿越 尝试 成功，所以通过 查看当前进程，回显app.py 通过 获取到源码： 可以看到是flask（ 在/admin路由内，如果session的admin=1的话就会回显flag 而通过burp抓包访问/admin会回显set cookie: session… 所以应该是需要我们伪造一个session并且将设置的session修改掉 伪造session需要知道SECRET_KEY 这个思路在文章中有提及： 通过/proc/self/maps读取堆栈分布，然后通过/proc/self/mem读取内存分布，获取secretkey 这里使用thai大师傅的dump.py 先通过?file=../../../../../../../../proc/self/maps获取堆栈分布，将其内容复制并保存至source.txt 然后使用dump.py获取secretkey： 获取到secretkey后使用flask-session-cookie-manager即可 最后修改cookie即可 "},{"title":"Buuoj SSRF Me 题解","date":"2022-12-28T03:40:42.000Z","url":"/posts/6505.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"昨天做到的一个很好的题目（个人觉得），写出来给大家看看（ 打开靶机 打开靶机，直接看到源码，并且能够看到提示，flag在flag.txt内： 但是这源码也太恶心人了吧，这谁看得懂啊… 然后经过我不懈的努力（雾 把源码整理好了： 审代码 接下来慢慢对代码进行审计即可： 获取flag 整理一下大概就是如下的思路： 通过exec函数读取flag.txt的内容，而flag.txt的内容会被scan的action存储在result.txt中 我们只需要获得read方法读取即可： sign，action在/De1ta路由中由cookie传入，而param由get方法传入 所以我们需要先访问/geneSign路由，然后param=flag.txtread 返回一个值：(055967a25e4ba3f082a3ab94e0344994) 注：这个值随每次靶机打开都是不一样的 这个值就是flag.txtreadscan的sign值： 而我们传入的参数param，action又是flag.txt、readscan，完美符合sign值 然后使用bp抓包，添加cookie，修改url即可： 结束~ 另解：哈希长度拓展攻击 虽然但是我并不知道这个怎么用，在这里贴出大佬的wp吧（ De1CTF ssrf_me 的三种解法 - 先知社区 (aliyun.com) 略略水一篇博客没人骂我的吧~"},{"title":"Buuoj题目(3)","date":"2022-12-24T03:28:18.000Z","url":"/posts/46695.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ 没想到这个连续剧居然做到第三集了（？ [GWCTF 2019] 我有一个数据库 打开靶机，一眼乱码… 使用charset改编码： 好，那就用dirsearch开找，由于万恶的反爬，还是只能用低线程： 跑出了phpmyadmin和robots.txt 访问robots.txt 发现提示是phpinfo.php 所以直接选择看/phpmyadmin/ 发现是phpmyadmin 4.8.1的版本 然后就上万能的CSDN… 发现有本地包含漏洞 直接拿漏洞打就完事了： payload： [BJDCTF2020] Mark loves cat 变量覆盖题。 进入靶机，就是一个贼酷炫的前端页面（ 然后啥也点不了 这个时候就要考虑是不是有dirsearch可以扫出来的东西了 使用dirsearch 能够扫描出/.git/ 使用githack下载源码： 所以思路很清晰，只需要将上面那三个变量选一个覆盖成$flag，然后再满足你所选择变量的exit条件即可 (虽然但是我到现在都不知道handsome要怎么做，怎么让flag=一个变量，这个变量又不能等于flag啊) 方法一： 如果选择yds： 首先将yds覆盖成flag： 然后… 如果GET传入flag和POST传入的flag都是空的话，就exit了 所以直接结束 方法二： 如果选择is： 还是先将is覆盖成flag： 看条件，如果get或者post传入flag的值为flag时，exit 所以后面传入flag=flag即可 [安洵杯 2019] easy_web 打开一看，也是啥都没有。。。 不过首页那个img=比较奇怪，看起来像base64加密 把他拖入CyberChef，发现其经过了1次Hex加密和2次base64加密 最初的结果是555.png 大抵就是那张图片？ 利用这个原理，我们将555.png改为index.php，然后进行同样的加密，尝试获取源码： 这里最大的问题就是如何使得一个字符串a的值不等于b，md5的值又要强相等（如果是两个等号，可以使用0e开头的md5） 使用 fastcoll 快速MD5碰撞生成器： 可以构建两个md5值一样，但是内容完全不一样的字符串 使用方法如下： 创建一个文本文件，写入内容，命名 cmd运行： fastcoll_v1.0.0.5.exe -p init.txt -o 1.txt 2.txt（其中init是你创建的文本文件，1.txt和2.txt是生成的两个文本的txt文件） 然后需要进行一步url编码才能够正常使用： result： 由于字符串比较长，所以使用burp进行Post传参：对于过滤，使用反斜杠绕过，空格使用%20进行url编码（burp里面打那个空格直接bad request了）： 找到flag 直接cat /flag "},{"title":"Dandelin双球模型","date":"2022-12-19T09:37:02.000Z","url":"/posts/62938.html","tags":[["不务正业","/tags/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/"]],"categories":[["不务正业系列","/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"]],"content":"最近有个小朋友问我Dandelin用来证明一个平面截圆锥得到的截口曲线是椭圆的模型的题咋做的，我一看，我大意了，不会做… 所以直接去网上百度一下，水了一篇博客出来 0x01 Dandelin模型 你是否在寻找Dandelion() Germinal Dandelin，著名数学家，主要成就有Dandelin双球模型，在圆锥与圆的切线等研究上取得了巨大的成果。其Dandelin的双球模型便是在一个圆锥内塞入两个球，这两个球既与圆锥相内切，又与一个公共平面相切，这个公共平面截圆锥所得到的截口曲线便是圆锥曲线（可以是椭圆、双曲线和抛物线） 0x02 Dandelin双球模型的证明 根据圆锥曲线的第一定义即可证明： 如果平面内一动点与两定点F1、F2的距离之和等于一个常数的轨迹为椭圆 那么我们就有如下的证明过程，假设上面的小圆圆心为O1、大圆圆心为O2，内切球与圆锥的交点为B、C： 所以截口曲线便是椭圆 0x03 截口曲线离心率的计算 离心率计算公式： 那么我们根据几何关系计算出c和a即可 为方便计算取其截面图如上，并且添加辅助线后的图如下（辅助线是手动添加的，可能十分不平整）： 假设D、E是切点，连接O1F1、O2F2、O1D、O2E 又作O1G垂直于O2E，垂足为G（O1、F1、G三点并不共线） 同时设轴线C1C2与平面α的交点为H 夹角为β、与母线的夹角为γ 由上面的推导可得到： 容易证明得到： 就能够将DE转到O1G 接下来提供两种方法（其实二者是一致，实际上只有一种的）： （假设圆的半径，O1O2的距离已知） 法一： 其实细细看来可以进行如下的推导： 这也就是方法二，计算这两个夹角的余弦值即可 其实这两个方法确实是一样的（雾 当然，如果选取的夹角不一样，得到的结论也会略有不同，但是离心率的值仍然是两个角度的比值： 参考了闲敲棋子落灯hua师傅的文章 0x04 小拓展 由该双球模型得出的离心率的取值是由截面与底面的夹角α决定的（一般认为圆锥固定不变） 所以截取的角度不同，所得到的圆锥曲线也不同（根据离心率判断即可） 在某些动点类求轨迹的问题中，也可以通过截面与底面的夹角α，母线与底面的夹角β来确定离心率，从而确定轨迹是何种圆锥曲线 更多的题型可以去参考棋子落灯hua师傅的文章，由于本人能力有限，这里就不作展开 其实真的是因为我又菜又懒，然后啥也不会... 参考文章： 【解题研究】对于圆锥截口曲线性状的Dandelin双球证明 "},{"title":"Buuoj题目(2)","date":"2022-12-15T06:43:46.000Z","url":"/posts/9830.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ [GXYCTF 2019] 禁止套娃 打开靶机，页面直接显示 “flag在哪里呢？” 所以我们使用dirsearch扫描试试，看看是否有敏感文件 不得不说buu的反爬是真的恶心…扫快一点就会弹429 发现/.git/能正常访问 使用githack下载源码，源码如下： 一眼顶针，鉴定为无参数RCE（经典括号嵌套） 这个过滤的挺少，直接祭出payload薄纱： （雾） 好了不闹了，先用： 看flag的位置： 发现在倒数第二，使用array_reverse逆转到第二位，刚好能够使用next函数读取数组的第二位 使用show_source读取php文件即可 [BSidesCF 2020] Had a bad day 打开靶机，发现很多猫图和狗子的图片（雾，重点不是这个） 看看上面的url，发现category= 这引诱人上去加单引号啊（（（ 试试加个单引号 发现报错了，但是报错的不是sql（ 发现了include报错，尝试能不能打开index.php获取源码： 成功读取base64，进行一个解码： 以下是解码的内容： 重点就是传参的内容需要含有woofers或者meowers或者index，才能进行文件的包含，那这个就很简单了，直接加一个woofers/meowers/index到base64-encode后面去即可，payload如下： 获得base64，解码获得flag： [NCTF 2019] Fake XML cookbook 又是我不会的新知识呢 XXE（XML External Entity Injection） 打开靶机，又是登录。。。 尝试弱口令和SQL注入，肯定是不行的 然后使用Burp抓包，发现了一段： 加载了来自外部的实体，导致了可以加载外部文件，可以进行文件的读取 以及加上题目的提示 XML，应该可以执行XXE 一个经典的XXE组成如下（DTD外部实体声明） 所以直接通过burp抓包，然后使用XXE攻击即可 成功获得flag "},{"title":"Buuoj题目(1)","date":"2022-12-09T02:44:14.000Z","url":"/posts/54886.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ [网鼎杯 2018] Fakebook SQL注入兼反序列化 点开靶机，一眼醒目的login和join，尝试login，那肯定是失败的 所以我们试试注册，填好个人信息之后点击提交，但是提示Blog is not valid. 所以应该是博客地址的问题，应该是要一个确切的博客地址 所以这里把博客的地址都填上（只用填github.io的就可以了） 然后观察url发现no=1 于是尝试no=1’ 发现SQL报错了 于是进行SQL注入 回显 no hack _，说明过滤了关键词 接下来就是测试关键词的时候 发现union 无no hack回显 union select 有no hack 回显 应该是过滤了空格 所以使用 发现报错，去掉单引号 发现2号位回显正常 然后上方有个notice: unserialize() 说明有反序列化的存在 爆出库名 fakebook 爆出表名 users 爆出列名 no username passwd data 发现了一串序列化的结果 然后似乎就做不下去了。。。 应该还有一些隐藏的文件吧，打开F12也没有提示 所以应该是存在敏感文件 打开dirsearch扫一下… 不过由于buuoj有反爬这个特性在，所以很难受的就是需要加上delay，使得扫描的过程十分的慢… 推荐盲试 robots.txt www.zip .bak啥的 在robots.txt发现： 直接访问/user.php.bak获得源码 所以我们只需要序列化用file协议写出的flag位置，读入后使用curl就能够返回flag的内容了 flag应该在根目录，那么序列化如下： 所以使用sql的语句写入内容： 如果没有内容，打开F12试试，如果也没有的话就换位置 测试3、4号位： 发现4号位回显正常，打开F12即可获取flag [BJDCTF2020] The mystery of ip smarty 模板注入 打开靶机 点击Flag，发现显示的是你的IP 点击Hint，发现提示： 修改ip的话，应该是X-Forward-For的问题，所以我们使用burp抓包进行测试 修改X-Forward-For为127.0.0.1，显示为127.0.0.1 试试修改为{7*7}，发现显示为49 应该就是ssti模板注入了，然后祭出经典老图 其实也可以通过 查看哪个模板 所以是smarty的ssti注入 smarty的模板注入直接使用系统命令即可： 获得flag [BJDCTF2020]ZJCTF，不过如此 [ZJCTF2019]NiZhuanSiWei的复刻了属于是（雾） 直接看代码： 同样的写入，文件包含以及一个next.php 那我们直接data协议写入，php://filter文件包含即可 获得next.php内的base64代码，进行一个decode 经典再现： 指路Day 4: Baby match（每日一题） preg_replace /e能够执行strolower(“\\\\1”)的内容 preg_replace输入的第一个是正则表达式re，然后将re，然后将re，然后将str的值替换进strtolower(“\\\\1”) 也就相当于是 也就是说我们需要传入一个正则表达式，以及一个需要执行的命令，这个正则表达式能够匹配所有的字符 正则表达式：.*又称为贪婪模式，可以匹配到所有的字符 但是url中不能够使用 . 会被php读取成下划线 所以我们可以使用另外一个正则表达式：\\S* 这个正则表达式可以匹配任何非空字符，等价于： 然后我们传入的命令需要调用getFlag函数，执行eval函数： 所以写成${getFlag()}，而eval函数直接执行get传参cmd传入的命令 所以cmd=system(‘cat /flag’); 但是由于这段代码是在next.php内的，所以我们需要进入next.php并且执行命令 未完待续捏 参考资料： 我的飞书云文档 The mystery of ip "},{"title":"AuroraCTF Write Up","date":"2022-12-03T13:10:01.000Z","url":"/posts/1516.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["RCE","/tags/RCE/"]],"categories":[["CTF WriteUp","/categories/CTF-WriteUp/"]],"content":"本萌新第二次参加的比赛，毕竟是新生赛，各位师傅都很手下留情了qwq。 我主要做web方向，也做一点简单的Misc和Crypto方向的题，反正就是不看提示和百度基本上做不出来的那种qwq What is CTF((( 简单说找flag交上去能拿到分，分越高越好（ 好像说了跟没说一样 其形式有解题赛、攻防赛、混合赛等 大致流程为参赛队伍通过攻防对抗，程序分析等形式获得提供环境的一串flag 将其交给主办方… 嗯，大致又分成五个方向：Web、Reverse、Pwn、Misc、Crypto(logy) 其实可能还有BlockChain( 嗯，大概就这样 Web: 呃呃呃，就是处理用户到网站之间的各种安全事件（ 写后门，内网渗透日穿内网巴拉巴拉（（ Crypto：密码学~ Reverse：逆向工程，破解程序获得源代码，从而写外挂（并不） Pwn：漏洞挖掘提权（来源于俚语：攻破设备或系统 反正本采集完全不会pwn… Misc：顾名思义，即为杂项，包含图片或者音频隐写、wireshark的流量分析、一些密码的破译等等等等，甚至能够在Misc里玩到音游，学会Misc，你就能成为全栈爷（雾） 雾 Web soeasyssti 无过滤的ssti jinjia2模板注入，payload： 获得flag Aurora{wu_wu_Just_@_Fl@sk_Test!} 刻猫猫 F12打开获得传参点 所以 wifestring(33) “Aurora{GensheN_1s_v3ry_fantastiC}” 原神3.2 这里其实是我先用dirsearch扫了一遍发现的www.zip 然后下载下来解压会发现source.js 是一串jsfuck代码，需要使用提供的网站解码（我也不知道为什么，反正我自己找的是解不出来 打开F12，发现secret.php 点进去发现title处就是flag的前半段 组合一下就是 是不是因为没有抽到专武…？ easyrce CTFShow红包题第二弹复刻（雾） get传参，只能使用p和.+`等 嗯，那就差不多了 构造PostPoc 网页处传参 回显fl3g.txt 直接cat即可 AURORA{0h_n1c3!} easyinclude putenv函数将环境从bin更改，调用函数的时候需要添加绝对路径 如 ls --&gt; /bin/ls die码如下： revengessti ssti模板注入，过滤了单引号、下划线 使用ctfshow366的payload： 这里是使用cookie传参 flag=Aurora{Request_reQuest_@ll_requesT!!} 关于ssti，本萌新其实真的不懂qwq letmeguess 每日一题的靶场做过一次了，所以比较简单 提示是登录的密码是弱密码，所以可以直接用字典爆（ 爆出来的结果就是admin123 然后就可以使用ping了，ping后面可以夹带其他命令，比如ls、cat啥的 这里如果直接使用|ls的话会显示非法语句，说明存在过滤 应该是preg_match型（同样使用%0a绕过 发现 这个kylin应该就藏有flag 输入cat login.php/index.php发现被过滤 这里的过滤应该是cat / 空格 /两者都有 所以干脆直接全换了：空格换成%09、cat换成nl/echo/tac payload: Tha1nodeshell 额，这个是不可见字符成的后门，可以通过visual studio code 看见 可以通过这个字符传递参数，执行命令 打开F12 提示/read 和flag在环境变量内 这里的post file其实是使用post方法传递一个file 不是上传文件… 由于是nodejs，所以可以访问app.js 其实这里也能看得到的，逗号后面空了一个 这里漏掉的字符可以进入checkcommands 执行命令 所以可以使用这个字符执行命令，并且写入一个文件中，再读取即可 大概如此，然后读取1.txt即可 another_vn_node 啊这个是取巧做的（ 使用CVE-2022-21824进行攻击（ submit之后直接查看/flag Aurora{78929acd-3456-4483-b043-c9c5fa1a5a59} babysql 喜提-52分，看了提示才知道是无列名注入 omo 提示 使用mysql.innodb_table_stats时，不储存列名，这也是为什么叫无列名注入 使用提示爆出库名、表名 很明显flag表内的内容就是我们需要的内容，接下来我们要读取它的列 无列名注入的大概意思就是 给表里面的列取个名，然后读取它 根据提示的命令得知过滤了空格，回显位置为3 自己测试发现过滤了#、–+ 所以这里使用了单引号闭合 不要问我怎么测出来的，一个劲的搞时间盲注，我是铸币 hard_rce hhh，写过的demo里面提到过确实很难，搞不懂，现在再看应该还是这样的 学习一下即可，die码如下 可以看出过滤了很多函数、同时这个preg_replace处限制了我们只能够使用无参数rce（函数嵌套括号） 这就让我想起了之前做的一个题的payload： 然后一看，var_dump、array、pos、localeconv全被过滤了，寄 但是万幸没有过滤show_source和scandir 可以通过scandir(‘.’)返回的内容使用show_source()显示出来，然后flag应该是在最末尾（这里比较幸运的就是撞对了），可以使用end()读取，所以关键就是构造出那个点（pos(localeconv())就是返回这个点） 而仔细看没有过滤chr 而点又是chr(46)，所以这里只需要构造出46就好了 接下来就是借鉴dalao写的wp里面的内容了 使用burp的intruder模块进行爆破就好了 flag: Aurora{you_are_so_great} Misc xnheulpb 百度一下题面xnheulpb 发现其名为小鹤双拼 根据打字的方法打出这几个字即可 绝密信息 提示是有标记，所以拖进stegsolve查看 Check in 找出这段文字不和谐的地方即可 题外话:想起自己怎么做这个题的时候就笑死了 day 1: 欸为什么这么长一段英文啊，然后仔细看看，On!y是什么鬼 然后想起星期五的英文 我明白了，然后去对照哪里有不同（其实拖进word就知道了 然后我就很傻的一直用原来的英文输入flag day 2：躺床上继续想，欸，是不是提交改了之后的英文？ 立刻爬起来 一看 所有错误的英文单词能够组成welcome! 那没事了 PING 打开Wireshark查看ping的内容即可 会发现每次ping的最后总会返回一个字符 而露出破绽的地方就在{，是flag的格式（ 所以打开查看每一个ping的数据就能找到flag了 图片太多了qwq，懒得保存了 组合一下就是 Aurora{Wh4t_1s_PING?} Location 推荐使用 exif在线查看一把梭 EXIF信息查看器 然后配合 经纬度格式转换工具软件使用 StrongMan Hint: Faster; Higher; Stronger. Come and see him in all his glory. Higher处加粗、附件是三张图片，应该是提示修改图片高度 使用010Editor修改即可 修改宽高后即可看到flag： （第一张图是Aurora{W） WebShell 既然是webshell，那么hacker肯定需要通过eval函数post一些东西执行命令 然后会回显结果 所以我们直接查查执行的命令以及回显的结果 也就是 http contains c 发现回显的内容是一串base64，解码即可 Barcode 条形码解密，附件是缺失定位码的QRCode、Maxicode、dotcode、pdf417 直接修补定位码、然后全部丢进去Dynamsoft Barcode Reader 这个也是能直接读取pdf的（ 结束~ WebShell 2 同样是webshell，所以搜索http contains c 发现hacker是通过上传webshell进行攻击的，同时发现了一个zip文件，使用wireshark可以进行导出 保存为1.zip，打开发现需要密码 所以我们还需要在流量内找压缩包的密码 由于hacker是上传的webshell到服务器内，所以我们需要关注他post的内容是啥 这是很明显的蚁剑流量特征（详见看看蚁剑流量包） 解码出来同样也是蚁剑享有的@ini_set头 所以hacker应该是上传了一个webshell到服务器，然后使用蚁剑连接执行的操作 所以我们对其传参的值需要从第三位开始进行base64 decode（也就是删除前两个字符进行解码） 所以我们一个个找POST请求，并且对传参的值进行解码即可 最后在分组202处找到压缩包的密码：CrazyKFCvivo50 然后解压缩即可 Aurora{Antsword_1s_n0thing_mor3_7han_that} Crypto latex喵 latex的每个符号都是由 \\一串英文 构成的 找出构成的符号的英文，取其首字母即可 所以 flag{catflaG} boxlin’s calculator 嗯，真就直接nc 然后算50个简单的加法就好了（雾 记得准备好计算器 easy_hash DoubleFermat 费马分解（ 其实可以偷偷去用yafu或者factordb分解大数 可以将n分解成p、q、r、s 那么phi= (p-1)(q-1)(r-1)(s-1) 然后就是跑脚本 嗯，连带看提示+百度搜索会做的就这么多了，果然我还是太菜了Orz 题目质量很好，明年再来~"},{"title":"简单看看无数字字母RCE","date":"2022-11-19T04:54:29.000Z","url":"/posts/47468.html","tags":[["RCE","/tags/RCE/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"这两天一直在看的玩意，原来我已经菜到啥也不会了，qwq。 简单引入 命令执行： 跑一个过滤字符的php看看能用啥字符 把数字和字母都过滤了，但是大多数符号是能够使用的，所以来看看这个要怎么绕过捏 1.url取反绕过（PHP7） 在PHP7中能够直接进行url取反绕过 结果如下 如果是PHP5的话需要多几步 2.汉字取反 Orz，这个多少带点离谱，通过对汉字取反得到想要的英文字符 参考大佬给出的生成器（雾），可以通过汉字跑出想要的英文字符 只需要修改$shell=''即可，例如assert就可以通过“极区区皮十勺”得到，POST可以通过“寸小欠立”得到 注意：assert在PHP7.0.12以上版本中已经不能够执行命令了（assert()内如果是字符串会当作php代码执行） 取反：~($var1{1}); 所以我们需要用符号构造出1，这里可以使用$_；使得变量的值变为1（i） 这就是执行的结果 3.异或 异或运算：比方5^Z 5的ASCII码是53，转成二进制是00110101，Z的ASCII码是90，转成二进制是01011010，二者异或会得到 01101111，转成字符串就是o 所以我们可以通过这个特性构造出我们想要的字符 接下来就是上大佬的脚本时间了： 所以assert可以通过 得到，注意反斜杠转义需要多加一个\\，即 _POST: 所以可以构造： 同样需要进行url编码 执行成功： 4.自增 运行一下，看看会得出什么？ 很神奇吧，会拼凑出A、B 解释一下：在Dest0g3-520迎新赛中有解释过 . 能够拼接变量，数组拼接字符串会显示Array（第一步） 第二步，截取A A++ =&gt; B; B++=&gt;C…以此类推，可以得到A-Z所有字符，然后不断通过拼接，总能得到： 这里直接上一个题好了（ctfshow的） 同样的过滤了一堆符号，并且不能使用数字，英文字母（ 其实跑一下脚本看看能用什么更加直观： 基本上能用的只有符号，不过没有限制下划线，加号，中括号小括号和$ 然后提示是吃瓜杯的shellme，去看一下，wp是自增构造的 但是这题不能够用任何数字（虽然没多大影响） 只需要构造出A，就能够造出_GET，那就能够传参 只需要传参执行命令即可： 总体payload： 5.Post执行 通过Post一个文件使用#!/bin/sh命令并用.（点）执行这个文件，就可以执行命令 例如 同样经过测试 能用的字符只有： 只能通过一个字母p，但是没有过滤点号和反引号，所以可以使用Post传文件并且通过.执行sh命令 （文件上传后储存的位置在/tmp/php+6个随机字母） 借助一下： burp抓包然后修改一下就可，能够找到/flag.txt，直接cat /flag.txt 有时候也可以直接.+/???/???[@-[]执行，例如ctfshow web入门 55 (只要大小于号、反引号没被过滤基本上能用上面的payload) 而且这个好像只能适用于get传参执行的样子… （注：使用echo+反引号能够执行命令，?&gt;&lt;?=``也相当于echo+反引号） 最后附上过滤字符的php，根据题目的不同修改preg_match就好了（ 芜湖，结束了，摆烂摆烂，反正到时候也是啥都不会~ 6.补充 参考资料： 无字母数字webshell总结 无字母数字webshell之提高篇 | 离别歌 (leavesongs.com) 无字母数字的命令执行(ctfshow web 入门 55) "},{"title":"Dest0g3 520 迎新赛部分write up","date":"2022-11-13T06:42:49.000Z","url":"/posts/32534.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["POST","/tags/POST/"],["RCE","/tags/RCE/"],["Upload","/tags/Upload/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"你管这叫迎新赛… 猛新啊，那没事了。 只有自己不会做的世界达成了 Misc的话… 之后再看看 phpdest require_once绕过 require_once()：引用或者包含外部的一个php文件，但是如果已经包含过一次了，该文件不会再次被包含 源码如下： 可以看见flag.php已经被包含了一次了，所以我们要进行require_once的绕过 参考这篇文章的payload： php源码分析 require_once 绕过不能重复包含文件的限制 | CN-SEC 中文网 进行base64解码后就能获得flag 成功获得flag EasyPHP 提示：Post something 认识set_error_handler() 源码如下： 上面那个if的条件肯定是实现不了的，哪里有大于24小时或者31天或者60秒的时候啊 所以关键就是在set_error_handler()上了 这个函数是，当报错时，就会执行 也就是我们要POST传参让其报错（ 又因为$fl4g 和 $dest0g3之间有个. 代表拼接 （例如fl4g=a dest0g3=b 之后的结果就是ab） 但是php中，数组和字符串是不能拼接的，会报错 所以我们传入数组 就会报错，执行set_error_hanlder 打印fl4g SimpleRCE 学到了新姿势… Try Try hex2bin 源码如下： 我的妈，那叫一个地狱绘图 ban掉了: ^ 、.、`、大于号、小于号、等于号、双引号、正则preg、&amp;、|、%0、{}、$、+、\\ 然后ban掉了常用的eval执行的命令 但是，唯独少了个单引号 参考了dalao的wp，发现一个神奇的函数：hex2bin() hex2bin()：转换十六进制字符为二进制ASCII字符串 用法：hex2bin(‘hexcode’) 例：echo hex2bin('68656c6c6f20776f726c64'); //输出Hello World 所以没有过滤单引号给我们使用了hex2bin的机会 只需要构造出system(‘cat /flag’)就结束了 system --&gt; 73797374656d cat /flag --&gt; 636174202f666c6167 也就是构造 aaa=hex2bin('73797374656d')(hex2bin('636174202f666c6167')); 成功获取flag funny_upload .htaccess的新姿势 文件上传的新姿势 打开F12可以看到如下脚本： 对后缀做了要求，我第一次做的时候直接传.htaccess和图片🐎蚁剑是连不上的= = 看看wp，要用php包含的方式连蚁剑，我也不知道为什么，挺神奇的 我们的.htaccess参数有： .htaccess中使用auto_prepend_file与auto_append_file能在所有页面的顶部和底部require文件 php_value auto_prepend_file 在页面顶部加载文件 php_value auto_append_file 在页面底部加载文件 所以我们传入的.htaccess文件内容如下： 然后传个1.txt 蚁剑连接，找到flag Really Easy SQL 延时盲注（过滤sleep()，substr()） 输入啥都没反应，由于又是SQL注入，很容易想到延时盲注 提示是insert注入 所以payload的格式有：0' or payload or' 采用NewStarCTF的延时盲注脚本就可以了 但是这里直接使用会发现啥也没有，那肯定是过滤了字段 找了找writeup： 发现给了黑名单 过滤sleep和substr 所以我们的payload修改下，mid能够替换substr，benchmark能替换sleep benchmark：让数据库反复多次做一件事，增大延迟（比如执行2500000次的MD5加密） 这个benchmark的误差真的太大了，注意使用时按照延迟修改下keep>的参数 尤其是跑table和column的时候，那个误差，会输出全是~ 同样使用二分脚本即可，payload编写方式与NewStarCTF 的延时盲注一致 同样的，睡一觉起来就能拿到flag了 先去睡会吧~ 不通顺的地方我也没办法，benchmark真的就是误差太大了，我这边使用3000000次和1.8能跑出flag EasySQL 和上一题是一样的，但是过滤了大小于号… 那么我们就不能够用二分跑了，只能一个个遍历，我靠 用二分能够稍微提速，遍历那就是坐牢中的坐牢了（我手机点完外卖了都没跑完一个） 同样写脚本，只需要注意什么时候中断循环就行了 同样使用3000000次和1.8的keep，跑出来的结果是最精确的 当然也可以试试(32,127)，正向跑，不知道正向跑和反向跑哪个快点呢= = 这是真的慢啊啊啊啊啊 跑了大概17、8分钟后，终于跑完了 会看wp然后会做的就这点了，剩下的啥都不会做，寄寄寄 参考资料： .htaccess文件解析漏洞 Dest0g3 520迎新赛 web部分 wp PHP字符串函数hex2bin require_once 绕过 还是开摆吧，呜呜 Orz"},{"title":"看看蚁剑流量包","date":"2022-11-10T15:37:24.000Z","url":"/posts/39070.html","tags":[["POST","/tags/POST/"],["Misc","/tags/Misc/"]],"categories":[["CTF Misc","/categories/CTF-Misc/"]],"content":"今天来看看Misc（雾） 只是简单的看一下蚁剑上传的包被wireshark抓包以后的形式 工具准备 Wireshark / Burp Suite （抓包工具，如果使用Burp需要在蚁剑设置代理） 中国蚁剑（AntSword） 以及测试靶机（使用校内靶机进行测试） 开始测试 1.使用txt文档写一个简单的一句话木马 &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; 然后修改成1.php 2.随后上传至靶机，使用蚁剑连接。连接成功后打开虚拟终端 3.使用Wireshark监听数据，虚拟终端内输入whoami，将会获得如下图POST包 也可以输入其他命令（比如我输入的是cd /var/www/html/） 3.1 如果你使用的是Burp Suite，打开监听，设置蚁剑的代理为127.0.0.1:8080 然后重复3.的步骤 可以将其复制出来，会发现仅有简单的urlencode，使用解码工具就能够得到以下代码： 又长又臭的一段代码 分析源码 开头：朴实无华的post（连接的密码） 存在有以下的特征： 以@ini_set(&quot;display_errors&quot;, &quot;0&quot;); @set_time_limit(0);开头，由于蚁剑是明文传输，所以很容易被发现 后面有base64字符 以及数据包内存在base64加密的分段内容，经过解码后可以看到路径 命令 以及随机数（后面会看见） 使用eval执行 注：旧版蚁剑还有的特征在user-agent处，请求头是antsword xxx，但是在新版的蚁剑中此特征已被移除。UA头已经改为默认ua头了（下图为旧版蚁剑的UA头） 可以看见function占大部分，而且发送指令时，代码和指令是一块发送的（例如发送了其他post的指令） 就像下面的post指令 使用wireshark可以看到传参的值 将传参的值使用base64解码（注意，从第三位开始才能正常解码），解码结果如下 基本上只有简单的加密 Base64加密 在编码器中选择base64加密 wireshark抓包后的结果如下 可以看到明显的base64 eval函数 Value: @eval(@base64_decode($_POST['c540d73cacbdc8'])); 经过base64解密，可以看到如下图所示的结果 可以看得出来，和明文是一样的 chr()加密 结果大同小异 同样解码后还是经典的@ini_set(&quot;display_errors&quot;, &quot;0&quot;); RSA加密 在蚁剑的编码器管理中生成RSA密钥 传上去的流量包是这样的，毫无规律 大概就是这样了 写的很水，也不会做Orz 参考资料： 菜刀、蚁剑、冰蝎、哥斯拉特征码 蚁剑流量分析 大佬轻喷qwq"},{"title":"Buuoj Hack World 题解","date":"2022-11-09T05:08:46.000Z","url":"/posts/60450.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["POST","/tags/POST/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"续接上文 打开靶机 同样是sql注入，题面已经提示我们flag在flag表的flag列里了 接下来我们只需要查询就好了 检测注入方式 输入1’ 回显bool(false) 没有报错信息 使用堆叠注入和联合查询 均回显SQL Injection Checked. 那只能考虑盲注，测试下是否有两种回显方式 使用1^1 和1^0 测试 发现1^1时，回显Error 发现1^0时，回显Hello, glzjin wants a girlfriend. 说明可以使用盲注 直接跑脚本就行了 把昨天的脚本复制一下，post传参名称改为id就好了（题目提示要我们提供id） Payload 但是这里跑是跑不出结果的 问题分析 测试语句 1^(ascii(substr((select(group_concat(flag))from(flag)),1,1))&lt;104) (因为flag的第一个字母f的ascii是102) 发现SQL Injection Checked 所以说某些词被检测到了 经测试… 当输入select(group_concat(flag))时，检测到了SQL注入 修改Payload 如果列内只有一个数据，可以不使用group_concat 因为flag列只有一个flag（ 所以脚本payload改为 1^(ascii(substr((select(flag)from(flag)),%d,1))&lt;%d)%(i,mid) 成功拿到flag PS：不要直接copy我的flag，这个题是动态flag"},{"title":"NewStarCTF SQL注入题","date":"2022-11-08T07:24:09.000Z","url":"/posts/40736.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["POST","/tags/POST/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"摆烂大师的第一篇Web文章，qwq。检验我摆烂的水平的时间到了 写写NewStarCTF的SQL注入题吧… 五周考了五个注入，考的点都不一样 NewStarCTF Week 1： Word - For - You 嗯… 这个题其实并不算sql注入，只是让你熟悉SQL的语句罢了 打开靶机 查询语句发现，输入1和输入1’的回显是一致的，根据这个信息能够初步得出考的应该不是SQL注入 SQL万能密码 一般查询数据库执行的语句时 select user_id,user_type,email from users where user_id='用户名' and password='密码' 由于后台进行数据库查询时没有滤过单引号，当输入admin 和 1’ or’1’='1时，执行的语句为： select user_id,user_type,email from users where user_id='admin' and password='1' or'1'='1' 这样子看的话，SQL查询语句被分成了两段： 第一段：select user_id,user_type,email from users where user_id='admin' and password='1' （由于sql语句中逻辑优先度 【=】&gt;【and】&gt;【or】） 第二段：'1'='1' 这两段语句之间的逻辑运算符是or 由于1=1恒为真，所以这段SQL语句恒为真，认证成功 payload 使用SQL注入万能密码查询 1' or'1'='1 拿到flag NewStarCTF Week 2： Word - For - You (2 Gen) 报错注入 / sqlmap一把梭 打开靶机 输入1’ 发现报错，存在SQL注入 测试联合注入 测试字段 输入1' order by 3# 报错 而输入1' order by 2# 回显正常，说明字段数为2 测试回显位 输入1' union select 1,2# 只显示查询成功，说明没有回显位 无法使用联合注入查询 使用报错注入 报错注入适用条件：页面没有回显位，但是页面会有报错信息，例如输入 1' order by 3#的时候 注入语句：updatexml(1,'~',3)，当第二个语句包含特殊字符时，数据库会报错，并且会把参数的内容显示在报错中 需要使用concat语句拼接字符串，长串的语句使用group_concat 查询命令： 1' and updatexml(1,concat('~',database()),3)# --爆库 爆出库名wfy 1' and updatexml(1,concat('~',(select group_concat(table_name) from inforamtion_schema.tables where table_schema=database())),3)# --爆表 1' and updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_name='wfy_comments')),3)# --爆列名 爆出的列名为id,text,user,name,display 我们只需要查询text的内容即可 payload 1' and updatexml(1,concat('~',(select(reverse(group_concat(text))) from wfy_comments)),3)# 要点： 报错注入的查询内容的字符是有限制的，如果内容过多，则无法回显。所以我们这里使用reverse()将flag倒着输出 使用select之前都需要在select前加括号 拿到倒置的flag sqlmap一把梭 sqlmap的使用教程可以查看这篇博客文章 &lt;[(9条消息) 工具使用]SqlMap_拈花倾城的博客-CSDN博客_sqlmap联动msf/&gt; 我们可以使用burp抓包的方式，抓到包的数据存入txt文本内，并使用sqlmap梭哈 将抓包的数据保存至txt文本内 sqlmap -r 1.txt --dbs sqlmap -r 1.txt -D wfy --dump 爆库内容 NewStarCTF Week 3： multiSQL 堆叠注入，sql预处理语句 题目描述：需要我们修改火华老师的成绩，让他通过四级考试 测试联合注入 / 报错注入 输入1' 1均无回显 输入1' union select 1,2,3,4# 发现被过滤 联合注入失败 由于无报错信息，无法使用报错注入 堆叠注入 堆叠注入是将多个sql语句一起执行，使用;间隔的注入方式 输入1';show databases;# 爆库 输入1';show tables;# 爆表 输入1';show columns from score;# 爆列名 修改数据 使用update语句修改分数即可 发现被过滤，怀疑过滤update 所以这里需要我们使用sql预处理语句进行拼接，绕过update的过滤 设置sql语句=拼接u 和后面的语句 预处理sql_exe 执行sql_exe 点击验证成绩即可，然后就能拿到flag 或者 查看分数 点击验证成绩就能获得flag 彩蛋 这里如果修改的分数不一样的话，拿到flag的对话也是不一样的 修改成100分的结果如下 修改成99999分的结果如下 所以这个故事告诉我们不要把分数改的太大（雾） NewStarCTF Week 4： 又一个SQL 异或/布尔盲注 打开靶机 尝试性输入1 和 1’ 果然，寄。没有回显位，没有报错信息。 我们常用的三种注入方式已经无效了，所以我们接下来要考虑盲注 由于输入1 和 1’的回显信息是好耶和啊哦（刚好是两种不同的信息） 我们这里输入0试试 发现输入0和输入1是两种不同的回显，这样我们就可以使用盲注了 异或运算 异或的运算有： 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 0 = 0 0 ^ 1 = 1 也就是说，两件事的异或运算中，如果有一真一假，就会输出1 如果两件都是真，则输出0 那么我们就可以通过异或运算构造sql语句查询 1^(length(database())=3) 注：如果过滤空格，则需要通过加括号的方式进行绕过，此题过滤了空格，所以要在length前加括号 如果数据库的名称长度为3，则为真 1^1 = 0，传的数据为0，回显为啊哦 如果数据库的名称长度不为3，则传的数据为1，回显为好耶 通过不断更改=后面的数字，可以得出数据库的长度 发现=3时，返回啊哦，则说明数据库长度为3，并且布尔/异或盲注可用~ 接下来就是编写脚本的事情了 编写盲注脚本 采用二分法方式编写盲注脚本 啥是二分法方式？ emmm，盲注的原理是一个字符的ascii码数值与你的数值作比较，需要一个个进行比较输出 比如爆库的一个查询语句是1^(ascii(substr(database(),1,1))=100) 即数据库名称的第一个字符的ascii 与 100 比较，如果是100 即提交0，返回的值是啊哦 而二分法能够缩短这个过程（ 首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。 如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。 如果某一步数组为空，则表示找不到目标元素。 大致意思是取第一个字符的ascii值和ascii（32，128）中间值，也就是80（刚好是常用的字段）作比较，如果ascii值大于中间值，从（80,132）的中间值比较,重复比较 直至ascii值相等。 结束一个判断的依据 根据页面返回的信息不同，在我的情况中，如果返回的是啊哦，说明是1^1型，那么，啊哦就是正确的依据 Python编写 这里给出post / get请求的两种盲注的脚本（ 其实你只要跑一次就知道为什么要-1了 最后一次输出的值是&lt;120，返回为真，但是我们此时的mid是120，真正的值是&lt;120 get传参也是如此 这里给出buuoj.cn FinalSQL的盲注脚本 我们愉快的跑脚本就完事了 NewStarCTF Week 5： Final Round 延时盲注 题面提示：啊呜，好困呜呜（sleep） 进入靶机 其实已经不用测什么方式注入了，sleep嘛，延时注入 测试语句： 114514||if(length(database())=3,sleep(0.2),1) 如果数据库名长度为3，休眠两秒再访问（ 肉眼可见的延迟 编写脚本 同样使用python脚本，同样也是post请求，同样也是二分法 套异或的就行了，只不过判断的方式有些不同 bool/异或 是根据1和0的两种回应来判断的，而time是根据访问的时间来进行访问的 然后就等吧… 啊呜，好困呜呜 睡一觉就把表跑完了，放心吧 记得renew 靶机 睡了一觉，终于跑完了（我忘记开最后那个倒序重整了，所以flag是倒着的） flag{Ju2t_let_me_sleep_f0r_a_while} 结束辣，好题，但是结束了才会做呜呜呜 看我摆烂的结果如何？ 题目来自：buuoj.cn //NewStarsCTF 图片来自：截图 侵删qwq"},{"title":"About Me","date":"2022-11-07T14:27:49.000Z","url":"/posts/61421.html","tags":[["Introduce_Myself","/tags/Introduce-Myself/"]],"categories":[["Intro","/categories/Intro/"]],"content":"Err0r233的自我介绍qwq 一个普通的摆烂哥，普通到不能再普通 qwq，梦想是做到一份非常简单的高考数学卷 不开玩笑了，真正的梦想是变得有钱qwq 练习时长两分钟的个人练习生，甚至不能说是练过ctf的呜呜 啥也不会，留着摆烂 哈？没有摆烂的人生哪能叫做好人生啊 博客的内容 偶尔写写题解qwq(x) 摆烂的时候写写东西用的 Thai神的任务罢了 以上三点都是错的 所以我要到什么时候才能有钱啊啊啊啊啊啊啊 Friends 提供一下链接和头像就好了（雾） 图片来自：网络/鹰角网络叙拉古人cg 侵删qwq"},{"title":"Buuoj题目(4)","date":"2022-02-01T03:28:18.000Z","url":"/posts/34405.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ [WUSTCTF2020]颜值成绩查询 熟悉的查询框，输入数字查询成绩 尝试输入1’，显示学生不存在 所以普通的注入失败 尝试使用1^1，发现不存在 1^0发现是admin 所以使用布尔盲注即可 [红明谷CTF 2021]write shell 源码如下： 那这里就很简单了，将我们的shell写进$dir内即可 那要怎么写呢？这里过滤了空格、单引号、下划线、php、分号、波浪号、大括号、eval、+、^ PHP短标签 在之前的webshell里讲过，&lt;?=``?&gt; 相当于命令执行 其中的&lt;?= 相当于echo 所以可以直接这样写： 或者是 然后按命令执行做就可以了，空格用%09替换，单引号用双引号替换，然后访问沙箱路径即可获得回显 [CISCN2019 华东南赛区]Web11 Very水的一个题，感觉不如攻防世界的smarty… 页面显示的是IP Address API 并且写道Build with Smarty 可以推测应该是smarty的xff注入，直接打开burp抓包，修改xff测试： Request包： Respond包： 可以发现执行了加法运算 将xff修改：X-Forwarded-For: {system(‘ls /’)} Request包： Response包： 可以看到成功了，直接读flag即可 X-Forwarded-For: {system(‘cat /f*’)} "}]